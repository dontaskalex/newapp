<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haircut Sim | hafnr</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%230f0f0f'/><text x='4' y='26' font-family='Arial' font-size='26' font-weight='bold' fill='%23fff'>h</text><circle cx='26' cy='24' r='3' fill='%23fff'/></svg>">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7723236991764317"
        crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #f5e6d3;
            --surface: #fff;
            --border: #e0d0c0;
            --text: #3a3a3a;
            --text-dim: #8a8a8a;
            --accent: #ff6b6b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }

        header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .logo {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
            text-decoration: none;
            letter-spacing: 0.05em;
        }

        .back-link {
            color: var(--text-dim);
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s;
        }

        .back-link:hover {
            color: var(--text);
        }

        canvas {
            display: block;
            cursor: none;
        }

        .controls {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            z-index: 100;
        }

        .btn {
            padding: 0.7rem 1.2rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-dim);
            font-size: 0.85rem;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: rgba(0, 0, 0, 0.03);
            border-color: #ccc;
            color: var(--text);
        }

        .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .btn-reset {
            background: rgba(255, 100, 100, 0.1);
            border-color: rgba(255, 100, 100, 0.3);
            color: #e55;
        }

        .btn-reset:hover {
            background: rgba(255, 100, 100, 0.2);
        }

        .hair-color {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0 0.8rem;
            border-left: 1px solid var(--border);
            margin-left: 0.25rem;
        }

        .color-btn {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: var(--text);
        }

        /* Mobile styles */
        @media (max-width: 600px) {
            header {
                padding: 0.75rem 1rem;
            }

            .logo {
                font-size: 0.75rem;
            }

            .back-link {
                font-size: 0.7rem;
            }

            .controls {
                bottom: 0.75rem;
                left: 0.5rem;
                right: 0.5rem;
                transform: none;
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.4rem;
                padding: 0.4rem;
            }

            .btn {
                padding: 0.5rem 0.7rem;
                font-size: 0.75rem;
                gap: 0.3rem;
            }

            .hair-color {
                padding: 0 0.5rem;
                gap: 0.3rem;
                margin-left: 0;
                border-left: none;
                border-top: 1px solid var(--border);
                padding-top: 0.4rem;
                width: 100%;
                justify-content: center;
            }

            .color-btn {
                width: 28px;
                height: 28px;
            }
        }
    </style>
</head>
<body>
    <header>
        <a href="../" class="logo">HAIRCUT</a>
        <a href="../" class="back-link">‚Üê Back to Hub</a>
    </header>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <button class="btn active" id="cutMode" title="Cut hair">‚úÇÔ∏è Cut</button>
        <button class="btn" id="combMode" title="Comb hair">ü™Æ Comb</button>
        <button class="btn" id="fanMode" title="Blow with fan">üí® Fan</button>
        <button class="btn btn-reset" id="resetBtn" title="Grow hair back">üîÑ Reset</button>
        <div class="hair-color">
            <div class="color-btn active" data-color="#2a1810" style="background: #2a1810" title="Black"></div>
            <div class="color-btn" data-color="#8B4513" style="background: #8B4513" title="Brown"></div>
            <div class="color-btn" data-color="#DAA520" style="background: #DAA520" title="Blonde"></div>
            <div class="color-btn" data-color="#ff6b6b" style="background: #ff6b6b" title="Red"></div>
            <div class="color-btn" data-color="#4a9eff" style="background: #4a9eff" title="Blue"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let headX, headY, headRadius;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            headX = width / 2;
            // On mobile, position head higher to account for controls
            const isMobile = width < 600;
            const controlsHeight = isMobile ? 120 : 80;
            headY = (height - controlsHeight) / 2;
            // Larger head on mobile for easier interaction
            headRadius = isMobile ? Math.min(width, height) * 0.22 : Math.min(width, height) * 0.18;
        }
        resize();
        window.addEventListener('resize', () => {
            resize();
            initHair();
        });

        // State
        let mode = 'cut';
        let hairColor = '#2a1810';
        let hairs = [];
        let eyelashes = [];
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;
        let fanAngle = 0;
        let scissorAngle = 0;
        let toolAngle = 0;
        let smoothToolX = 0, smoothToolY = 0;
        let targetToolAngle = 0;

        // Hair strand class
        class Hair {
            constructor(rootX, rootY, angle, length) {
                this.rootX = rootX;
                this.rootY = rootY;
                this.baseAngle = angle;
                this.angle = angle;
                this.length = length;
                this.maxLength = length;
                this.segments = 8;
                this.points = [];
                this.velocities = [];

                // Initialize points along the hair
                for (let i = 0; i <= this.segments; i++) {
                    const t = i / this.segments;
                    const x = this.rootX + Math.cos(this.angle) * this.length * t;
                    const y = this.rootY + Math.sin(this.angle) * this.length * t;
                    this.points.push({ x, y });
                    this.velocities.push({ x: 0, y: 0 });
                }
            }

            update(gravity, wind) {
                // First point is fixed at root
                this.points[0].x = this.rootX;
                this.points[0].y = this.rootY;

                const segmentLength = this.length / this.segments;
                const stiffness = 0.08; // Low stiffness for easy molding
                const damping = 0.9;

                // Apply forces and update positions
                for (let i = 1; i <= this.segments; i++) {
                    const point = this.points[i];
                    const vel = this.velocities[i];

                    // Gravity
                    vel.y += gravity * 0.3;

                    // Wind
                    vel.x += wind.x * 0.1;
                    vel.y += wind.y * 0.05;

                    // Hair wants to return to natural position (very weak)
                    const naturalX = this.rootX + Math.cos(this.baseAngle) * segmentLength * i;
                    const naturalY = this.rootY + Math.sin(this.baseAngle) * segmentLength * i;
                    vel.x += (naturalX - point.x) * stiffness * 0.015;
                    vel.y += (naturalY - point.y) * stiffness * 0.015;

                    // Apply velocity
                    vel.x *= damping;
                    vel.y *= damping;
                    point.x += vel.x;
                    point.y += vel.y;
                }

                // Constrain distances between points
                for (let iter = 0; iter < 3; iter++) {
                    for (let i = 1; i <= this.segments; i++) {
                        const prev = this.points[i - 1];
                        const curr = this.points[i];

                        const dx = curr.x - prev.x;
                        const dy = curr.y - prev.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 0) {
                            const diff = (dist - segmentLength) / dist;
                            curr.x -= dx * diff * 0.5;
                            curr.y -= dy * diff * 0.5;
                        }
                    }
                }
            }

            applyForce(fx, fy, px, py, radius) {
                for (let i = 1; i <= this.segments; i++) {
                    const point = this.points[i];
                    const dx = point.x - px;
                    const dy = point.y - py;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < radius) {
                        const strength = 1 - dist / radius;
                        this.velocities[i].x += fx * strength;
                        this.velocities[i].y += fy * strength;
                    }
                }
            }

            // Comb changes the base angle to style hair
            applyComb(fx, fy, px, py, radius) {
                // Check if any point is near the comb
                for (let i = 1; i <= this.segments; i++) {
                    const point = this.points[i];
                    const dx = point.x - px;
                    const dy = point.y - py;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < radius) {
                        // Adjust base angle based on comb direction
                        const combAngle = Math.atan2(fy, fx);
                        const angleDiff = combAngle - this.baseAngle;
                        // Strongly shift base angle towards comb direction
                        this.baseAngle += angleDiff * 0.12;
                        // Also apply force for immediate movement
                        this.velocities[i].x += fx * 0.8;
                        this.velocities[i].y += fy * 0.8;
                        break;
                    }
                }
            }

            // Fan pushes hair and gradually changes its resting angle
            applyFan(fx, fy, px, py, radius) {
                for (let i = 1; i <= this.segments; i++) {
                    const point = this.points[i];
                    const dx = point.x - px;
                    const dy = point.y - py;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < radius) {
                        const strength = 1 - dist / radius;
                        // Apply force
                        this.velocities[i].x += fx * strength;
                        this.velocities[i].y += fy * strength;
                        // Gradually mold the base angle in blow direction
                        const blowAngle = Math.atan2(fy, fx);
                        const angleDiff = blowAngle - this.baseAngle;
                        this.baseAngle += angleDiff * 0.02 * strength;
                    }
                }
            }

            trycut(x, y, radius) {
                // Check line-segment to circle intersection for each segment
                for (let i = 1; i <= this.segments; i++) {
                    const p1 = this.points[i - 1];
                    const p2 = this.points[i];

                    // Vector from p1 to p2
                    const segDx = p2.x - p1.x;
                    const segDy = p2.y - p1.y;
                    const segLenSq = segDx * segDx + segDy * segDy;

                    // Vector from p1 to cut center
                    const toDx = x - p1.x;
                    const toDy = y - p1.y;

                    // Find closest point on segment to cut center
                    let t = 0;
                    if (segLenSq > 0) {
                        t = Math.max(0, Math.min(1, (toDx * segDx + toDy * segDy) / segLenSq));
                    }

                    // Closest point on segment
                    const closestX = p1.x + t * segDx;
                    const closestY = p1.y + t * segDy;

                    // Distance from cut center to closest point
                    const distX = x - closestX;
                    const distY = y - closestY;
                    const dist = Math.sqrt(distX * distX + distY * distY);

                    if (dist < radius) {
                        // Cut at this segment - calculate exact cut ratio based on current length
                        const cutRatio = ((i - 1) + t) / this.segments;
                        this.length = this.length * cutRatio;
                        this.maxLength = this.length; // Update max length for future cuts
                        const newSegments = Math.max(2, Math.floor((i - 1) + t));
                        if (newSegments < this.segments) {
                            this.segments = newSegments;
                            this.points = this.points.slice(0, this.segments + 1);
                            this.velocities = this.velocities.slice(0, this.segments + 1);
                        }
                        return;
                    }
                }
            }

            draw(ctx, color) {
                if (this.length < 5) return;

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);

                // Use quadratic curves for smooth hair
                if (this.points.length > 2) {
                    for (let i = 1; i < this.points.length - 1; i++) {
                        const xc = (this.points[i].x + this.points[i + 1].x) / 2;
                        const yc = (this.points[i].y + this.points[i + 1].y) / 2;
                        ctx.quadraticCurveTo(this.points[i].x, this.points[i].y, xc, yc);
                    }
                    // Draw to the last point
                    const last = this.points[this.points.length - 1];
                    ctx.lineTo(last.x, last.y);
                } else {
                    for (let i = 1; i < this.points.length; i++) {
                        ctx.lineTo(this.points[i].x, this.points[i].y);
                    }
                }
                ctx.stroke();
            }
        }

        // Eyelash class (simpler than hair)
        class Eyelash {
            constructor(rootX, rootY, angle, length) {
                this.rootX = rootX;
                this.rootY = rootY;
                this.baseAngle = angle;
                this.length = length;
                this.tipX = rootX + Math.cos(angle) * length;
                this.tipY = rootY + Math.sin(angle) * length;
                this.velX = 0;
                this.velY = 0;
            }

            update(wind) {
                // Apply wind force
                this.velX += wind.x * 0.15;
                this.velY += wind.y * 0.15;

                // Spring back to natural position
                const naturalX = this.rootX + Math.cos(this.baseAngle) * this.length;
                const naturalY = this.rootY + Math.sin(this.baseAngle) * this.length;
                this.velX += (naturalX - this.tipX) * 0.15;
                this.velY += (naturalY - this.tipY) * 0.15;

                // Damping
                this.velX *= 0.8;
                this.velY *= 0.8;

                // Apply velocity
                this.tipX += this.velX;
                this.tipY += this.velY;

                // Constrain length
                const dx = this.tipX - this.rootX;
                const dy = this.tipY - this.rootY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    this.tipX = this.rootX + (dx / dist) * this.length;
                    this.tipY = this.rootY + (dy / dist) * this.length;
                }
            }

            applyForce(fx, fy, px, py, radius) {
                const dx = this.tipX - px;
                const dy = this.tipY - py;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < radius) {
                    const strength = (1 - dist / radius) * 2;
                    this.velX += fx * strength;
                    this.velY += fy * strength;
                }
            }

            draw(ctx) {
                ctx.strokeStyle = '#2a1a10';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.rootX, this.rootY);
                ctx.lineTo(this.tipX, this.tipY);
                ctx.stroke();
            }
        }

        // Initialize hair and eyelashes
        function initHair() {
            hairs = [];
            eyelashes = [];

            // Create hair around the top of the head (symmetrically)
            const hairCount = 500;
            for (let i = 0; i < hairCount; i++) {
                // Angle around the head - symmetric from -PI to 0 (top half)
                // Goes from left side (-PI) through top (-PI/2) to right side (0)
                const headAngle = -Math.PI + (i / (hairCount - 1)) * Math.PI;

                // Skip the very bottom portions (near ears)
                if (headAngle > -0.1 || headAngle < -Math.PI + 0.1) continue;

                const rootX = headX + Math.cos(headAngle) * headRadius;
                const rootY = headY + Math.sin(headAngle) * headRadius;

                // Hair falls straight DOWN
                const hairAngle = Math.PI / 2 + (Math.random() - 0.5) * 0.05; // Straight down with tiny variation

                // All hair ends at the same Y level below the head
                const targetY = headY + headRadius + 100; // Uniform end point below chin
                const hairLength = Math.max(50, (targetY - rootY) / Math.sin(hairAngle)) + (Math.random() - 0.5) * 8;

                hairs.push(new Hair(rootX, rootY, hairAngle, hairLength));
            }

            // Create eyelashes
            const eyeY = headY - headRadius * 0.1;
            const eyeSpacing = headRadius * 0.35;

            // Left eye lashes
            for (let i = 0; i < 6; i++) {
                const lashAngle = -Math.PI * 0.85 + (i / 5) * Math.PI * 0.7;
                const lashX = headX - eyeSpacing + Math.cos(lashAngle) * 14;
                const lashY = eyeY + Math.sin(lashAngle) * 11;
                eyelashes.push(new Eyelash(lashX, lashY, lashAngle, 8));
            }
            // Right eye lashes
            for (let i = 0; i < 6; i++) {
                const lashAngle = -Math.PI * 0.85 + (i / 5) * Math.PI * 0.7;
                const lashX = headX + eyeSpacing + Math.cos(lashAngle) * 14;
                const lashY = eyeY + Math.sin(lashAngle) * 11;
                eyelashes.push(new Eyelash(lashX, lashY, lashAngle, 8));
            }
        }
        initHair();

        // Mode buttons
        const cutModeBtn = document.getElementById('cutMode');
        const combModeBtn = document.getElementById('combMode');
        const fanModeBtn = document.getElementById('fanMode');
        const resetBtn = document.getElementById('resetBtn');
        const colorBtns = document.querySelectorAll('.color-btn');

        function setMode(newMode) {
            mode = newMode;
            cutModeBtn.classList.toggle('active', mode === 'cut');
            combModeBtn.classList.toggle('active', mode === 'comb');
            fanModeBtn.classList.toggle('active', mode === 'fan');

            if (mode === 'cut') canvas.style.cursor = 'crosshair';
            else if (mode === 'comb') canvas.style.cursor = 'grab';
            else if (mode === 'fan') canvas.style.cursor = 'pointer';
        }

        cutModeBtn.addEventListener('click', () => setMode('cut'));
        combModeBtn.addEventListener('click', () => setMode('comb'));
        fanModeBtn.addEventListener('click', () => setMode('fan'));
        resetBtn.addEventListener('click', initHair);

        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                colorBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                hairColor = btn.dataset.color;
            });
        });

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            lastMouseX = mouseX = e.clientX;
            lastMouseY = mouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
            // Initialize smooth tool position on first move
            if (smoothToolX === 0 && smoothToolY === 0) {
                smoothToolX = mouseX;
                smoothToolY = mouseY;
            }
        });

        canvas.addEventListener('mouseup', () => isMouseDown = false);
        canvas.addEventListener('mouseleave', () => isMouseDown = false);
        canvas.addEventListener('mouseenter', (e) => {
            smoothToolX = e.clientX;
            smoothToolY = e.clientY;
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isMouseDown = true;
            lastMouseX = mouseX = e.touches[0].clientX;
            lastMouseY = mouseY = e.touches[0].clientY;
            smoothToolX = mouseX;
            smoothToolY = mouseY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchend', () => isMouseDown = false);

        // Draw head
        function drawHead() {
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(headX + 5, headY + 10, headRadius, headRadius * 1.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#ffd5b5';
            ctx.beginPath();
            ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = '#ffc8a8';
            ctx.beginPath();
            ctx.ellipse(headX - headRadius - 8, headY, 12, 18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(headX + headRadius + 8, headY, 12, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            const eyeY = headY - headRadius * 0.1;
            const eyeSpacing = headRadius * 0.35;

            // Eye whites
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(headX - eyeSpacing, eyeY, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(headX + eyeSpacing, eyeY, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = '#3a2a1a';
            ctx.beginPath();
            ctx.arc(headX - eyeSpacing + 2, eyeY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(headX + eyeSpacing + 2, eyeY, 6, 0, Math.PI * 2);
            ctx.fill();

            // Eyebrows
            ctx.strokeStyle = '#4a3520';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            // Left eyebrow
            ctx.beginPath();
            ctx.moveTo(headX - eyeSpacing - 18, eyeY - 22);
            ctx.quadraticCurveTo(headX - eyeSpacing, eyeY - 28, headX - eyeSpacing + 18, eyeY - 20);
            ctx.stroke();
            // Right eyebrow
            ctx.beginPath();
            ctx.moveTo(headX + eyeSpacing - 18, eyeY - 20);
            ctx.quadraticCurveTo(headX + eyeSpacing, eyeY - 28, headX + eyeSpacing + 18, eyeY - 22);
            ctx.stroke();

            // Nose
            ctx.fillStyle = '#eec0a0';
            ctx.beginPath();
            ctx.ellipse(headX, headY + headRadius * 0.2, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.strokeStyle = '#c98a70';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(headX, headY + headRadius * 0.35, 15, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }

        // Draw realistic comb
        function drawComb(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 2);

            // Comb body
            const combWidth = 50;
            const combHeight = 12;
            const toothCount = 12;
            const toothLength = 25;
            const toothWidth = 2;

            // Main body (rounded rectangle)
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.roundRect(-combWidth / 2, -combHeight / 2, combWidth, combHeight, 4);
            ctx.fill();

            // Darker top edge
            ctx.fillStyle = '#6B3510';
            ctx.beginPath();
            ctx.roundRect(-combWidth / 2, -combHeight / 2, combWidth, 3, [4, 4, 0, 0]);
            ctx.fill();

            // Teeth
            ctx.fillStyle = '#8B4513';
            for (let i = 0; i < toothCount; i++) {
                const tx = -combWidth / 2 + 6 + i * ((combWidth - 12) / (toothCount - 1));
                ctx.beginPath();
                ctx.roundRect(tx - toothWidth / 2, combHeight / 2 - 2, toothWidth, toothLength, [0, 0, 1, 1]);
                ctx.fill();
            }

            // Highlight on body
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.roundRect(-combWidth / 2 + 3, -combHeight / 2 + 2, combWidth - 6, 3, 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw realistic scissors
        function drawScissors(x, y, angle, openAngle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            const bladeLength = 35;
            const handleLength = 25;
            const handleWidth = 18;

            // Top blade
            ctx.save();
            ctx.rotate(-openAngle);

            // Blade
            ctx.fillStyle = '#C0C0C0';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(bladeLength, -3);
            ctx.lineTo(bladeLength + 5, 0);
            ctx.lineTo(bladeLength, 2);
            ctx.lineTo(0, 2);
            ctx.closePath();
            ctx.fill();

            // Blade edge highlight
            ctx.strokeStyle = '#E8E8E8';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(5, -1);
            ctx.lineTo(bladeLength, -2);
            ctx.stroke();

            // Handle
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(-handleLength + 5, 0, handleWidth / 2, handleWidth / 2 - 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Handle hole
            ctx.fillStyle = '#f5e6d3';
            ctx.beginPath();
            ctx.ellipse(-handleLength + 5, 0, handleWidth / 2 - 4, handleWidth / 2 - 6, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Bottom blade
            ctx.save();
            ctx.rotate(openAngle);

            // Blade
            ctx.fillStyle = '#A8A8A8';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(bladeLength, 3);
            ctx.lineTo(bladeLength + 5, 0);
            ctx.lineTo(bladeLength, -2);
            ctx.lineTo(0, -2);
            ctx.closePath();
            ctx.fill();

            // Blade edge
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(5, 1);
            ctx.lineTo(bladeLength, 2);
            ctx.stroke();

            // Handle
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.ellipse(-handleLength + 5, 0, handleWidth / 2, handleWidth / 2 - 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Handle hole
            ctx.fillStyle = '#f5e6d3';
            ctx.beginPath();
            ctx.ellipse(-handleLength + 5, 0, handleWidth / 2 - 4, handleWidth / 2 - 6, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Screw/pivot
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(0, 0, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw realistic handheld fan
        function drawFan(x, y, spinAngle, isBlowing) {
            ctx.save();
            ctx.translate(x, y);

            // Fan cage/guard
            const cageRadius = 50;
            const bladeCount = 5;

            // Outer ring
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, cageRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner ring
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, cageRadius * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            // Cage wires
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * cageRadius * 0.7, Math.sin(angle) * cageRadius * 0.7);
                ctx.lineTo(Math.cos(angle) * cageRadius, Math.sin(angle) * cageRadius);
                ctx.stroke();
            }

            // Fan blades (spinning)
            for (let i = 0; i < bladeCount; i++) {
                const bladeAngle = spinAngle + (i / bladeCount) * Math.PI * 2;

                ctx.save();
                ctx.rotate(bladeAngle);

                // Blade gradient
                const gradient = ctx.createLinearGradient(0, 0, cageRadius * 0.6, 0);
                gradient.addColorStop(0, '#888');
                gradient.addColorStop(0.5, '#aaa');
                gradient.addColorStop(1, '#666');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.quadraticCurveTo(cageRadius * 0.3, -12, cageRadius * 0.55, -8);
                ctx.lineTo(cageRadius * 0.55, 8);
                ctx.quadraticCurveTo(cageRadius * 0.3, 12, 8, 0);
                ctx.fill();

                // Blade highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(12, -2);
                ctx.quadraticCurveTo(cageRadius * 0.3, -8, cageRadius * 0.5, -5);
                ctx.stroke();

                ctx.restore();
            }

            // Center hub
            ctx.fillStyle = '#444';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();

            // Center cap
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            // Handle
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.roundRect(-8, cageRadius - 5, 16, 45, 4);
            ctx.fill();

            // Handle grip lines
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const gy = cageRadius + 8 + i * 7;
                ctx.beginPath();
                ctx.moveTo(-5, gy);
                ctx.lineTo(5, gy);
                ctx.stroke();
            }

            // Wind effect when blowing
            if (isBlowing) {
                ctx.strokeStyle = 'rgba(150, 200, 255, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const windAngle = (i / 8) * Math.PI * 2;
                    const startR = cageRadius + 5;
                    const endR = cageRadius + 25 + Math.sin(Date.now() / 100 + i * 2) * 15;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(windAngle) * startR, Math.sin(windAngle) * startR);
                    ctx.lineTo(Math.cos(windAngle) * endR, Math.sin(windAngle) * endR);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // Animation loop
        function animate() {
            ctx.fillStyle = '#f5e6d3';
            ctx.fillRect(0, 0, width, height);

            // Calculate wind from fan or natural
            let wind = { x: 0, y: 0 };

            if (mode === 'fan' && isMouseDown) {
                // Fan blows away from mouse
                const fanRadius = 250;
                fanAngle += 0.4; // Spin the fan

                // Calculate blow direction (away from fan center)
                hairs.forEach(hair => {
                    const dx = hair.rootX - smoothToolX;
                    const dy = hair.rootY - smoothToolY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < fanRadius && dist > 0) {
                        const strength = (1 - dist / fanRadius) * 12;
                        hair.applyFan(dx / dist * strength, dy / dist * strength, smoothToolX, smoothToolY, fanRadius);
                    }
                });

                // Apply to eyelashes too
                eyelashes.forEach(lash => {
                    const dx = lash.rootX - smoothToolX;
                    const dy = lash.rootY - smoothToolY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < fanRadius && dist > 0) {
                        const strength = (1 - dist / fanRadius) * 8;
                        lash.applyForce(dx / dist * strength, dy / dist * strength, smoothToolX, smoothToolY, fanRadius);
                    }
                });

                // Set wind for global effect
                wind.x = 2;
                wind.y = 0.5;
            } else if (mode === 'fan') {
                // Slow down fan when not blowing
                fanAngle += 0.05;
            }

            // Comb effect
            if (mode === 'comb' && isMouseDown) {
                const combRadius = 40;
                const combForceX = (mouseX - lastMouseX) * 0.8;
                const combForceY = (mouseY - lastMouseY) * 0.8;

                hairs.forEach(hair => {
                    hair.applyComb(combForceX, combForceY, smoothToolX, smoothToolY, combRadius);
                });
            }

            // Cut effect
            if (mode === 'cut' && isMouseDown) {
                const cutRadius = 18;

                // Interpolate between last and current mouse position for smooth cutting
                const dx = mouseX - lastMouseX;
                const dy = mouseY - lastMouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const steps = Math.max(1, Math.ceil(dist / 5)); // Check every 5 pixels

                for (let s = 0; s <= steps; s++) {
                    const t = s / steps;
                    const x = lastMouseX + dx * t;
                    const y = lastMouseY + dy * t;
                    hairs.forEach(hair => {
                        hair.trycut(x, y, cutRadius);
                    });
                }
            }

            // Update and draw hair (behind head first)
            const gravity = 0.4;
            hairs.forEach(hair => {
                hair.update(gravity, wind);
            });

            // Draw head
            drawHead();

            // Update and draw eyelashes
            eyelashes.forEach(lash => {
                lash.update(wind);
                lash.draw(ctx);
            });

            // Draw all hair in front of head
            hairs.forEach(hair => hair.draw(ctx, hairColor));

            // Smooth tool position (lerp towards mouse)
            const smoothing = 0.25;
            smoothToolX += (mouseX - smoothToolX) * smoothing;
            smoothToolY += (mouseY - smoothToolY) * smoothing;

            // Update tool angle based on mouse movement (smooth)
            const moveDx = mouseX - lastMouseX;
            const moveDy = mouseY - lastMouseY;
            if (Math.abs(moveDx) > 0.5 || Math.abs(moveDy) > 0.5) {
                targetToolAngle = Math.atan2(moveDy, moveDx);
            }
            // Smooth angle interpolation (handle wrapping)
            let angleDiff = targetToolAngle - toolAngle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            toolAngle += angleDiff * 0.15;

            // Draw tools on top
            if (mode === 'comb') {
                drawComb(smoothToolX, smoothToolY, toolAngle);
            } else if (mode === 'cut') {
                // Animate scissors open/close
                if (isMouseDown) {
                    scissorAngle = Math.min(scissorAngle + 0.15, 0.4);
                } else {
                    scissorAngle = Math.max(scissorAngle - 0.1, 0.1);
                }
                drawScissors(smoothToolX, smoothToolY, toolAngle, scissorAngle);
            } else if (mode === 'fan') {
                drawFan(smoothToolX, smoothToolY, fanAngle, isMouseDown);
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
