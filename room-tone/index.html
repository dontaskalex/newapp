<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-D19M0488B7"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-D19M0488B7');</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room Tone | Procedural Ambient Sound Generator | hafnr</title>
    <meta name="description" content="Layer procedurally generated ambient sounds to create your perfect atmosphere. No recordings - every sound is synthesized in real-time using algorithms. Zero downloads, infinite variety.">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%230f0f0f'/><text x='4' y='26' font-family='Arial' font-size='26' font-weight='bold' fill='%23fff'>h</text><circle cx='26' cy='24' r='3' fill='%23fff'/></svg>">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7723236991764317" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #08080a;
            --bg-surface: #0e0e11;
            --bg-elevated: #141418;
            --bg-card: #18181d;
            --bg-card-hover: #1d1d23;
            --border: #222228;
            --border-active: #3a3a42;
            --text-primary: #e8e6e3;
            --text-secondary: #9a9a9a;
            --text-muted: #5a5a5a;
            --text-dim: #3a3a3a;
            --amber: #e09f3e;
            --amber-soft: #f5d89a;
            --amber-dim: #c08a35;
            --amber-glow: rgba(224, 159, 62, 0.12);
            --amber-glow-strong: rgba(224, 159, 62, 0.25);
            --warm-white: #faf6f0;
            --ember: #d4724a;
            --ember-glow: rgba(212, 114, 74, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            background: var(--bg-deep);
            min-height: 100%;
            font-family: 'DM Mono', monospace;
            color: var(--text-primary);
            overflow-x: hidden;
            position: relative;
        }

        /* Ambient background glow - shifts based on active sounds */
        .ambient-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        .ambient-glow.active {
            opacity: 1;
        }

        .ambient-glow::before {
            content: '';
            position: absolute;
            top: -20%;
            left: -20%;
            width: 60%;
            height: 60%;
            background: radial-gradient(ellipse at center, var(--amber-glow) 0%, transparent 70%);
            animation: drift1 25s ease-in-out infinite;
        }

        .ambient-glow::after {
            content: '';
            position: absolute;
            bottom: -20%;
            right: -20%;
            width: 70%;
            height: 70%;
            background: radial-gradient(ellipse at center, var(--ember-glow) 0%, transparent 70%);
            animation: drift2 30s ease-in-out infinite;
        }

        @keyframes drift1 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            33% { transform: translate(10%, 5%) scale(1.1); }
            66% { transform: translate(-5%, 10%) scale(0.95); }
        }

        @keyframes drift2 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-10%, -5%) scale(1.15); }
        }

        /* Grain texture overlay */
        .grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.025;
            pointer-events: none;
            z-index: 1000;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Main layout */
        .app {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            background: rgba(8, 8, 10, 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: baseline;
            gap: 12px;
            text-decoration: none;
        }

        .logo h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 26px;
            font-weight: 300;
            color: var(--text-primary);
            letter-spacing: 0.02em;
        }

        .logo .tagline {
            font-size: 10px;
            color: var(--text-muted);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        .back-link {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 11px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            transition: color 0.3s;
            padding: 8px 12px;
            border-radius: 6px;
        }

        .back-link:hover {
            color: var(--text-secondary);
            background: var(--bg-elevated);
        }

        /* Main content area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 24px;
            gap: 24px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        /* Category tabs */
        .category-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg-surface);
            padding: 4px;
            border-radius: 10px;
            border: 1px solid var(--border);
            width: fit-content;
        }

        .category-tab {
            padding: 10px 18px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 7px;
            transition: all 0.25s ease;
            position: relative;
        }

        .category-tab:hover {
            color: var(--text-secondary);
        }

        .category-tab.active {
            background: var(--bg-elevated);
            color: var(--amber);
        }

        .category-tab .count {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            background: var(--amber);
            border-radius: 50%;
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s ease;
        }

        .category-tab .count.visible {
            opacity: 1;
            transform: scale(1);
        }

        /* Sound grid */
        .sound-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        .sound-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 18px 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
        }

        .sound-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, var(--amber-glow) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }

        .sound-card:hover {
            background: var(--bg-card-hover);
            border-color: var(--border-active);
            transform: translateY(-2px);
        }

        .sound-card.active {
            border-color: var(--amber-dim);
            box-shadow: 0 0 30px var(--amber-glow), inset 0 0 30px var(--amber-glow);
        }

        .sound-card.active::before {
            opacity: 1;
        }

        .sound-icon {
            width: 48px;
            height: 48px;
            background: var(--bg-elevated);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .sound-card.active .sound-icon {
            background: var(--amber-glow-strong);
            box-shadow: 0 0 20px var(--amber-glow);
        }

        /* Pulsing animation for active sounds */
        .sound-card.active .sound-icon::after {
            content: '';
            position: absolute;
            inset: -4px;
            border-radius: 16px;
            border: 1px solid var(--amber);
            opacity: 0;
            animation: pulse-ring 2s ease-out infinite;
        }

        @keyframes pulse-ring {
            0% { transform: scale(0.95); opacity: 0.5; }
            50% { transform: scale(1.05); opacity: 0; }
            100% { transform: scale(0.95); opacity: 0; }
        }

        .sound-name {
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            letter-spacing: 0.03em;
            transition: color 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .sound-card.active .sound-name {
            color: var(--amber-soft);
        }

        /* Active mixer panel */
        .mixer-panel {
            background: var(--bg-surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .mixer-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mixer-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 18px;
            font-weight: 400;
            color: var(--text-primary);
            letter-spacing: 0.02em;
        }

        .mixer-subtitle {
            font-size: 10px;
            color: var(--text-muted);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .mixer-content {
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 280px;
            overflow-y: auto;
        }

        .mixer-content::-webkit-scrollbar {
            width: 6px;
        }

        .mixer-content::-webkit-scrollbar-track {
            background: var(--bg-elevated);
            border-radius: 3px;
        }

        .mixer-content::-webkit-scrollbar-thumb {
            background: var(--border-active);
            border-radius: 3px;
        }

        .mixer-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
        }

        .mixer-empty-icon {
            font-size: 32px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .mixer-empty-sub {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 8px;
            letter-spacing: 0.05em;
        }

        /* Mixer channel strip */
        .channel-strip {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 10px 12px;
            background: var(--bg-elevated);
            border-radius: 10px;
            transition: all 0.25s ease;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .channel-strip:hover {
            background: var(--bg-card);
        }

        .channel-icon {
            width: 36px;
            height: 36px;
            background: var(--amber-glow);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .channel-info {
            flex: 1;
            min-width: 0;
        }

        .channel-name {
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Volume slider */
        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--amber);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--amber-glow-strong);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 0 16px var(--amber-glow-strong);
        }

        .volume-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--amber);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px var(--amber-glow-strong);
        }

        .channel-volume {
            font-size: 10px;
            color: var(--text-muted);
            width: 32px;
            text-align: right;
            flex-shrink: 0;
        }

        .channel-remove {
            width: 28px;
            height: 28px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .channel-remove:hover {
            background: rgba(220, 80, 80, 0.15);
            border-color: rgba(220, 80, 80, 0.3);
            color: #dc5050;
        }

        .channel-remove svg {
            width: 14px;
            height: 14px;
        }

        /* Master controls */
        .master-controls {
            background: var(--bg-surface);
            border-top: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 20px;
            position: sticky;
            bottom: 0;
            z-index: 50;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .play-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--amber);
            border: none;
            color: var(--bg-deep);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s ease;
            flex-shrink: 0;
        }

        .play-btn:hover {
            background: var(--amber-soft);
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--amber-glow-strong);
        }

        .play-btn:active {
            transform: scale(0.98);
        }

        .play-btn.playing {
            background: var(--bg-elevated);
            border: 2px solid var(--amber);
            color: var(--amber);
        }

        .play-btn svg {
            width: 22px;
            height: 22px;
        }

        .master-volume-container {
            flex: 1;
            max-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .master-label {
            font-size: 9px;
            color: var(--text-muted);
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }

        .master-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .master-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--warm-white);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: transform 0.15s ease;
        }

        .master-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .master-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--warm-white);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* Timer dropdown */
        .timer-container {
            position: relative;
        }

        .timer-btn {
            padding: 10px 16px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .timer-btn:hover {
            border-color: var(--border-active);
            color: var(--text-primary);
        }

        .timer-btn.active {
            border-color: var(--amber-dim);
            color: var(--amber);
        }

        .timer-btn svg {
            width: 14px;
            height: 14px;
        }

        .timer-dropdown {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            min-width: 240px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.25s ease;
            z-index: 100;
        }

        .timer-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .timer-picker {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .timer-picker-label {
            font-size: 10px;
            color: var(--text-muted);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .timer-inputs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timer-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .timer-input {
            width: 54px;
            padding: 10px 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Cormorant Garamond', serif;
            font-size: 22px;
            text-align: center;
            outline: none;
            transition: all 0.2s ease;
            -moz-appearance: textfield;
        }

        .timer-input::-webkit-outer-spin-button,
        .timer-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .timer-input:focus {
            border-color: var(--amber-dim);
            box-shadow: 0 0 0 2px var(--amber-glow);
        }

        .timer-input-label {
            font-size: 9px;
            color: var(--text-dim);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .timer-separator {
            font-family: 'Cormorant Garamond', serif;
            font-size: 22px;
            color: var(--text-muted);
            margin-top: -18px;
        }

        .timer-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .timer-preset {
            padding: 6px 10px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .timer-preset:hover {
            border-color: var(--border-active);
            color: var(--text-secondary);
        }

        .timer-actions {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }

        .timer-start-btn {
            flex: 1;
            padding: 10px 16px;
            background: var(--amber);
            border: none;
            border-radius: 8px;
            color: var(--bg-deep);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timer-start-btn:hover {
            background: var(--amber-soft);
        }

        .timer-start-btn:disabled {
            background: var(--border);
            color: var(--text-dim);
            cursor: not-allowed;
        }

        .timer-clear-btn {
            padding: 10px 14px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timer-clear-btn:hover {
            border-color: rgba(220, 80, 80, 0.3);
            color: #dc5050;
        }

        /* Presets */
        .presets-container {
            position: relative;
        }

        .presets-btn {
            padding: 10px 16px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .presets-btn:hover {
            border-color: var(--border-active);
            color: var(--text-primary);
        }

        .presets-btn svg {
            width: 14px;
            height: 14px;
        }

        .presets-dropdown {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 6px;
            min-width: 200px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.25s ease;
            z-index: 100;
        }

        .presets-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .preset-option {
            padding: 12px 14px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            border-radius: 6px;
            transition: all 0.15s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .preset-option:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .preset-name {
            font-size: 12px;
        }

        .preset-sounds {
            font-size: 9px;
            color: var(--text-muted);
            letter-spacing: 0.05em;
        }

        /* Keyboard hints */
        .keyboard-hints {
            margin-left: auto;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .hint {
            font-size: 10px;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .hint kbd {
            padding: 3px 6px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: inherit;
            font-size: 9px;
        }

        /* Timer display overlay */
        .timer-display {
            position: fixed;
            top: 80px;
            right: 24px;
            background: var(--bg-card);
            border: 1px solid var(--amber-dim);
            border-radius: 10px;
            padding: 12px 18px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 90;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .timer-display.visible {
            display: flex;
        }

        .timer-display-icon {
            color: var(--amber);
        }

        .timer-display-icon svg {
            width: 16px;
            height: 16px;
        }

        .timer-display-time {
            font-family: 'Cormorant Garamond', serif;
            font-size: 22px;
            color: var(--amber-soft);
        }

        .timer-display-cancel {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            margin-left: 4px;
        }

        .timer-display-cancel:hover {
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            header {
                padding: 16px 20px;
            }

            .logo h1 {
                font-size: 22px;
            }

            .logo .tagline {
                display: none;
            }

            .main-content {
                padding: 20px 16px;
                gap: 20px;
            }

            .category-tabs {
                width: 100%;
                justify-content: center;
            }

            .category-tab {
                padding: 10px 14px;
                font-size: 10px;
            }

            .sound-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
            }

            .sound-card {
                padding: 14px 10px;
            }

            .sound-icon {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }

            .sound-name {
                font-size: 10px;
            }

            .master-controls {
                padding: 14px 16px;
                gap: 14px;
                flex-wrap: wrap;
            }

            .play-btn {
                width: 50px;
                height: 50px;
            }

            .master-volume-container {
                max-width: 140px;
            }

            .keyboard-hints {
                display: none;
            }

            .timer-display {
                top: 70px;
                right: 16px;
                padding: 10px 14px;
            }

            .timer-display-time {
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            .category-tabs {
                overflow-x: auto;
                justify-content: flex-start;
                -webkit-overflow-scrolling: touch;
            }

            .category-tab {
                white-space: nowrap;
            }

            .sound-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .mixer-content {
                max-height: 200px;
            }

            .channel-strip {
                padding: 8px 10px;
                gap: 10px;
            }

            .channel-icon {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }

            .timer-btn span,
            .presets-btn span {
                display: none;
            }
        }

        /* Fireplace flicker animation for cozy mood */
        @keyframes fireflicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }

        .cozy-mode .ambient-glow::before,
        .cozy-mode .ambient-glow::after {
            animation: fireflicker 3s ease-in-out infinite, drift1 25s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="ambient-glow"></div>
    <div class="grain"></div>

    <div class="app">
        <header>
            <a href="/" class="logo">
                <h1>Room Tone</h1>
                <span class="tagline">procedurally generated ambience</span>
            </a>
            <a href="/" class="back-link">‚Üê Back to Hub</a>
        </header>

        <main class="main-content">
            <nav class="category-tabs" role="tablist">
                <button class="category-tab active" data-category="nature" role="tab">
                    Nature
                    <span class="count"></span>
                </button>
                <button class="category-tab" data-category="indoor" role="tab">
                    Indoor
                    <span class="count"></span>
                </button>
                <button class="category-tab" data-category="urban" role="tab">
                    Urban
                    <span class="count"></span>
                </button>
                <button class="category-tab" data-category="mechanical" role="tab">
                    Mechanical
                    <span class="count"></span>
                </button>
                <button class="category-tab" data-category="scifi" role="tab">
                    Sci-Fi
                    <span class="count"></span>
                </button>
                <button class="category-tab" data-category="abstract" role="tab">
                    Abstract
                    <span class="count"></span>
                </button>
            </nav>

            <section class="sound-grid" id="soundGrid" role="tabpanel">
                <!-- Sounds populated by JS -->
            </section>

            <section class="mixer-panel">
                <div class="mixer-header">
                    <div>
                        <h2 class="mixer-title">Active Mix</h2>
                        <p class="mixer-subtitle" id="mixerSubtitle">No sounds playing</p>
                    </div>
                </div>
                <div class="mixer-content" id="mixerContent">
                    <div class="mixer-empty">
                        <div class="mixer-empty-icon">„Ä∞Ô∏è</div>
                        <p>Select sounds to generate your atmosphere</p>
                        <p class="mixer-empty-sub">Every sound is synthesized in real-time ‚Äî no recordings</p>
                    </div>
                </div>
            </section>
        </main>

        <footer class="master-controls">
            <button class="play-btn" id="playBtn" title="Play/Pause (Space)">
                <svg viewBox="0 0 24 24" fill="currentColor" class="play-icon">
                    <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>
                <svg viewBox="0 0 24 24" fill="currentColor" class="pause-icon" style="display: none;">
                    <rect x="6" y="4" width="4" height="16"/>
                    <rect x="14" y="4" width="4" height="16"/>
                </svg>
            </button>

            <div class="master-volume-container">
                <label class="master-label">Master Volume</label>
                <input type="range" class="master-slider" id="masterVolume" min="0" max="100" value="75">
            </div>

            <div class="timer-container">
                <button class="timer-btn" id="timerBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12 6 12 12 16 14"/>
                    </svg>
                    <span>Timer</span>
                </button>
                <div class="timer-dropdown" id="timerDropdown">
                    <div class="timer-picker">
                        <span class="timer-picker-label">Set Duration</span>
                        <div class="timer-inputs">
                            <div class="timer-input-group">
                                <input type="number" class="timer-input" id="timerHours" min="0" max="23" value="0" placeholder="0">
                                <span class="timer-input-label">hours</span>
                            </div>
                            <span class="timer-separator">:</span>
                            <div class="timer-input-group">
                                <input type="number" class="timer-input" id="timerMinutes" min="0" max="59" value="30" placeholder="30">
                                <span class="timer-input-label">min</span>
                            </div>
                            <span class="timer-separator">:</span>
                            <div class="timer-input-group">
                                <input type="number" class="timer-input" id="timerSeconds" min="0" max="59" value="0" placeholder="0">
                                <span class="timer-input-label">sec</span>
                            </div>
                        </div>
                        <div class="timer-presets">
                            <button class="timer-preset" data-time="15:0">15m</button>
                            <button class="timer-preset" data-time="30:0">30m</button>
                            <button class="timer-preset" data-time="45:0">45m</button>
                            <button class="timer-preset" data-time="60:0">1h</button>
                            <button class="timer-preset" data-time="90:0">1.5h</button>
                            <button class="timer-preset" data-time="120:0">2h</button>
                        </div>
                        <div class="timer-actions">
                            <button class="timer-start-btn" id="timerStartBtn">Start Timer</button>
                            <button class="timer-clear-btn" id="timerClearBtn">Clear</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="presets-container">
                <button class="presets-btn" id="presetsBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                    </svg>
                    <span>Presets</span>
                </button>
                <div class="presets-dropdown" id="presetsDropdown">
                    <button class="preset-option" data-preset="rainy-cafe">
                        <span class="preset-name">‚òï Rainy Caf√©</span>
                        <span class="preset-sounds">Rain + Coffee Shop</span>
                    </button>
                    <button class="preset-option" data-preset="cozy-cabin">
                        <span class="preset-name">üè† Cozy Cabin</span>
                        <span class="preset-sounds">Fire + Rain + Wind</span>
                    </button>
                    <button class="preset-option" data-preset="deep-focus">
                        <span class="preset-name">üß† Deep Focus</span>
                        <span class="preset-sounds">Brown Noise + Fan</span>
                    </button>
                    <button class="preset-option" data-preset="forest-morning">
                        <span class="preset-name">üå≤ Forest Morning</span>
                        <span class="preset-sounds">Birds + Stream + Wind</span>
                    </button>
                    <button class="preset-option" data-preset="ocean-night">
                        <span class="preset-name">üåä Ocean Night</span>
                        <span class="preset-sounds">Waves + Crickets</span>
                    </button>
                </div>
            </div>

            <div class="keyboard-hints">
                <span class="hint"><kbd>Space</kbd> Play</span>
                <span class="hint"><kbd>M</kbd> Mute</span>
            </div>
        </footer>
    </div>

    <!-- Timer display -->
    <div class="timer-display" id="timerDisplay">
        <span class="timer-display-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <polyline points="12 6 12 12 16 14"/>
            </svg>
        </span>
        <span class="timer-display-time" id="timerDisplayTime">00:00</span>
        <button class="timer-display-cancel" id="timerCancel" title="Cancel timer">
            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
        </button>
    </div>

    <script>
        // Sound definitions - ALL procedurally generated
        const SOUNDS = {
            nature: [
                { id: 'rain-light', name: 'Light Rain', icon: 'üåßÔ∏è' },
                { id: 'rain-heavy', name: 'Heavy Rain', icon: '‚õàÔ∏è' },
                { id: 'rain-roof', name: 'Rain on Roof', icon: 'üè†' },
                { id: 'thunder', name: 'Thunder', icon: '‚ö°' },
                { id: 'wind-trees', name: 'Wind in Trees', icon: 'üçÉ' },
                { id: 'wind-howling', name: 'Howling Wind', icon: 'üí®' },
                { id: 'wind-grass', name: 'Prairie Wind', icon: 'üåæ' },
                { id: 'stream', name: 'Forest Stream', icon: 'üèûÔ∏è' },
                { id: 'waterfall', name: 'Waterfall', icon: 'üíß' },
                { id: 'river', name: 'River Flow', icon: 'üåä' },
                { id: 'ocean-waves', name: 'Ocean Waves', icon: 'üåä' },
                { id: 'lake', name: 'Gentle Lake', icon: 'üèûÔ∏è' },
                { id: 'birds', name: 'Forest Birds', icon: 'üê¶' },
                { id: 'seagulls', name: 'Seagulls', icon: 'üïäÔ∏è' },
                { id: 'owls', name: 'Night Owls', icon: 'ü¶â' },
                { id: 'crickets', name: 'Night Crickets', icon: 'ü¶ó' },
                { id: 'frogs', name: 'Frogs', icon: 'üê∏' },
                { id: 'cicadas', name: 'Cicadas', icon: 'ü™≤' },
                { id: 'campfire', name: 'Campfire', icon: 'üèïÔ∏è' },
            ],
            indoor: [
                { id: 'fireplace', name: 'Fireplace', icon: 'üî•' },
                { id: 'clock', name: 'Ticking Clock', icon: 'üï∞Ô∏è' },
                { id: 'fan', name: 'Fan Hum', icon: 'üåÄ' },
                { id: 'ac', name: 'Air Conditioner', icon: '‚ùÑÔ∏è' },
                { id: 'heater', name: 'Space Heater', icon: 'üî•' },
                { id: 'fridge', name: 'Refrigerator', icon: 'üßä' },
                { id: 'washer', name: 'Washing Machine', icon: 'ü´ß' },
                { id: 'dryer', name: 'Dryer Tumble', icon: 'üëï' },
                { id: 'dishwasher', name: 'Dishwasher', icon: 'üçΩÔ∏è' },
                { id: 'typing', name: 'Keyboard Typing', icon: '‚å®Ô∏è' },
                { id: 'mouse-clicks', name: 'Mouse Clicks', icon: 'üñ±Ô∏è' },
                { id: 'pages', name: 'Page Turning', icon: 'üìñ' },
                { id: 'vinyl', name: 'Vinyl Crackle', icon: 'üìÄ' },
                { id: 'pencil', name: 'Pencil Writing', icon: '‚úèÔ∏è' },
                { id: 'shower', name: 'Shower', icon: 'üöø' },
                { id: 'bathtub', name: 'Bathtub Fill', icon: 'üõÅ' },
                { id: 'boiling', name: 'Boiling Water', icon: '‚ô®Ô∏è' },
                { id: 'cats-purr', name: 'Cat Purring', icon: 'üê±' },
                { id: 'humming', name: 'Soft Humming', icon: 'üé∂' },
                { id: 'baby-breathing', name: 'Baby Sleeping', icon: 'üë∂' },
            ],
            urban: [
                { id: 'cafe', name: 'Coffee Shop', icon: '‚òï' },
                { id: 'library', name: 'Library', icon: 'üìö' },
                { id: 'office', name: 'Office Ambience', icon: 'üè¢' },
                { id: 'traffic', name: 'City Traffic', icon: 'üöó' },
                { id: 'highway', name: 'Highway', icon: 'üõ£Ô∏è' },
                { id: 'subway', name: 'Subway Train', icon: 'üöá' },
                { id: 'train', name: 'Train Journey', icon: 'üöÇ' },
                { id: 'airport', name: 'Airport Terminal', icon: '‚úàÔ∏è' },
                { id: 'airplane', name: 'Airplane Cabin', icon: 'üõ´' },
                { id: 'restaurant', name: 'Restaurant', icon: 'üçΩÔ∏è' },
                { id: 'bar', name: 'Bar Ambience', icon: 'üç∫' },
                { id: 'mall', name: 'Shopping Mall', icon: 'üõçÔ∏è' },
                { id: 'playground', name: 'Playground', icon: 'üé†' },
                { id: 'construction', name: 'Construction', icon: 'üèóÔ∏è' },
                { id: 'city-night', name: 'City Night', icon: 'üåÉ' },
                { id: 'crowd-murmur', name: 'Crowd Murmur', icon: 'üë•' },
                { id: 'distant-party', name: 'Distant Party', icon: 'üéâ' },
                { id: 'street-busker', name: 'Street Busker', icon: 'üé∏' },
            ],
            mechanical: [
                { id: 'engine-idle', name: 'Engine Idle', icon: 'üöó' },
                { id: 'ship-engine', name: 'Ship Engine', icon: 'üö¢' },
                { id: 'generator', name: 'Generator', icon: '‚ö°' },
                { id: 'machinery', name: 'Factory Machines', icon: 'üè≠' },
                { id: 'server-room', name: 'Server Room', icon: 'üñ•Ô∏è' },
                { id: 'hard-drive', name: 'Hard Drive', icon: 'üíæ' },
                { id: 'printer', name: 'Printer', icon: 'üñ®Ô∏è' },
                { id: 'ventilation', name: 'Ventilation', icon: 'üå¨Ô∏è' },
                { id: 'electric-hum', name: 'Electric Hum', icon: 'üí°' },
                { id: 'transformer', name: 'Transformer Box', icon: 'üîå' },
            ],
            scifi: [
                { id: 'spaceship', name: 'Spaceship', icon: 'üöÄ' },
                { id: 'warp-drive', name: 'Warp Drive', icon: 'üåå' },
                { id: 'alien-planet', name: 'Alien Planet', icon: 'üëΩ' },
                { id: 'space-station', name: 'Space Station', icon: 'üõ∏' },
                { id: 'underwater-base', name: 'Underwater Base', icon: 'üåä' },
                { id: 'radioactive', name: 'Radioactive', icon: '‚ò¢Ô∏è' },
                { id: 'energy-field', name: 'Energy Field', icon: '‚ö°' },
                { id: 'quantum-hum', name: 'Quantum Hum', icon: 'üîÆ' },
            ],
            abstract: [
                { id: 'brown-noise', name: 'Brown Noise', icon: 'üü§' },
                { id: 'pink-noise', name: 'Pink Noise', icon: 'ü©∑' },
                { id: 'white-noise', name: 'White Noise', icon: '‚ö™' },
                { id: 'blue-noise', name: 'Blue Noise', icon: 'üîµ' },
                { id: 'grey-noise', name: 'Grey Noise', icon: '‚ö´' },
                { id: 'binaural-alpha', name: 'Alpha Waves', icon: 'üß†' },
                { id: 'binaural-theta', name: 'Theta Waves', icon: 'üò¥' },
                { id: 'binaural-focus', name: 'Focus Tones', icon: 'üéØ' },
                { id: 'drone', name: 'Ambient Drone', icon: 'üéµ' },
                { id: 'drone-dark', name: 'Dark Drone', icon: 'üåë' },
                { id: 'drone-light', name: 'Light Drone', icon: '‚òÄÔ∏è' },
                { id: 'sine-60hz', name: '60Hz Sine', icon: '„Ä∞Ô∏è' },
                { id: 'sine-432hz', name: '432Hz Tone', icon: 'üîî' },
                { id: 'harmonic-series', name: 'Harmonic Series', icon: 'üéº' },
                { id: 'shepard-tone', name: 'Shepard Tone', icon: '‚ôæÔ∏è' },
            ]
        };

        // Presets
        const PRESETS = {
            'rainy-cafe': [
                { id: 'rain-light', volume: 0.5 },
                { id: 'cafe', volume: 0.4 }
            ],
            'cozy-cabin': [
                { id: 'fireplace', volume: 0.6 },
                { id: 'rain-light', volume: 0.3 },
                { id: 'wind-trees', volume: 0.25 }
            ],
            'deep-focus': [
                { id: 'brown-noise', volume: 0.5 },
                { id: 'fan', volume: 0.3 }
            ],
            'forest-morning': [
                { id: 'birds', volume: 0.5 },
                { id: 'stream', volume: 0.4 },
                { id: 'wind-trees', volume: 0.2 }
            ],
            'ocean-night': [
                { id: 'ocean-waves', volume: 0.6 },
                { id: 'crickets', volume: 0.35 }
            ]
        };

        // State
        let activeSounds = new Map(); // id -> { volume, gainNode, sourceNode, buffer }
        let audioContext = null;
        let masterGainNode = null;
        let isPlaying = false;
        let currentCategory = 'nature';
        let timerInterval = null;
        let timerEndTime = null;

        // DOM elements
        const soundGrid = document.getElementById('soundGrid');
        const mixerContent = document.getElementById('mixerContent');
        const mixerSubtitle = document.getElementById('mixerSubtitle');
        const playBtn = document.getElementById('playBtn');
        const playIcon = playBtn.querySelector('.play-icon');
        const pauseIcon = playBtn.querySelector('.pause-icon');
        const masterVolume = document.getElementById('masterVolume');
        const timerBtn = document.getElementById('timerBtn');
        const timerDropdown = document.getElementById('timerDropdown');
        const timerDisplay = document.getElementById('timerDisplay');
        const timerDisplayTime = document.getElementById('timerDisplayTime');
        const timerCancel = document.getElementById('timerCancel');
        const presetsBtn = document.getElementById('presetsBtn');
        const presetsDropdown = document.getElementById('presetsDropdown');
        const ambientGlow = document.querySelector('.ambient-glow');
        const categoryTabs = document.querySelectorAll('.category-tab');

        // Initialize audio context on first interaction
        function initAudio() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGainNode = audioContext.createGain();
            masterGainNode.connect(audioContext.destination);
            masterGainNode.gain.value = masterVolume.value / 100;
        }

        // Generate procedural ambient sounds
        function generateSound(id) {
            initAudio();

            const sampleRate = audioContext.sampleRate;
            const duration = 10; // 10 second loops
            const numSamples = sampleRate * duration;
            const buffer = audioContext.createBuffer(2, numSamples, sampleRate);

            const leftChannel = buffer.getChannelData(0);
            const rightChannel = buffer.getChannelData(1);

            // Different generation based on sound type
            switch(id) {
                case 'rain-light':
                    generateRain(leftChannel, rightChannel, numSamples, 0.15, 0.02);
                    break;
                case 'rain-heavy':
                    generateRain(leftChannel, rightChannel, numSamples, 0.4, 0.08);
                    break;
                case 'thunder':
                    generateThunder(leftChannel, rightChannel, numSamples);
                    break;
                case 'wind-trees':
                    generateWind(leftChannel, rightChannel, numSamples, 0.3, 2);
                    break;
                case 'wind-howling':
                    generateWind(leftChannel, rightChannel, numSamples, 0.5, 0.5);
                    break;
                case 'stream':
                    generateStream(leftChannel, rightChannel, numSamples);
                    break;
                case 'ocean-waves':
                    generateOcean(leftChannel, rightChannel, numSamples);
                    break;
                case 'birds':
                    generateBirds(leftChannel, rightChannel, numSamples);
                    break;
                case 'crickets':
                    generateCrickets(leftChannel, rightChannel, numSamples);
                    break;
                case 'fireplace':
                    generateFireplace(leftChannel, rightChannel, numSamples);
                    break;
                case 'clock':
                    generateClock(leftChannel, rightChannel, numSamples);
                    break;
                case 'fan':
                    generateFan(leftChannel, rightChannel, numSamples);
                    break;
                case 'typing':
                    generateTyping(leftChannel, rightChannel, numSamples);
                    break;
                case 'pages':
                    generatePages(leftChannel, rightChannel, numSamples);
                    break;
                case 'vinyl':
                    generateVinyl(leftChannel, rightChannel, numSamples);
                    break;
                case 'cafe':
                    generateCafe(leftChannel, rightChannel, numSamples);
                    break;
                case 'traffic':
                    generateTraffic(leftChannel, rightChannel, numSamples);
                    break;
                case 'subway':
                    generateSubway(leftChannel, rightChannel, numSamples);
                    break;
                case 'restaurant':
                    generateRestaurant(leftChannel, rightChannel, numSamples);
                    break;
                case 'brown-noise':
                    generateBrownNoise(leftChannel, rightChannel, numSamples);
                    break;
                case 'pink-noise':
                    generatePinkNoise(leftChannel, rightChannel, numSamples);
                    break;
                case 'white-noise':
                    generateWhiteNoise(leftChannel, rightChannel, numSamples);
                    break;
                case 'binaural':
                    generateBinaural(leftChannel, rightChannel, numSamples);
                    break;
                case 'drone':
                    generateDrone(leftChannel, rightChannel, numSamples);
                    break;
                // New Nature sounds
                case 'rain-roof':
                    generateRainOnRoof(leftChannel, rightChannel, numSamples);
                    break;
                case 'wind-grass':
                    generateWindGrass(leftChannel, rightChannel, numSamples);
                    break;
                case 'waterfall':
                    generateWaterfall(leftChannel, rightChannel, numSamples);
                    break;
                case 'river':
                    generateRiver(leftChannel, rightChannel, numSamples);
                    break;
                case 'lake':
                    generateLake(leftChannel, rightChannel, numSamples);
                    break;
                case 'seagulls':
                    generateSeagulls(leftChannel, rightChannel, numSamples);
                    break;
                case 'owls':
                    generateOwls(leftChannel, rightChannel, numSamples);
                    break;
                case 'frogs':
                    generateFrogs(leftChannel, rightChannel, numSamples);
                    break;
                case 'cicadas':
                    generateCicadas(leftChannel, rightChannel, numSamples);
                    break;
                case 'campfire':
                    generateCampfire(leftChannel, rightChannel, numSamples);
                    break;
                // New Indoor sounds
                case 'ac':
                    generateAC(leftChannel, rightChannel, numSamples);
                    break;
                case 'heater':
                    generateHeater(leftChannel, rightChannel, numSamples);
                    break;
                case 'fridge':
                    generateFridge(leftChannel, rightChannel, numSamples);
                    break;
                case 'washer':
                    generateWasher(leftChannel, rightChannel, numSamples);
                    break;
                case 'dryer':
                    generateDryer(leftChannel, rightChannel, numSamples);
                    break;
                case 'dishwasher':
                    generateDishwasher(leftChannel, rightChannel, numSamples);
                    break;
                case 'mouse-clicks':
                    generateMouseClicks(leftChannel, rightChannel, numSamples);
                    break;
                case 'pencil':
                    generatePencil(leftChannel, rightChannel, numSamples);
                    break;
                case 'shower':
                    generateShower(leftChannel, rightChannel, numSamples);
                    break;
                case 'bathtub':
                    generateBathtub(leftChannel, rightChannel, numSamples);
                    break;
                case 'boiling':
                    generateBoiling(leftChannel, rightChannel, numSamples);
                    break;
                case 'cats-purr':
                    generateCatsPurr(leftChannel, rightChannel, numSamples);
                    break;
                case 'humming':
                    generateHumming(leftChannel, rightChannel, numSamples);
                    break;
                case 'baby-breathing':
                    generateBabyBreathing(leftChannel, rightChannel, numSamples);
                    break;
                // New Urban sounds
                case 'library':
                    generateLibrary(leftChannel, rightChannel, numSamples);
                    break;
                case 'office':
                    generateOffice(leftChannel, rightChannel, numSamples);
                    break;
                case 'highway':
                    generateHighway(leftChannel, rightChannel, numSamples);
                    break;
                case 'train':
                    generateTrain(leftChannel, rightChannel, numSamples);
                    break;
                case 'airport':
                    generateAirport(leftChannel, rightChannel, numSamples);
                    break;
                case 'airplane':
                    generateAirplane(leftChannel, rightChannel, numSamples);
                    break;
                case 'bar':
                    generateBar(leftChannel, rightChannel, numSamples);
                    break;
                case 'mall':
                    generateMall(leftChannel, rightChannel, numSamples);
                    break;
                case 'playground':
                    generatePlayground(leftChannel, rightChannel, numSamples);
                    break;
                case 'construction':
                    generateConstruction(leftChannel, rightChannel, numSamples);
                    break;
                case 'city-night':
                    generateCityNight(leftChannel, rightChannel, numSamples);
                    break;
                case 'crowd-murmur':
                    generateCrowdMurmur(leftChannel, rightChannel, numSamples);
                    break;
                case 'distant-party':
                    generateDistantParty(leftChannel, rightChannel, numSamples);
                    break;
                case 'street-busker':
                    generateStreetBusker(leftChannel, rightChannel, numSamples);
                    break;
                // Mechanical sounds
                case 'engine-idle':
                    generateEngineIdle(leftChannel, rightChannel, numSamples);
                    break;
                case 'ship-engine':
                    generateShipEngine(leftChannel, rightChannel, numSamples);
                    break;
                case 'generator':
                    generateGenerator(leftChannel, rightChannel, numSamples);
                    break;
                case 'machinery':
                    generateMachinery(leftChannel, rightChannel, numSamples);
                    break;
                case 'server-room':
                    generateServerRoom(leftChannel, rightChannel, numSamples);
                    break;
                case 'hard-drive':
                    generateHardDrive(leftChannel, rightChannel, numSamples);
                    break;
                case 'printer':
                    generatePrinter(leftChannel, rightChannel, numSamples);
                    break;
                case 'ventilation':
                    generateVentilation(leftChannel, rightChannel, numSamples);
                    break;
                case 'electric-hum':
                    generateElectricHum(leftChannel, rightChannel, numSamples);
                    break;
                case 'transformer':
                    generateTransformer(leftChannel, rightChannel, numSamples);
                    break;
                // Sci-Fi sounds
                case 'spaceship':
                    generateSpaceship(leftChannel, rightChannel, numSamples);
                    break;
                case 'warp-drive':
                    generateWarpDrive(leftChannel, rightChannel, numSamples);
                    break;
                case 'alien-planet':
                    generateAlienPlanet(leftChannel, rightChannel, numSamples);
                    break;
                case 'space-station':
                    generateSpaceStation(leftChannel, rightChannel, numSamples);
                    break;
                case 'underwater-base':
                    generateUnderwaterBase(leftChannel, rightChannel, numSamples);
                    break;
                case 'radioactive':
                    generateRadioactive(leftChannel, rightChannel, numSamples);
                    break;
                case 'energy-field':
                    generateEnergyField(leftChannel, rightChannel, numSamples);
                    break;
                case 'quantum-hum':
                    generateQuantumHum(leftChannel, rightChannel, numSamples);
                    break;
                // New Abstract sounds
                case 'blue-noise':
                    generateBlueNoise(leftChannel, rightChannel, numSamples);
                    break;
                case 'grey-noise':
                    generateGreyNoise(leftChannel, rightChannel, numSamples);
                    break;
                case 'binaural-alpha':
                    generateBinauralAlpha(leftChannel, rightChannel, numSamples);
                    break;
                case 'binaural-theta':
                    generateBinauralTheta(leftChannel, rightChannel, numSamples);
                    break;
                case 'binaural-focus':
                    generateBinaural(leftChannel, rightChannel, numSamples);
                    break;
                case 'drone-dark':
                    generateDroneDark(leftChannel, rightChannel, numSamples);
                    break;
                case 'drone-light':
                    generateDroneLight(leftChannel, rightChannel, numSamples);
                    break;
                case 'sine-60hz':
                    generateSine60Hz(leftChannel, rightChannel, numSamples);
                    break;
                case 'sine-432hz':
                    generateSine432Hz(leftChannel, rightChannel, numSamples);
                    break;
                case 'harmonic-series':
                    generateHarmonicSeries(leftChannel, rightChannel, numSamples);
                    break;
                case 'shepard-tone':
                    generateShepardTone(leftChannel, rightChannel, numSamples);
                    break;
                default:
                    generateWhiteNoise(leftChannel, rightChannel, numSamples);
            }

            return buffer;
        }

        // Sound generation functions
        function generateRain(left, right, samples, density, dropSize) {
            const sampleRate = 44100;

            // Base rain ambience - filtered noise
            let rainAmbL = 0, rainAmbR = 0;
            for (let i = 0; i < samples; i++) {
                rainAmbL += (Math.random() * 2 - 1) * dropSize * 0.5;
                rainAmbR += (Math.random() * 2 - 1) * dropSize * 0.5;
                rainAmbL *= 0.997;
                rainAmbR *= 0.997;
                left[i] = rainAmbL;
                right[i] = rainAmbR;
            }

            // Individual raindrops with splatter
            for (let i = 0; i < samples; i++) {
                if (Math.random() < density * 0.8) {
                    // Small drops - quick splatter
                    const dropLength = Math.floor(Math.random() * 200 + 50);
                    const amplitude = Math.random() * dropSize * 0.6;
                    const pan = Math.random();
                    const dropFreq = Math.random() * 3000 + 2000; // Higher freq for small drops

                    for (let j = 0; j < dropLength && i + j < samples; j++) {
                        const env = Math.exp(-j / (dropLength * 0.15));
                        const impact = Math.sin(j / sampleRate * dropFreq * Math.PI * 2) * env * 0.1;
                        const noise = (Math.random() * 2 - 1) * amplitude * env;
                        left[i + j] += (noise + impact) * (1 - pan * 0.5);
                        right[i + j] += (noise + impact) * (0.5 + pan * 0.5);
                    }
                }

                // Occasional larger drops with deeper sound
                if (Math.random() < density * 0.05) {
                    const dropLength = Math.floor(Math.random() * 600 + 300);
                    const amplitude = Math.random() * dropSize * 1.5;
                    const pan = Math.random();

                    for (let j = 0; j < dropLength && i + j < samples; j++) {
                        const env = Math.exp(-j / (dropLength * 0.2));
                        const noise = (Math.random() * 2 - 1) * amplitude * env;
                        // Add low thump for big drops
                        const thump = Math.sin(j / sampleRate * 150 * Math.PI * 2) * env * amplitude * 0.5;
                        left[i + j] += (noise + thump) * (1 - pan * 0.3);
                        right[i + j] += (noise + thump) * (0.7 + pan * 0.3);
                    }
                }
            }

            // Intensity variation over time
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                const intensityMod = Math.sin(t * 0.15) * 0.2 + 0.9;
                left[i] *= intensityMod;
                right[i] *= intensityMod;
            }
        }

        function generateThunder(left, right, samples) {
            // Background rumble
            let rumble = 0;
            for (let i = 0; i < samples; i++) {
                rumble += (Math.random() * 2 - 1) * 0.01;
                rumble *= 0.999;
                const vol = 0.05 + Math.sin(i / samples * Math.PI * 2 * 0.1) * 0.03;
                left[i] = rumble * vol;
                right[i] = rumble * vol;
            }

            // Occasional thunder claps
            const numClaps = Math.floor(Math.random() * 2) + 1;
            for (let c = 0; c < numClaps; c++) {
                const startPos = Math.floor(Math.random() * (samples - 44100 * 3));
                const clapLength = Math.floor(44100 * (1 + Math.random() * 2));
                for (let i = 0; i < clapLength && startPos + i < samples; i++) {
                    const t = i / clapLength;
                    const env = Math.exp(-t * 4) * (1 - Math.exp(-t * 100));
                    const noise = (Math.random() * 2 - 1) * env * 0.3;
                    left[startPos + i] += noise;
                    right[startPos + i] += noise * 0.9;
                }
            }
        }

        function generateWind(left, right, samples, intensity, speed) {
            const sampleRate = 44100;
            let windL = 0, windR = 0;
            let gustL = 0, gustR = 0;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Base wind with multiple modulation frequencies
                const mod1 = Math.sin(t * speed * Math.PI * 2) * 0.4 + 0.6;
                const mod2 = Math.sin(t * speed * 0.3 * Math.PI * 2 + 1) * 0.2 + 0.8;
                const mod3 = Math.sin(t * speed * 2.5 * Math.PI * 2 + 0.5) * 0.1 + 0.9;
                const modulation = mod1 * mod2 * mod3;

                // Primary wind layer
                windL += (Math.random() * 2 - 1) * 0.012 * intensity;
                windR += (Math.random() * 2 - 1) * 0.012 * intensity;
                windL *= 0.9975;
                windR *= 0.9975;

                // Higher frequency gust layer
                gustL += (Math.random() * 2 - 1) * 0.008 * intensity;
                gustR += (Math.random() * 2 - 1) * 0.008 * intensity;
                gustL *= 0.995;
                gustR *= 0.995;

                // Occasional stronger gusts
                let gust = 0;
                if (Math.sin(t * 0.1 * Math.PI * 2) > 0.8) {
                    gust = (Math.sin(t * 0.1 * Math.PI * 2) - 0.8) * 2;
                }

                // Whistling (at higher speeds)
                const whistle = speed < 1 ? 0 :
                    Math.sin(t * (800 + Math.sin(t * 3) * 100) * Math.PI * 2) * 0.003 * intensity * gust;

                // Combine
                left[i] = (windL + gustL * 0.5) * modulation * (1 + gust * 0.3) + whistle;
                right[i] = (windR + gustR * 0.5) * modulation * (1 + gust * 0.3) + whistle * 0.9;
            }
        }

        function generateStream(left, right, samples) {
            let waterL = 0, waterR = 0;
            for (let i = 0; i < samples; i++) {
                waterL += (Math.random() * 2 - 1) * 0.02;
                waterR += (Math.random() * 2 - 1) * 0.02;
                waterL *= 0.997;
                waterR *= 0.997;

                // Add some bubbling
                if (Math.random() < 0.001) {
                    const bubbleLen = Math.floor(Math.random() * 1000 + 500);
                    const freq = Math.random() * 2000 + 500;
                    for (let j = 0; j < bubbleLen && i + j < samples; j++) {
                        const env = Math.exp(-j / (bubbleLen * 0.2));
                        const bubble = Math.sin(j / 44100 * freq * Math.PI * 2) * env * 0.02;
                        const pan = Math.random();
                        left[i + j] += bubble * (1 - pan);
                        right[i + j] += bubble * pan;
                    }
                }

                left[i] += waterL;
                right[i] += waterR;
            }
        }

        function generateOcean(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Multiple wave frequencies for natural rhythm
                // Primary swell (8-12 second period)
                const swell = Math.sin(t * 0.09 * Math.PI * 2) * 0.5 + 0.5;
                // Secondary waves (5-7 second)
                const wave2 = Math.sin(t * 0.15 * Math.PI * 2 + 0.5) * 0.3 + 0.35;
                // Smaller waves (2-3 second)
                const wave3 = Math.sin(t * 0.4 * Math.PI * 2 + 1.2) * 0.15 + 0.2;

                // Combined wave envelope
                const waveEnv = swell * wave2 + wave3 * 0.3;

                // Base ocean roar
                const roar = (Math.random() * 2 - 1) * waveEnv * 0.12;

                // Wave crashing/breaking sound at peaks
                let crash = 0;
                const crashThreshold = 0.6;
                if (swell > crashThreshold) {
                    const crashIntensity = (swell - crashThreshold) / (1 - crashThreshold);
                    crash = (Math.random() * 2 - 1) * crashIntensity * 0.08;
                }

                // Foam/hiss after wave breaks
                const foamPhase = swell < 0.4 && wave2 > 0.3 ? (0.4 - swell) / 0.4 : 0;
                const foam = (Math.random() * 2 - 1) * foamPhase * 0.03;

                // Subtle low frequency rumble
                const rumble = Math.sin(t * 15 * Math.PI * 2) * waveEnv * 0.02;

                // Stereo width - waves coming from different angles
                const stereoMod = Math.sin(t * 0.05 * Math.PI * 2) * 0.15;

                left[i] = roar + crash + foam + rumble * (1 + stereoMod);
                right[i] = roar * 0.97 + crash * 0.95 + foam + rumble * (1 - stereoMod);
            }

            // Gentle lowpass for that distant ocean feel
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.6 + left[i-1] * 0.4;
                right[i] = right[i] * 0.6 + right[i-1] * 0.4;
            }
        }

        function generateBirds(left, right, samples) {
            const sampleRate = 44100;

            // Light forest ambient - rustling leaves
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                const leafRustle = (Math.random() * 2 - 1) * 0.008 * (Math.sin(t * 0.5) * 0.3 + 0.7);
                left[i] = leafRustle;
                right[i] = leafRustle * 0.95;
            }

            // Multiple bird types with different call patterns
            const birdTypes = [
                // Robin - melodic descending phrases
                { baseFreq: 2200, type: 'robin', count: 3 },
                // Sparrow - chirpy, rapid
                { baseFreq: 3500, type: 'sparrow', count: 4 },
                // Warbler - trills
                { baseFreq: 2800, type: 'warbler', count: 2 },
                // Chickadee - two-note call
                { baseFreq: 3200, type: 'chickadee', count: 2 },
                // Distant crow
                { baseFreq: 600, type: 'crow', count: 1 }
            ];

            birdTypes.forEach(bird => {
                for (let b = 0; b < bird.count; b++) {
                    const pan = Math.random();
                    const volume = 0.02 + Math.random() * 0.02;

                    // Each bird makes multiple calls at different times
                    const numCalls = Math.floor(Math.random() * 4) + 2;
                    for (let c = 0; c < numCalls; c++) {
                        const startPos = Math.floor(Math.random() * (samples - sampleRate * 2));

                        if (bird.type === 'robin') {
                            // Robin: melodic phrase with descending notes
                            const phraseLen = Math.floor(sampleRate * (0.4 + Math.random() * 0.3));
                            const numNotes = 3 + Math.floor(Math.random() * 3);
                            for (let n = 0; n < numNotes; n++) {
                                const noteStart = startPos + Math.floor(n * phraseLen / numNotes);
                                const noteLen = Math.floor(phraseLen / numNotes * 0.8);
                                const noteFreq = bird.baseFreq * (1 - n * 0.08 + Math.random() * 0.05);
                                for (let i = 0; i < noteLen && noteStart + i < samples; i++) {
                                    const t = i / noteLen;
                                    const env = Math.sin(t * Math.PI) * volume;
                                    const vibrato = 1 + Math.sin(i / sampleRate * 30 * Math.PI * 2) * 0.02;
                                    const sound = Math.sin(i / sampleRate * noteFreq * vibrato * Math.PI * 2) * env;
                                    left[noteStart + i] += sound * (1 - pan);
                                    right[noteStart + i] += sound * pan;
                                }
                            }
                        } else if (bird.type === 'sparrow') {
                            // Sparrow: rapid chirps
                            const numChirps = 4 + Math.floor(Math.random() * 4);
                            for (let ch = 0; ch < numChirps; ch++) {
                                const chirpStart = startPos + ch * Math.floor(sampleRate * 0.08);
                                const chirpLen = Math.floor(sampleRate * 0.04);
                                const chirpFreq = bird.baseFreq + Math.random() * 500;
                                for (let i = 0; i < chirpLen && chirpStart + i < samples; i++) {
                                    const t = i / chirpLen;
                                    const env = Math.sin(t * Math.PI) * Math.exp(-t * 3) * volume;
                                    const freqSweep = chirpFreq * (1 + t * 0.3);
                                    const sound = Math.sin(i / sampleRate * freqSweep * Math.PI * 2) * env;
                                    left[chirpStart + i] += sound * (1 - pan);
                                    right[chirpStart + i] += sound * pan;
                                }
                            }
                        } else if (bird.type === 'warbler') {
                            // Warbler: trill
                            const trillLen = Math.floor(sampleRate * (0.5 + Math.random() * 0.5));
                            for (let i = 0; i < trillLen && startPos + i < samples; i++) {
                                const t = i / trillLen;
                                const env = Math.sin(t * Math.PI) * volume;
                                const trillMod = Math.sin(i / sampleRate * 25 * Math.PI * 2) * 0.5 + 0.5;
                                const freq = bird.baseFreq * (1 + Math.sin(t * Math.PI * 3) * 0.1);
                                const sound = Math.sin(i / sampleRate * freq * Math.PI * 2) * env * trillMod;
                                left[startPos + i] += sound * (1 - pan);
                                right[startPos + i] += sound * pan;
                            }
                        } else if (bird.type === 'chickadee') {
                            // Chickadee: "fee-bee" two notes
                            const note1Len = Math.floor(sampleRate * 0.25);
                            const note2Len = Math.floor(sampleRate * 0.35);
                            // High note
                            for (let i = 0; i < note1Len && startPos + i < samples; i++) {
                                const t = i / note1Len;
                                const env = Math.sin(t * Math.PI) * volume;
                                const sound = Math.sin(i / sampleRate * bird.baseFreq * Math.PI * 2) * env;
                                left[startPos + i] += sound * (1 - pan);
                                right[startPos + i] += sound * pan;
                            }
                            // Lower note
                            const note2Start = startPos + note1Len + Math.floor(sampleRate * 0.05);
                            for (let i = 0; i < note2Len && note2Start + i < samples; i++) {
                                const t = i / note2Len;
                                const env = Math.sin(t * Math.PI) * volume * 0.9;
                                const sound = Math.sin(i / sampleRate * bird.baseFreq * 0.75 * Math.PI * 2) * env;
                                left[note2Start + i] += sound * (1 - pan);
                                right[note2Start + i] += sound * pan;
                            }
                        } else if (bird.type === 'crow') {
                            // Crow: harsh caw
                            const cawLen = Math.floor(sampleRate * 0.3);
                            for (let i = 0; i < cawLen && startPos + i < samples; i++) {
                                const t = i / cawLen;
                                const env = Math.sin(t * Math.PI) * Math.exp(-t) * volume * 1.5;
                                const harsh = Math.sin(i / sampleRate * bird.baseFreq * Math.PI * 2);
                                const harmonics = Math.sin(i / sampleRate * bird.baseFreq * 2 * Math.PI * 2) * 0.5;
                                const noise = (Math.random() * 2 - 1) * 0.3;
                                const sound = (harsh + harmonics + noise) * env;
                                left[startPos + i] += sound * (1 - pan) * 0.7;
                                right[startPos + i] += sound * pan * 0.7;
                            }
                        }
                    }
                }
            });
        }

        function generateCrickets(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Multiple cricket frequencies
                const cricket1 = Math.sin(t * 4500 * Math.PI * 2) * 0.02;
                const cricket2 = Math.sin(t * 4800 * Math.PI * 2) * 0.015;
                // Pulsing envelope
                const pulse = Math.sin(t * 15 * Math.PI * 2) > 0.3 ? 1 : 0.1;
                const pulse2 = Math.sin(t * 12 * Math.PI * 2 + 2) > 0.4 ? 1 : 0.1;

                left[i] = cricket1 * pulse + (Math.random() * 2 - 1) * 0.003;
                right[i] = cricket2 * pulse2 + (Math.random() * 2 - 1) * 0.003;
            }
        }

        function generateFireplace(left, right, samples) {
            const sampleRate = 44100;
            let crackleL = 0, crackleR = 0;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Base fire roar - filtered noise with warmth
                crackleL += (Math.random() * 2 - 1) * 0.014;
                crackleR += (Math.random() * 2 - 1) * 0.014;
                crackleL *= 0.996;
                crackleR *= 0.996;

                // Fire intensity breathing (flames dancing)
                const breathe = Math.sin(t * 0.3 * Math.PI * 2) * 0.15 +
                               Math.sin(t * 0.7 * Math.PI * 2) * 0.1 +
                               Math.sin(t * 1.3 * Math.PI * 2) * 0.05 + 0.7;

                // Low rumble of fire
                const rumble = Math.sin(t * 25 * Math.PI * 2) * 0.008 * breathe;

                // Crackles and pops - varying intensity
                if (Math.random() < 0.001 * breathe) {
                    const popLen = Math.floor(Math.random() * 600 + 150);
                    const intensity = Math.random() * 0.12 + 0.03;
                    const popFreq = Math.random() * 2000 + 1000;
                    const pan = Math.random();

                    for (let j = 0; j < popLen && i + j < samples; j++) {
                        const env = Math.exp(-j / (popLen * 0.12));
                        // Combination of noise and resonant ring
                        const noise = (Math.random() * 2 - 1) * env * intensity;
                        const ring = Math.sin(j / sampleRate * popFreq * Math.PI * 2) * env * intensity * 0.3;
                        left[i + j] += (noise + ring) * (0.5 + pan * 0.5);
                        right[i + j] += (noise + ring) * (1 - pan * 0.5);
                    }
                }

                // Occasional log shift/settle
                if (Math.random() < 0.00005) {
                    const shiftLen = Math.floor(sampleRate * 0.3);
                    for (let j = 0; j < shiftLen && i + j < samples; j++) {
                        const env = Math.sin(j / shiftLen * Math.PI) * 0.03;
                        const shift = (Math.random() * 2 - 1) * env;
                        left[i + j] += shift;
                        right[i + j] += shift * 0.85;
                    }
                }

                // Ember glow hiss
                const hiss = (Math.random() * 2 - 1) * 0.004;

                left[i] += (crackleL + rumble + hiss) * breathe;
                right[i] += (crackleR + rumble + hiss) * breathe * 0.97;
            }
        }

        function generateClock(left, right, samples) {
            const tickInterval = Math.floor(44100); // 1 second
            for (let tick = 0; tick < samples / tickInterval; tick++) {
                const pos = tick * tickInterval;
                const isTock = tick % 2 === 1;
                const freq = isTock ? 800 : 1000;
                const len = 400;

                for (let i = 0; i < len && pos + i < samples; i++) {
                    const env = Math.exp(-i / 80);
                    const sound = Math.sin(i / 44100 * freq * Math.PI * 2) * env * 0.08;
                    left[pos + i] += sound;
                    right[pos + i] += sound;
                }
            }
        }

        function generateFan(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Low frequency hum
                const hum = Math.sin(t * 120 * Math.PI * 2) * 0.02;
                // White noise filtered
                const noise = (Math.random() * 2 - 1) * 0.06;
                left[i] = hum + noise;
                right[i] = hum + noise * 0.98;
            }
            // Apply simple lowpass by averaging
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.3 + left[i-1] * 0.7;
                right[i] = right[i] * 0.3 + right[i-1] * 0.7;
            }
        }

        function generateTyping(left, right, samples) {
            const sampleRate = 44100;

            // State machine for typing patterns
            let isTyping = false;
            let burstEnd = 0;
            let pauseEnd = 0;
            let nextKey = 0;

            for (let i = 0; i < samples; i++) {
                // Decide if we should be typing or pausing
                if (!isTyping && i >= pauseEnd) {
                    isTyping = true;
                    burstEnd = i + Math.floor(sampleRate * (1 + Math.random() * 4)); // 1-5 second bursts
                    nextKey = i;
                }
                if (isTyping && i >= burstEnd) {
                    isTyping = false;
                    pauseEnd = i + Math.floor(sampleRate * (0.3 + Math.random() * 1.5)); // 0.3-1.8 second pauses
                }

                if (isTyping && i >= nextKey) {
                    // Different key types
                    const keyType = Math.random();
                    let keyLen, keyFreq, keyVol, pan;

                    if (keyType < 0.7) {
                        // Regular key
                        keyLen = Math.floor(Math.random() * 150 + 50);
                        keyFreq = Math.random() * 1500 + 3000;
                        keyVol = 0.06 + Math.random() * 0.03;
                        pan = Math.random() * 0.3 + 0.35;
                    } else if (keyType < 0.9) {
                        // Spacebar - lower, longer
                        keyLen = Math.floor(Math.random() * 200 + 100);
                        keyFreq = Math.random() * 800 + 1500;
                        keyVol = 0.08 + Math.random() * 0.03;
                        pan = 0.5;
                    } else {
                        // Enter/Shift - distinct
                        keyLen = Math.floor(Math.random() * 250 + 100);
                        keyFreq = Math.random() * 600 + 2000;
                        keyVol = 0.1;
                        pan = keyType < 0.95 ? 0.7 : 0.3;
                    }

                    // Key down sound
                    for (let j = 0; j < keyLen && i + j < samples; j++) {
                        const env = Math.exp(-j / 25);
                        const click = (Math.random() * 2 - 1) * env * keyVol;
                        const resonance = Math.sin(j / sampleRate * keyFreq * Math.PI * 2) * env * keyVol * 0.2;
                        left[i + j] += (click + resonance) * (1 - pan * 0.5);
                        right[i + j] += (click + resonance) * (0.5 + pan * 0.5);
                    }

                    // Typing speed varies
                    const baseInterval = 1800; // ~5.5 keys per second
                    const variation = Math.random() < 0.2 ? 2 : 1; // Sometimes slower (thinking)
                    nextKey = i + Math.floor((Math.random() * baseInterval + 800) * variation);
                }
            }
        }

        function generatePages(left, right, samples) {
            let nextPage = Math.floor(Math.random() * 88200 + 44100);
            for (let i = 0; i < samples; i++) {
                if (i >= nextPage) {
                    const pageLen = Math.floor(Math.random() * 15000 + 8000);
                    for (let j = 0; j < pageLen && i + j < samples; j++) {
                        const t = j / pageLen;
                        const env = Math.sin(t * Math.PI) * 0.06;
                        const rustle = (Math.random() * 2 - 1) * env;
                        left[i + j] += rustle;
                        right[i + j] += rustle * 0.9;
                    }
                    nextPage = i + Math.floor(Math.random() * 176400 + 88200);
                }
            }
        }

        function generateVinyl(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                // Constant crackle
                const crackle = (Math.random() * 2 - 1) * 0.015;
                // Occasional pops
                const pop = Math.random() < 0.0001 ? (Math.random() * 2 - 1) * 0.1 : 0;
                // Low rumble
                const rumble = Math.sin(i / 44100 * 33 * Math.PI * 2) * 0.008;

                left[i] = crackle + pop + rumble;
                right[i] = crackle * 0.95 + pop + rumble;
            }
        }

        function generateCafe(left, right, samples) {
            const sampleRate = 44100;

            // Background murmur - multiple layers for richness
            let murmurL1 = 0, murmurR1 = 0;
            let murmurL2 = 0, murmurR2 = 0;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Layer 1 - close conversation murmur
                murmurL1 += (Math.random() * 2 - 1) * 0.01;
                murmurR1 += (Math.random() * 2 - 1) * 0.01;
                murmurL1 *= 0.998;
                murmurR1 *= 0.998;

                // Layer 2 - distant chatter (more filtered)
                murmurL2 += (Math.random() * 2 - 1) * 0.006;
                murmurR2 += (Math.random() * 2 - 1) * 0.006;
                murmurL2 *= 0.9995;
                murmurR2 *= 0.9995;

                // Volume swells like conversation dynamics
                const swell = Math.sin(t * 0.2) * 0.1 + Math.sin(t * 0.5) * 0.05 + 0.85;

                left[i] = (murmurL1 + murmurL2) * swell;
                right[i] = (murmurR1 + murmurR2) * swell;
            }

            // Espresso machine steaming (periodic)
            for (let s = 0; s < 3; s++) {
                const steamPos = Math.floor(Math.random() * (samples - sampleRate * 3));
                const steamLen = Math.floor(sampleRate * (1 + Math.random()));
                for (let i = 0; i < steamLen && steamPos + i < samples; i++) {
                    const t = i / steamLen;
                    const env = Math.sin(t * Math.PI) * 0.04;
                    const steam = (Math.random() * 2 - 1) * env;
                    left[steamPos + i] += steam * 0.4;
                    right[steamPos + i] += steam * 0.6;
                }
            }

            // Cup and saucer sounds
            for (let c = 0; c < 20; c++) {
                const pos = Math.floor(Math.random() * (samples - 3000));
                const pan = Math.random();
                const soundType = Math.random();

                if (soundType < 0.5) {
                    // Ceramic clink
                    const freq = Math.random() * 2000 + 3000;
                    const len = Math.floor(Math.random() * 800 + 200);
                    for (let i = 0; i < len && pos + i < samples; i++) {
                        const env = Math.exp(-i / 100);
                        const clink = Math.sin(i / sampleRate * freq * Math.PI * 2) * env * 0.025;
                        left[pos + i] += clink * (1 - pan);
                        right[pos + i] += clink * pan;
                    }
                } else if (soundType < 0.8) {
                    // Spoon stir
                    const len = Math.floor(Math.random() * 4000 + 2000);
                    for (let i = 0; i < len && pos + i < samples; i++) {
                        const t = i / len;
                        const stirPhase = (i / sampleRate * 3) % 1;
                        const stir = stirPhase < 0.3 ?
                            Math.sin(i / sampleRate * 4000 * Math.PI * 2) * Math.exp(-stirPhase * 10) * 0.01 : 0;
                        left[pos + i] += stir * (1 - pan);
                        right[pos + i] += stir * pan;
                    }
                } else {
                    // Coffee pour
                    const len = Math.floor(sampleRate * (0.5 + Math.random() * 0.5));
                    for (let i = 0; i < len && pos + i < samples; i++) {
                        const t = i / len;
                        const env = Math.sin(t * Math.PI) * 0.02;
                        const pour = (Math.random() * 2 - 1) * env;
                        left[pos + i] += pour * (1 - pan);
                        right[pos + i] += pour * pan;
                    }
                }
            }

            // Occasional laughter (distant)
            for (let l = 0; l < 2; l++) {
                const laughPos = Math.floor(Math.random() * (samples - sampleRate));
                const laughLen = Math.floor(sampleRate * (0.4 + Math.random() * 0.3));
                const pan = Math.random();

                for (let i = 0; i < laughLen && laughPos + i < samples; i++) {
                    const t = i / laughLen;
                    const burstPhase = (i / sampleRate * 6) % 1;
                    const burst = burstPhase < 0.4 ? Math.sin(burstPhase / 0.4 * Math.PI) : 0;
                    const env = Math.sin(t * Math.PI) * burst * 0.015;
                    const laugh = Math.sin(i / sampleRate * (250 + Math.random() * 100) * Math.PI * 2) * env;
                    left[laughPos + i] += laugh * (1 - pan);
                    right[laughPos + i] += laugh * pan;
                }
            }
        }

        function generateTraffic(left, right, samples) {
            const sampleRate = 44100;

            // Ambient city rumble - low frequency background
            let rumbleL = 0, rumbleR = 0;
            for (let i = 0; i < samples; i++) {
                rumbleL += (Math.random() * 2 - 1) * 0.006;
                rumbleR += (Math.random() * 2 - 1) * 0.006;
                rumbleL *= 0.9985;
                rumbleR *= 0.9985;
                left[i] = rumbleL;
                right[i] = rumbleR;
            }

            // Passing vehicles with realistic engine sounds and Doppler
            const numVehicles = Math.floor(Math.random() * 6) + 4;
            for (let v = 0; v < numVehicles; v++) {
                const startPos = Math.floor(Math.random() * (samples - sampleRate * 4));
                const passLen = Math.floor(sampleRate * (2 + Math.random() * 2));
                const direction = Math.random() > 0.5 ? 1 : -1; // Left-to-right or right-to-left
                const vehicleType = Math.random();

                // Different vehicle characteristics
                let baseFreq, engineCharacter, volume;
                if (vehicleType < 0.6) {
                    // Regular car
                    baseFreq = 80 + Math.random() * 40;
                    engineCharacter = 'car';
                    volume = 0.06 + Math.random() * 0.03;
                } else if (vehicleType < 0.85) {
                    // Truck/bus - lower, more rumble
                    baseFreq = 40 + Math.random() * 20;
                    engineCharacter = 'truck';
                    volume = 0.08 + Math.random() * 0.04;
                } else {
                    // Motorcycle - higher, buzzy
                    baseFreq = 150 + Math.random() * 50;
                    engineCharacter = 'motorcycle';
                    volume = 0.05 + Math.random() * 0.03;
                }

                for (let i = 0; i < passLen && startPos + i < samples; i++) {
                    const t = i / passLen; // 0 to 1 progress

                    // Doppler effect - approaching sounds higher, receding sounds lower
                    const dopplerPosition = (t - 0.5) * 2; // -1 to 1
                    const dopplerFactor = 1 / (1 + dopplerPosition * 0.15);

                    // Volume envelope - loudest at center
                    const distance = Math.abs(t - 0.5) * 2; // 0 at center, 1 at edges
                    const volEnv = Math.pow(1 - distance, 1.5) * volume;

                    // Stereo panning
                    const pan = direction > 0 ? t : (1 - t);

                    // Engine sound based on type
                    let engineSound = 0;
                    const time = i / sampleRate;
                    const freq = baseFreq * dopplerFactor;

                    if (engineCharacter === 'car') {
                        // 4-cylinder engine simulation
                        engineSound = Math.sin(time * freq * Math.PI * 2) * 0.5;
                        engineSound += Math.sin(time * freq * 2 * Math.PI * 2) * 0.25;
                        engineSound += Math.sin(time * freq * 4 * Math.PI * 2) * 0.15;
                        // Add some tire noise
                        engineSound += (Math.random() * 2 - 1) * 0.3;
                    } else if (engineCharacter === 'truck') {
                        // Diesel rumble
                        engineSound = Math.sin(time * freq * Math.PI * 2) * 0.6;
                        engineSound += Math.sin(time * freq * 0.5 * Math.PI * 2) * 0.3;
                        engineSound += (Math.random() * 2 - 1) * 0.4;
                        // Air brake hiss occasionally
                        if (t > 0.7 && Math.random() < 0.0001) {
                            for (let j = 0; j < 5000 && i + j < passLen && startPos + i + j < samples; j++) {
                                const hiss = (Math.random() * 2 - 1) * Math.exp(-j / 1000) * 0.1;
                                left[startPos + i + j] += hiss * (1 - pan);
                                right[startPos + i + j] += hiss * pan;
                            }
                        }
                    } else {
                        // Motorcycle - buzzy
                        engineSound = Math.sin(time * freq * Math.PI * 2) * 0.4;
                        engineSound += Math.sin(time * freq * 1.5 * Math.PI * 2) * 0.3;
                        engineSound += Math.sin(time * freq * 3 * Math.PI * 2) * 0.2;
                        engineSound += (Math.random() * 2 - 1) * 0.2;
                    }

                    const finalSound = engineSound * volEnv;
                    left[startPos + i] += finalSound * (1 - pan * 0.7);
                    right[startPos + i] += finalSound * (0.3 + pan * 0.7);
                }
            }

            // Apply gentle lowpass to smooth it out
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.6 + left[i-1] * 0.4;
                right[i] = right[i] * 0.6 + right[i-1] * 0.4;
            }
        }

        function generateSubway(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Rail joint rhythm - faster than regular train
                const jointInterval = 0.5;
                const jointPhase = (t % jointInterval) / jointInterval;

                // Wheel-rail clacking
                const clack = jointPhase < 0.08 ?
                    (Math.random() * 2 - 1) * Math.exp(-jointPhase * 30) * 0.045 : 0;

                // Tunnel resonance - low rumble amplified by tunnel
                const rumble = Math.sin(t * 25 * Math.PI * 2) * 0.035;
                const rumble2 = Math.sin(t * 50 * Math.PI * 2) * 0.02;

                // Electric motor whine
                const motorWhine = Math.sin(t * 300 * Math.PI * 2) * 0.008 *
                    (Math.sin(t * 0.1 * Math.PI * 2) * 0.2 + 0.8);

                // Air rushing through tunnel
                const tunnel = (Math.random() * 2 - 1) * 0.025;

                // Brake squeal when slowing (occasional)
                let squeal = 0;
                if (Math.sin(t * 0.02 * Math.PI * 2) > 0.95) {
                    squeal = Math.sin(t * 2500 * Math.PI * 2) * 0.008 *
                        (1 - ((t * 0.02) % 1));
                }

                // Door chime approaching station (rare)
                let chime = 0;
                if (Math.random() < 0.00001) {
                    for (let j = 0; j < sampleRate && i + j < samples; j++) {
                        const chimeTone = Math.sin(j / sampleRate * 800 * Math.PI * 2);
                        const chimeEnv = j < sampleRate / 4 ? 1 : Math.exp(-(j - sampleRate / 4) / 5000);
                        chime = chimeTone * chimeEnv * 0.02;
                        left[i + j] += chime;
                        right[i + j] += chime;
                    }
                }

                // Sway effect
                const sway = Math.sin(t * 0.4 * Math.PI * 2) * 0.08;

                const signal = clack + rumble + rumble2 + motorWhine + tunnel + squeal;
                left[i] = signal * (1 + sway);
                right[i] = signal * (1 - sway);
            }

            // Tunnel echo simulation
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.5 + left[i-1] * 0.5;
                right[i] = right[i] * 0.5 + right[i-1] * 0.5;
            }
        }

        function generateRestaurant(left, right, samples) {
            // Background chatter
            let chatterL = 0, chatterR = 0;
            for (let i = 0; i < samples; i++) {
                chatterL += (Math.random() * 2 - 1) * 0.01;
                chatterR += (Math.random() * 2 - 1) * 0.01;
                chatterL *= 0.998;
                chatterR *= 0.998;

                left[i] = chatterL;
                right[i] = chatterR;
            }

            // Dishes clattering
            for (let c = 0; c < 20; c++) {
                const pos = Math.floor(Math.random() * (samples - 3000));
                const len = Math.floor(Math.random() * 1500 + 500);
                const pan = Math.random();

                for (let i = 0; i < len && pos + i < samples; i++) {
                    const env = Math.exp(-i / 150);
                    const clatter = (Math.random() * 2 - 1) * env * 0.04;
                    left[pos + i] += clatter * (1 - pan);
                    right[pos + i] += clatter * pan;
                }
            }
        }

        function generateBrownNoise(left, right, samples) {
            let valueL = 0, valueR = 0;
            for (let i = 0; i < samples; i++) {
                valueL += (Math.random() * 2 - 1) * 0.02;
                valueR += (Math.random() * 2 - 1) * 0.02;
                valueL = Math.max(-1, Math.min(1, valueL)) * 0.998;
                valueR = Math.max(-1, Math.min(1, valueR)) * 0.998;
                left[i] = valueL * 0.5;
                right[i] = valueR * 0.5;
            }
        }

        function generatePinkNoise(left, right, samples) {
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < samples; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                const pink = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                b6 = white * 0.115926;
                left[i] = pink * 0.5;
                right[i] = pink * 0.5 + (Math.random() * 2 - 1) * 0.01;
            }
        }

        function generateWhiteNoise(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                left[i] = (Math.random() * 2 - 1) * 0.15;
                right[i] = (Math.random() * 2 - 1) * 0.15;
            }
        }

        function generateBinaural(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // 40Hz binaural beat (good for focus)
                left[i] = Math.sin(t * 200 * Math.PI * 2) * 0.08;
                right[i] = Math.sin(t * 210 * Math.PI * 2) * 0.08;
            }
        }

        function generateDrone(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Rich harmonic drone based on A (55Hz)
                const fundamental = 55;

                // Fundamental and harmonics with slight detuning for warmth
                const d1 = Math.sin(t * fundamental * Math.PI * 2) * 0.08;
                const d2 = Math.sin(t * fundamental * 1.498 * Math.PI * 2) * 0.05; // Perfect 5th, slightly flat
                const d3 = Math.sin(t * fundamental * 2.003 * Math.PI * 2) * 0.04; // Octave, slightly sharp
                const d4 = Math.sin(t * fundamental * 3 * Math.PI * 2) * 0.025;
                const d5 = Math.sin(t * fundamental * 4 * Math.PI * 2) * 0.015;

                // Slow evolution/breathing
                const breath1 = Math.sin(t * 0.08 * Math.PI * 2) * 0.2 + 0.8;
                const breath2 = Math.sin(t * 0.13 * Math.PI * 2) * 0.15 + 0.85;

                // Subtle chorus effect via slight pitch wobble
                const wobble = Math.sin(t * 0.5 * Math.PI * 2) * 0.002;
                const d1wobbled = Math.sin(t * fundamental * (1 + wobble) * Math.PI * 2) * 0.03;

                // Soft noise bed for texture
                const texture = (Math.random() * 2 - 1) * 0.004;

                const signalL = (d1 + d2 + d3 + d4 + d5 + d1wobbled + texture) * breath1;
                const signalR = (d1 + d2 * 0.95 + d3 + d4 + d5 + d1wobbled * 0.9 + texture) * breath2;

                left[i] = signalL;
                right[i] = signalR;
            }
        }

        // ============ NEW NATURE SOUNDS ============

        function generateRainOnRoof(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                // Metallic pitter-patter
                if (Math.random() < 0.25) {
                    const dropLength = Math.floor(Math.random() * 200 + 50);
                    const amplitude = Math.random() * 0.04;
                    const pan = Math.random();
                    const freq = Math.random() * 3000 + 2000;
                    for (let j = 0; j < dropLength && i + j < samples; j++) {
                        const env = Math.exp(-j / (dropLength * 0.1));
                        const ring = Math.sin(j / 44100 * freq * Math.PI * 2) * env * amplitude * 0.3;
                        const noise = (Math.random() * 2 - 1) * amplitude * env;
                        left[i + j] += (noise + ring) * (1 - pan * 0.5);
                        right[i + j] += (noise + ring) * (0.5 + pan * 0.5);
                    }
                }
            }
        }

        function generateWindGrass(left, right, samples) {
            let windL = 0, windR = 0;
            for (let i = 0; i < samples; i++) {
                const mod = Math.sin(i / 44100 * 0.3) * 0.4 + 0.6;
                const rustle = Math.sin(i / 44100 * 8) * 0.15 + 0.85;
                windL += (Math.random() * 2 - 1) * 0.008 * mod;
                windR += (Math.random() * 2 - 1) * 0.008 * mod;
                windL *= 0.999;
                windR *= 0.999;
                // Higher frequency rustling
                const highRustle = (Math.random() * 2 - 1) * 0.015 * rustle * mod;
                left[i] = windL + highRustle;
                right[i] = windR + highRustle * 0.9;
            }
        }

        function generateWaterfall(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                // Heavy white noise with low-end boost
                const noise = (Math.random() * 2 - 1) * 0.2;
                left[i] = noise;
                right[i] = noise * 0.95 + (Math.random() * 2 - 1) * 0.02;
            }
            // Apply lowpass for rumble
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.4 + left[i-1] * 0.6;
                right[i] = right[i] * 0.4 + right[i-1] * 0.6;
            }
        }

        function generateRiver(left, right, samples) {
            let flowL = 0, flowR = 0;
            for (let i = 0; i < samples; i++) {
                const mod = Math.sin(i / 44100 * 0.2) * 0.2 + 0.8;
                flowL += (Math.random() * 2 - 1) * 0.015 * mod;
                flowR += (Math.random() * 2 - 1) * 0.015 * mod;
                flowL *= 0.998;
                flowR *= 0.998;
                // Add some splashing
                if (Math.random() < 0.0005) {
                    const splashLen = Math.floor(Math.random() * 2000 + 500);
                    for (let j = 0; j < splashLen && i + j < samples; j++) {
                        const env = Math.sin(j / splashLen * Math.PI) * 0.04;
                        left[i + j] += (Math.random() * 2 - 1) * env;
                        right[i + j] += (Math.random() * 2 - 1) * env;
                    }
                }
                left[i] += flowL;
                right[i] += flowR;
            }
        }

        function generateLake(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Very gentle lapping
                const wave = Math.sin(t * 0.15 * Math.PI * 2) * 0.3 + 0.4;
                const noise = (Math.random() * 2 - 1) * wave * 0.03;
                left[i] = noise;
                right[i] = noise * 0.98;
            }
        }

        function generateSeagulls(left, right, samples) {
            // Light ocean background
            for (let i = 0; i < samples; i++) {
                left[i] = (Math.random() * 2 - 1) * 0.01;
                right[i] = (Math.random() * 2 - 1) * 0.01;
            }
            // Seagull calls
            const numCalls = Math.floor(Math.random() * 4) + 2;
            for (let c = 0; c < numCalls; c++) {
                const startPos = Math.floor(Math.random() * (samples - 44100));
                const callLen = Math.floor(Math.random() * 15000 + 8000);
                const baseFreq = Math.random() * 500 + 800;
                const pan = Math.random();
                for (let i = 0; i < callLen && startPos + i < samples; i++) {
                    const t = i / callLen;
                    const env = Math.sin(t * Math.PI) * Math.exp(-t * 1.5);
                    const freqMod = 1 + Math.sin(t * Math.PI * 6) * 0.3 + t * 0.5;
                    const call = Math.sin(i / 44100 * baseFreq * freqMod * Math.PI * 2) * env * 0.06;
                    left[startPos + i] += call * (1 - pan);
                    right[startPos + i] += call * pan;
                }
            }
        }

        function generateOwls(left, right, samples) {
            // Night ambient
            for (let i = 0; i < samples; i++) {
                left[i] = (Math.random() * 2 - 1) * 0.003;
                right[i] = (Math.random() * 2 - 1) * 0.003;
            }
            // Owl hoots
            const numHoots = Math.floor(Math.random() * 3) + 1;
            for (let h = 0; h < numHoots; h++) {
                const startPos = Math.floor(Math.random() * (samples - 88200));
                const hootPattern = [0, 8820, 13230, 22050]; // "hoo hoo-hoo hoooo"
                const pan = Math.random() * 0.6 + 0.2;
                hootPattern.forEach((offset, idx) => {
                    const hootLen = idx === 3 ? 15000 : 6000;
                    const freq = 350 + Math.random() * 50;
                    for (let i = 0; i < hootLen && startPos + offset + i < samples; i++) {
                        const t = i / hootLen;
                        const env = Math.sin(t * Math.PI) * 0.08;
                        const hoot = Math.sin(i / 44100 * freq * Math.PI * 2) * env;
                        left[startPos + offset + i] += hoot * (1 - pan);
                        right[startPos + offset + i] += hoot * pan;
                    }
                });
            }
        }

        function generateFrogs(left, right, samples) {
            // Pond ambient
            for (let i = 0; i < samples; i++) {
                left[i] = (Math.random() * 2 - 1) * 0.005;
                right[i] = (Math.random() * 2 - 1) * 0.005;
            }
            // Frog croaks - multiple frogs
            for (let f = 0; f < 8; f++) {
                const frogFreq = Math.random() * 200 + 150;
                const frogRate = Math.random() * 3 + 2;
                const pan = Math.random();
                for (let i = 0; i < samples; i++) {
                    const t = i / 44100;
                    const pulse = Math.sin(t * frogRate * Math.PI * 2) > 0.7 ? 1 : 0;
                    const croak = Math.sin(t * frogFreq * Math.PI * 2) * pulse * 0.015;
                    const wobble = Math.sin(t * frogFreq * 2 * Math.PI * 2) * pulse * 0.008;
                    left[i] += (croak + wobble) * (1 - pan);
                    right[i] += (croak + wobble) * pan;
                }
            }
        }

        function generateCicadas(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Multiple cicada frequencies with pulsing
                const pulse1 = (Math.sin(t * 0.5 * Math.PI * 2) * 0.5 + 0.5);
                const pulse2 = (Math.sin(t * 0.7 * Math.PI * 2 + 1) * 0.5 + 0.5);
                const cicada1 = Math.sin(t * 5500 * Math.PI * 2) * 0.025 * pulse1;
                const cicada2 = Math.sin(t * 6200 * Math.PI * 2) * 0.02 * pulse2;
                const noise = (Math.random() * 2 - 1) * 0.01;
                left[i] = cicada1 + noise;
                right[i] = cicada2 + noise;
            }
        }

        function generateCampfire(left, right, samples) {
            // Similar to fireplace but more outdoor ambience
            let crackle = 0;
            for (let i = 0; i < samples; i++) {
                crackle += (Math.random() * 2 - 1) * 0.015;
                crackle *= 0.996;
                // More frequent pops for outdoor fire
                if (Math.random() < 0.001) {
                    const popLen = Math.floor(Math.random() * 600 + 150);
                    const intensity = Math.random() * 0.12 + 0.04;
                    for (let j = 0; j < popLen && i + j < samples; j++) {
                        const env = Math.exp(-j / (popLen * 0.12));
                        const pop = (Math.random() * 2 - 1) * env * intensity;
                        left[i + j] += pop;
                        right[i + j] += pop * 0.9;
                    }
                }
                left[i] += crackle;
                right[i] += crackle * 0.92;
            }
        }

        // ============ NEW INDOOR SOUNDS ============

        function generateAC(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Compressor hum
                const hum = Math.sin(t * 60 * Math.PI * 2) * 0.015;
                // Fan noise
                const noise = (Math.random() * 2 - 1) * 0.05;
                // Cycling on/off simulation
                const cycle = Math.sin(t * 0.02 * Math.PI * 2) * 0.1 + 0.9;
                left[i] = (hum + noise) * cycle;
                right[i] = (hum + noise * 0.98) * cycle;
            }
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.35 + left[i-1] * 0.65;
                right[i] = right[i] * 0.35 + right[i-1] * 0.65;
            }
        }

        function generateHeater(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Warm hum
                const hum = Math.sin(t * 50 * Math.PI * 2) * 0.02;
                const hum2 = Math.sin(t * 100 * Math.PI * 2) * 0.01;
                // Element hiss
                const hiss = (Math.random() * 2 - 1) * 0.02;
                left[i] = hum + hum2 + hiss;
                right[i] = hum + hum2 + hiss * 0.97;
            }
        }

        function generateFridge(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Compressor hum with harmonics
                const hum1 = Math.sin(t * 55 * Math.PI * 2) * 0.03;
                const hum2 = Math.sin(t * 110 * Math.PI * 2) * 0.015;
                const hum3 = Math.sin(t * 165 * Math.PI * 2) * 0.008;
                // Slight vibration noise
                const vibration = (Math.random() * 2 - 1) * 0.01;
                left[i] = hum1 + hum2 + hum3 + vibration;
                right[i] = (hum1 + hum2 + hum3 + vibration) * 0.98;
            }
        }

        function generateWasher(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Rotating drum sound
                const rotation = Math.sin(t * 2 * Math.PI * 2) * 0.3 + 0.7;
                // Motor hum
                const motor = Math.sin(t * 120 * Math.PI * 2) * 0.02;
                // Water sloshing
                const slosh = Math.sin(t * 1.5 * Math.PI * 2) * (Math.random() * 2 - 1) * 0.03;
                // Mechanical noise
                const mech = (Math.random() * 2 - 1) * 0.025 * rotation;
                left[i] = motor + slosh + mech;
                right[i] = motor + slosh * 0.9 + mech * 0.95;
            }
        }

        function generateDryer(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Tumbling rhythm
                const tumble = Math.sin(t * 1.2 * Math.PI * 2);
                const thump = tumble > 0.9 ? 0.05 : 0;
                // Motor drone
                const motor = Math.sin(t * 80 * Math.PI * 2) * 0.02;
                // Airflow
                const air = (Math.random() * 2 - 1) * 0.04;
                left[i] = motor + air + thump;
                right[i] = motor + air * 0.96 + thump;
            }
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.4 + left[i-1] * 0.6;
                right[i] = right[i] * 0.4 + right[i-1] * 0.6;
            }
        }

        function generateDishwasher(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Water spray
                const spray = (Math.random() * 2 - 1) * 0.06;
                // Pump hum
                const pump = Math.sin(t * 90 * Math.PI * 2) * 0.015;
                // Rotating spray arm
                const rotation = Math.sin(t * 0.8 * Math.PI * 2) * 0.2 + 0.8;
                left[i] = (spray * rotation + pump);
                right[i] = (spray * rotation * 0.95 + pump);
            }
        }

        function generateMouseClicks(left, right, samples) {
            let nextClick = Math.floor(Math.random() * 22050 + 11025);
            for (let i = 0; i < samples; i++) {
                if (i >= nextClick) {
                    const clickLen = Math.floor(Math.random() * 80 + 30);
                    const freq = Math.random() * 2000 + 4000;
                    for (let j = 0; j < clickLen && i + j < samples; j++) {
                        const env = Math.exp(-j / 15);
                        const click = Math.sin(j / 44100 * freq * Math.PI * 2) * env * 0.08;
                        left[i + j] += click;
                        right[i + j] += click * 0.95;
                    }
                    nextClick = i + Math.floor(Math.random() * 44100 + 11025);
                }
            }
        }

        function generatePencil(left, right, samples) {
            let nextStroke = 0;
            let isWriting = false;
            let strokeEnd = 0;
            for (let i = 0; i < samples; i++) {
                if (!isWriting && i >= nextStroke) {
                    isWriting = true;
                    strokeEnd = i + Math.floor(Math.random() * 44100 + 22050);
                }
                if (isWriting) {
                    const scratchIntensity = Math.random() * 0.04;
                    left[i] = (Math.random() * 2 - 1) * scratchIntensity;
                    right[i] = (Math.random() * 2 - 1) * scratchIntensity * 0.9;
                    if (i >= strokeEnd) {
                        isWriting = false;
                        nextStroke = i + Math.floor(Math.random() * 22050 + 4410);
                    }
                }
            }
        }

        function generateShower(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                // Spray noise
                const spray = (Math.random() * 2 - 1) * 0.12;
                // Water hitting surface
                const impact = (Math.random() * 2 - 1) * 0.05;
                left[i] = spray + impact;
                right[i] = spray * 0.97 + impact * 0.95;
            }
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.5 + left[i-1] * 0.5;
                right[i] = right[i] * 0.5 + right[i-1] * 0.5;
            }
        }

        function generateBathtub(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Running water
                const water = (Math.random() * 2 - 1) * 0.08;
                // Resonance of tub
                const resonance = Math.sin(t * 180 * Math.PI * 2) * 0.01;
                left[i] = water + resonance;
                right[i] = water * 0.96 + resonance;
            }
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.45 + left[i-1] * 0.55;
                right[i] = right[i] * 0.45 + right[i-1] * 0.55;
            }
        }

        function generateBoiling(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                // Bubbling
                if (Math.random() < 0.01) {
                    const bubbleLen = Math.floor(Math.random() * 800 + 200);
                    const freq = Math.random() * 1500 + 500;
                    const pan = Math.random();
                    for (let j = 0; j < bubbleLen && i + j < samples; j++) {
                        const env = Math.sin(j / bubbleLen * Math.PI);
                        const bubble = Math.sin(j / 44100 * freq * Math.PI * 2) * env * 0.04;
                        left[i + j] += bubble * (1 - pan);
                        right[i + j] += bubble * pan;
                    }
                }
                // Steam hiss
                const hiss = (Math.random() * 2 - 1) * 0.015;
                left[i] += hiss;
                right[i] += hiss * 0.97;
            }
        }

        function generateCatsPurr(left, right, samples) {
            const sampleRate = 44100;
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                // Purr is low frequency pulsing with characteristic vibration
                const purrFreq = 25 + Math.sin(t * 0.3) * 2; // Slight variation
                const purr = Math.sin(t * purrFreq * Math.PI * 2) * 0.04;
                const purr2 = Math.sin(t * purrFreq * 2 * Math.PI * 2) * 0.02;
                const purr3 = Math.sin(t * purrFreq * 3 * Math.PI * 2) * 0.01;
                // Breathing modulation - inhale/exhale cycle
                const breath = Math.sin(t * 0.35 * Math.PI * 2) * 0.35 + 0.65;
                // Soft rumble noise
                const noise = (Math.random() * 2 - 1) * 0.012;
                const signal = (purr + purr2 + purr3 + noise) * breath;
                left[i] = signal;
                right[i] = signal * 0.97;
            }
        }

        function generateHumming(left, right, samples) {
            const sampleRate = 44100;

            // Simple melodic humming - creates a gentle human presence
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Slow wandering melody
                const melodyPhase = t * 0.08;
                const baseNote = 180 + Math.sin(melodyPhase * Math.PI * 2) * 30;

                // Human voice formants (simplified)
                const f1 = baseNote; // Fundamental
                const f2 = baseNote * 2; // 2nd harmonic
                const f3 = baseNote * 3; // 3rd harmonic

                const voice = Math.sin(t * f1 * Math.PI * 2) * 0.035;
                const h2 = Math.sin(t * f2 * Math.PI * 2) * 0.015;
                const h3 = Math.sin(t * f3 * Math.PI * 2) * 0.008;

                // Vibrato
                const vibrato = Math.sin(t * 5 * Math.PI * 2) * 0.015;

                // Breathing pauses
                const breathCycle = t % 4;
                const breathEnv = breathCycle < 3.5 ? 1 : Math.cos((breathCycle - 3.5) / 0.5 * Math.PI / 2);

                // Add slight noise for air sound
                const breath = (Math.random() * 2 - 1) * 0.003;

                const signal = (voice + h2 + h3 + vibrato + breath) * breathEnv;
                left[i] = signal;
                right[i] = signal * 0.98;
            }
        }

        function generateBabyBreathing(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Baby breathing cycle - about 30-40 breaths per minute
                const breathRate = 0.55; // ~33 breaths per minute
                const breathPhase = (t * breathRate) % 1;

                // Inhale and exhale phases
                let breathSound = 0;
                if (breathPhase < 0.4) {
                    // Inhale - softer
                    const inhaleT = breathPhase / 0.4;
                    const inhaleEnv = Math.sin(inhaleT * Math.PI) * 0.015;
                    breathSound = (Math.random() * 2 - 1) * inhaleEnv;
                } else if (breathPhase < 0.85) {
                    // Exhale - slightly louder, with soft vocalization
                    const exhaleT = (breathPhase - 0.4) / 0.45;
                    const exhaleEnv = Math.sin(exhaleT * Math.PI) * 0.02;
                    breathSound = (Math.random() * 2 - 1) * exhaleEnv;
                    // Occasional soft coo/sigh
                    if (Math.sin(t * 0.1) > 0.9) {
                        const coo = Math.sin(t * 350 * Math.PI * 2) * exhaleEnv * 0.3;
                        breathSound += coo;
                    }
                }
                // Pause between breaths (0.85 to 1.0)

                // Very subtle movement sounds
                if (Math.random() < 0.0001) {
                    const rustleLen = Math.floor(Math.random() * 2000 + 500);
                    for (let j = 0; j < rustleLen && i + j < samples; j++) {
                        const env = Math.sin(j / rustleLen * Math.PI) * 0.008;
                        left[i + j] += (Math.random() * 2 - 1) * env;
                        right[i + j] += (Math.random() * 2 - 1) * env;
                    }
                }

                left[i] = breathSound;
                right[i] = breathSound * 0.97;
            }

            // Gentle lowpass for warmth
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.6 + left[i-1] * 0.4;
                right[i] = right[i] * 0.6 + right[i-1] * 0.4;
            }
        }

        // ============ NEW URBAN SOUNDS ============

        function generateLibrary(left, right, samples) {
            // Very quiet ambient
            for (let i = 0; i < samples; i++) {
                left[i] = (Math.random() * 2 - 1) * 0.003;
                right[i] = (Math.random() * 2 - 1) * 0.003;
            }
            // Occasional page turns and whispers
            for (let e = 0; e < 8; e++) {
                const pos = Math.floor(Math.random() * (samples - 22050));
                const len = Math.floor(Math.random() * 8000 + 4000);
                const pan = Math.random();
                for (let i = 0; i < len && pos + i < samples; i++) {
                    const env = Math.sin(i / len * Math.PI) * 0.02;
                    const sound = (Math.random() * 2 - 1) * env;
                    left[pos + i] += sound * (1 - pan);
                    right[pos + i] += sound * pan;
                }
            }
        }

        function generateOffice(left, right, samples) {
            // AC background
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                const ac = Math.sin(t * 60 * Math.PI * 2) * 0.008 + (Math.random() * 2 - 1) * 0.015;
                left[i] = ac;
                right[i] = ac * 0.98;
            }
            // Keyboard clicks, printer, phone rings
            for (let e = 0; e < 30; e++) {
                const pos = Math.floor(Math.random() * (samples - 2000));
                const type = Math.random();
                if (type < 0.7) { // Keyboard
                    const len = Math.floor(Math.random() * 100 + 50);
                    for (let i = 0; i < len && pos + i < samples; i++) {
                        const env = Math.exp(-i / 30);
                        left[pos + i] += (Math.random() * 2 - 1) * env * 0.02;
                        right[pos + i] += (Math.random() * 2 - 1) * env * 0.02;
                    }
                }
            }
        }

        function generateHighway(left, right, samples) {
            const sampleRate = 44100;

            // Constant tire drone - the "bed" of highway sound
            let droneL = 0, droneR = 0;
            for (let i = 0; i < samples; i++) {
                droneL += (Math.random() * 2 - 1) * 0.025;
                droneR += (Math.random() * 2 - 1) * 0.025;
                droneL *= 0.997;
                droneR *= 0.997;
                left[i] = droneL;
                right[i] = droneR;
            }

            // Frequent passing vehicles with speed variation
            const numVehicles = Math.floor(Math.random() * 12) + 8;
            for (let v = 0; v < numVehicles; v++) {
                const startPos = Math.floor(Math.random() * (samples - sampleRate * 2.5));
                const speed = 60 + Math.random() * 40; // 60-100 mph simulated
                const passLen = Math.floor(sampleRate * (3.5 - speed / 50)); // Faster = shorter pass
                const direction = Math.random() > 0.5 ? 1 : -1;
                const isTruck = Math.random() < 0.25;

                for (let i = 0; i < passLen && startPos + i < samples; i++) {
                    const t = i / passLen; // 0 to 1
                    const time = i / sampleRate;

                    // Doppler shift - more pronounced at higher speeds
                    const dopplerStrength = speed / 80;
                    const dopplerPosition = (t - 0.5) * 2; // -1 to 1
                    const dopplerFactor = 1 / (1 + dopplerPosition * 0.12 * dopplerStrength);

                    // Volume - inverse square falloff approximation
                    const distance = Math.abs(t - 0.5);
                    const volEnv = Math.pow(1 - distance * 1.8, 2) * (isTruck ? 0.07 : 0.05);

                    // Stereo panning
                    const pan = direction > 0 ? t : (1 - t);

                    // Tire noise - primary highway sound
                    const tireNoise = (Math.random() * 2 - 1) * volEnv;

                    // Engine tone (more prominent for trucks)
                    const baseFreq = isTruck ? 50 : 80;
                    const engineFreq = baseFreq * dopplerFactor * (speed / 70);
                    const engine = Math.sin(time * engineFreq * Math.PI * 2) * volEnv * (isTruck ? 0.6 : 0.3);

                    // Wind whoosh
                    const whoosh = (Math.random() * 2 - 1) * volEnv * 0.4 * dopplerFactor;

                    const combined = tireNoise + engine + whoosh;
                    left[startPos + i] += combined * (1 - pan * 0.8);
                    right[startPos + i] += combined * (0.2 + pan * 0.8);
                }
            }

            // Gentle lowpass
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.55 + left[i-1] * 0.45;
                right[i] = right[i] * 0.55 + right[i-1] * 0.45;
            }
        }

        function generateTrain(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Wheel clacking rhythm - classic "clickety-clack" pattern
                // Two clicks per rail joint, slight delay for second axle
                const jointInterval = 0.8; // Time between rail joints
                const jointPhase = (t % jointInterval) / jointInterval;

                // First wheel set
                const click1 = jointPhase < 0.05 ?
                    (Math.random() * 2 - 1) * Math.exp(-jointPhase * 40) * 0.04 : 0;
                // Second wheel set (slight delay)
                const click2Phase = ((t - 0.1) % jointInterval) / jointInterval;
                const click2 = click2Phase > 0 && click2Phase < 0.05 ?
                    (Math.random() * 2 - 1) * Math.exp(-click2Phase * 40) * 0.035 : 0;

                // Rail singing - continuous high-pitched harmonic
                const railSing = Math.sin(t * 800 * Math.PI * 2) * 0.003 *
                    (Math.sin(t * 0.2 * Math.PI * 2) * 0.3 + 0.7);

                // Engine/motor drone
                const motor = Math.sin(t * 40 * Math.PI * 2) * 0.02;
                const motor2 = Math.sin(t * 80 * Math.PI * 2) * 0.01;

                // Continuous rail noise
                const railNoise = (Math.random() * 2 - 1) * 0.03;

                // Subtle swaying motion (affects stereo)
                const sway = Math.sin(t * 0.3 * Math.PI * 2) * 0.1;

                // Occasional horn in distance
                let horn = 0;
                if (Math.sin(t * 0.02 * Math.PI * 2) > 0.98) {
                    const hornPhase = (t * 0.02) % 1;
                    horn = (Math.sin(t * 440 * Math.PI * 2) + Math.sin(t * 554 * Math.PI * 2) * 0.5) *
                        Math.exp(-hornPhase * 3) * 0.015;
                }

                const signal = click1 + click2 + railSing + motor + motor2 + railNoise + horn;
                left[i] = signal * (1 + sway);
                right[i] = signal * (1 - sway);
            }

            // Lowpass for that "inside the train" muffled feel
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.55 + left[i-1] * 0.45;
                right[i] = right[i] * 0.55 + right[i-1] * 0.45;
            }
        }

        function generateAirport(left, right, samples) {
            // PA echo ambience
            let murmur = 0;
            for (let i = 0; i < samples; i++) {
                murmur += (Math.random() * 2 - 1) * 0.006;
                murmur *= 0.999;
                left[i] = murmur;
                right[i] = murmur * 0.98;
            }
            // Announcements
            for (let a = 0; a < 2; a++) {
                const pos = Math.floor(Math.random() * (samples - 88200));
                for (let i = 0; i < 66150 && pos + i < samples; i++) {
                    const t = i / 66150;
                    const env = Math.sin(t * Math.PI) * 0.015;
                    const freq = 400 + Math.sin(t * 3) * 100;
                    const voice = Math.sin(i / 44100 * freq * Math.PI * 2) * env;
                    left[pos + i] += voice;
                    right[pos + i] += voice * 0.95;
                }
            }
        }

        function generateAirplane(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Jet engine drone - multiple harmonics
                const jet1 = Math.sin(t * 70 * Math.PI * 2) * 0.02;
                const jet2 = Math.sin(t * 100 * Math.PI * 2) * 0.015;
                const jet3 = Math.sin(t * 140 * Math.PI * 2) * 0.01;

                // Engine variation (slight RPM changes)
                const engineVar = Math.sin(t * 0.05 * Math.PI * 2) * 0.05 + 0.95;

                // Cabin pressurization hum
                const pressure = Math.sin(t * 200 * Math.PI * 2) * 0.005;

                // Air conditioning/ventilation
                const airflow = (Math.random() * 2 - 1) * 0.05;

                // Turbulence (occasional extra noise)
                const turbulence = Math.sin(t * 0.03 * Math.PI * 2) > 0.8 ?
                    (Math.random() * 2 - 1) * 0.02 : 0;

                // Very subtle wing flex creaks (rare)
                let creak = 0;
                if (Math.random() < 0.00003) {
                    for (let j = 0; j < 1000 && i + j < samples; j++) {
                        creak = Math.sin(j / sampleRate * 150 * Math.PI * 2) *
                            Math.exp(-j / 200) * 0.01;
                        left[i + j] += creak;
                        right[i + j] += creak * 0.8;
                    }
                }

                // Distant seatbelt chime (very rare)
                if (Math.random() < 0.00002) {
                    for (let j = 0; j < 4000 && i + j < samples; j++) {
                        const chime = Math.sin(j / sampleRate * 1000 * Math.PI * 2) *
                            Math.exp(-j / 600) * 0.015;
                        left[i + j] += chime * 0.7;
                        right[i + j] += chime * 0.7;
                    }
                }

                const signal = (jet1 + jet2 + jet3) * engineVar + pressure + airflow + turbulence;
                left[i] = signal;
                right[i] = signal * 0.97;
            }

            // Heavy lowpass for that pressurized cabin feel
            for (let pass = 0; pass < 2; pass++) {
                for (let i = 1; i < samples; i++) {
                    left[i] = left[i] * 0.35 + left[i-1] * 0.65;
                    right[i] = right[i] * 0.35 + right[i-1] * 0.65;
                }
            }
        }

        function generateBar(left, right, samples) {
            // Louder chatter
            let chatter = 0;
            for (let i = 0; i < samples; i++) {
                chatter += (Math.random() * 2 - 1) * 0.012;
                chatter *= 0.998;
                left[i] = chatter;
                right[i] = chatter * 0.97;
            }
            // Glass clinks
            for (let c = 0; c < 25; c++) {
                const pos = Math.floor(Math.random() * (samples - 3000));
                const freq = Math.random() * 2000 + 3000;
                const pan = Math.random();
                for (let i = 0; i < 1500 && pos + i < samples; i++) {
                    const env = Math.exp(-i / 150);
                    const clink = Math.sin(i / 44100 * freq * Math.PI * 2) * env * 0.04;
                    left[pos + i] += clink * (1 - pan);
                    right[pos + i] += clink * pan;
                }
            }
        }

        function generateMall(left, right, samples) {
            // Echoey ambience
            let ambient = 0;
            for (let i = 0; i < samples; i++) {
                ambient += (Math.random() * 2 - 1) * 0.008;
                ambient *= 0.9985;
                left[i] = ambient;
                right[i] = ambient * 0.96;
            }
            // Music snippets
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                const music = Math.sin(t * 220 * Math.PI * 2) * 0.005 + Math.sin(t * 330 * Math.PI * 2) * 0.003;
                left[i] += music;
                right[i] += music;
            }
        }

        function generatePlayground(left, right, samples) {
            // Outdoor ambient
            for (let i = 0; i < samples; i++) {
                left[i] = (Math.random() * 2 - 1) * 0.01;
                right[i] = (Math.random() * 2 - 1) * 0.01;
            }
            // Children sounds - high pitched
            for (let c = 0; c < 15; c++) {
                const pos = Math.floor(Math.random() * (samples - 22050));
                const len = Math.floor(Math.random() * 11025 + 4410);
                const freq = Math.random() * 500 + 600;
                const pan = Math.random();
                for (let i = 0; i < len && pos + i < samples; i++) {
                    const t = i / len;
                    const env = Math.sin(t * Math.PI) * 0.025;
                    const voice = Math.sin(i / 44100 * freq * (1 + Math.sin(t * 5) * 0.2) * Math.PI * 2) * env;
                    left[pos + i] += voice * (1 - pan);
                    right[pos + i] += voice * pan;
                }
            }
        }

        function generateConstruction(left, right, samples) {
            // Base noise
            for (let i = 0; i < samples; i++) {
                left[i] = (Math.random() * 2 - 1) * 0.03;
                right[i] = (Math.random() * 2 - 1) * 0.03;
            }
            // Hammering
            for (let h = 0; h < 20; h++) {
                const pos = Math.floor(Math.random() * (samples - 11025));
                for (let i = 0; i < 300 && pos + i < samples; i++) {
                    const env = Math.exp(-i / 30);
                    left[pos + i] += (Math.random() * 2 - 1) * env * 0.15;
                    right[pos + i] += (Math.random() * 2 - 1) * env * 0.15;
                }
            }
            // Drilling
            const drillPos = Math.floor(Math.random() * (samples / 2));
            const drillLen = Math.floor(Math.random() * 88200 + 44100);
            for (let i = 0; i < drillLen && drillPos + i < samples; i++) {
                const t = i / 44100;
                const drill = Math.sin(t * 2500 * Math.PI * 2) * 0.04;
                left[drillPos + i] += drill;
                right[drillPos + i] += drill * 0.95;
            }
        }

        function generateCityNight(left, right, samples) {
            const sampleRate = 44100;

            // Quiet ambient hum of the city
            let ambL = 0, ambR = 0;
            for (let i = 0; i < samples; i++) {
                ambL += (Math.random() * 2 - 1) * 0.005;
                ambR += (Math.random() * 2 - 1) * 0.005;
                ambL *= 0.998;
                ambR *= 0.998;
                left[i] = ambL;
                right[i] = ambR;
            }

            // Occasional distant car pass
            const numCars = Math.floor(Math.random() * 3) + 1;
            for (let c = 0; c < numCars; c++) {
                const startPos = Math.floor(Math.random() * (samples - sampleRate * 3));
                const passLen = sampleRate * 2;
                for (let i = 0; i < passLen && startPos + i < samples; i++) {
                    const t = i / passLen;
                    const vol = Math.sin(t * Math.PI) * 0.02;
                    const pan = t;
                    const engine = (Math.random() * 2 - 1) * vol;
                    left[startPos + i] += engine * (1 - pan * 0.6);
                    right[startPos + i] += engine * (0.4 + pan * 0.6);
                }
            }

            // Distant siren (maybe)
            if (Math.random() < 0.4) {
                const sirenPos = Math.floor(Math.random() * (samples - sampleRate * 2));
                for (let i = 0; i < sampleRate * 1.5 && sirenPos + i < samples; i++) {
                    const t = i / sampleRate;
                    const freq = 600 + Math.sin(t * 2.5) * 200;
                    const env = 0.012 * (1 - Math.abs(t / 1.5 - 0.5) * 1.5);
                    const siren = Math.sin(t * freq * Math.PI * 2) * env;
                    left[sirenPos + i] += siren * 0.5;
                    right[sirenPos + i] += siren * 0.7;
                }
            }

            // Very distant dog bark
            if (Math.random() < 0.3) {
                const barkPos = Math.floor(Math.random() * (samples - sampleRate));
                for (let b = 0; b < 3; b++) {
                    const pos = barkPos + b * Math.floor(sampleRate * 0.4);
                    const barkLen = Math.floor(sampleRate * 0.15);
                    for (let i = 0; i < barkLen && pos + i < samples; i++) {
                        const t = i / barkLen;
                        const env = Math.sin(t * Math.PI) * Math.exp(-t * 2) * 0.015;
                        const bark = Math.sin(i / sampleRate * 400 * Math.PI * 2) * env;
                        left[pos + i] += bark * 0.4;
                        right[pos + i] += bark * 0.6;
                    }
                }
            }
        }

        function generateCrowdMurmur(left, right, samples) {
            const sampleRate = 44100;

            // Base crowd murmur - layered filtered noise simulating many voices
            let murmurL = 0, murmurR = 0;
            let murmurL2 = 0, murmurR2 = 0;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Multiple layers of "voice-like" noise
                murmurL += (Math.random() * 2 - 1) * 0.015;
                murmurR += (Math.random() * 2 - 1) * 0.015;
                murmurL *= 0.997;
                murmurR *= 0.997;

                // Second layer with different filtering
                murmurL2 += (Math.random() * 2 - 1) * 0.01;
                murmurR2 += (Math.random() * 2 - 1) * 0.01;
                murmurL2 *= 0.994;
                murmurR2 *= 0.994;

                // Add formant-like resonances for voice character
                const formant1 = Math.sin(t * 350 * Math.PI * 2) * (Math.random() * 0.003);
                const formant2 = Math.sin(t * 700 * Math.PI * 2) * (Math.random() * 0.002);

                // Volume swells like conversation dynamics
                const swell = Math.sin(t * 0.3) * 0.15 + Math.sin(t * 0.7) * 0.1 + 0.75;

                left[i] = (murmurL + murmurL2 + formant1 + formant2) * swell;
                right[i] = (murmurR + murmurR2 + formant1 * 0.8 + formant2 * 1.1) * swell;
            }

            // Occasional distinct laugh
            for (let l = 0; l < 3; l++) {
                const laughPos = Math.floor(Math.random() * (samples - sampleRate));
                const laughLen = Math.floor(sampleRate * (0.3 + Math.random() * 0.4));
                const pan = Math.random();
                const pitch = 200 + Math.random() * 150;

                for (let i = 0; i < laughLen && laughPos + i < samples; i++) {
                    const t = i / laughLen;
                    // Staccato bursts for "ha ha ha"
                    const burstPhase = (i / sampleRate * 8) % 1;
                    const burst = burstPhase < 0.4 ? Math.sin(burstPhase / 0.4 * Math.PI) : 0;
                    const env = Math.sin(t * Math.PI) * burst * 0.025;
                    const sound = Math.sin(i / sampleRate * pitch * Math.PI * 2) * env;
                    left[laughPos + i] += sound * (1 - pan);
                    right[laughPos + i] += sound * pan;
                }
            }
        }

        function generateDistantParty(left, right, samples) {
            const sampleRate = 44100;

            // Muffled bass thump - like hearing music through walls
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Bass kick pattern (4/4 time, ~120 BPM)
                const bpm = 120;
                const beatPhase = (t * bpm / 60) % 1;
                const kick = beatPhase < 0.1 ? Math.sin(beatPhase * 10 * Math.PI) * Math.exp(-beatPhase * 15) : 0;
                const bass = Math.sin(t * 55 * Math.PI * 2) * kick * 0.08;

                // Muffled crowd/music noise
                const muffle = (Math.random() * 2 - 1) * 0.02;

                left[i] = bass + muffle;
                right[i] = bass * 0.95 + muffle * 0.97;
            }

            // Heavy lowpass for "through walls" effect
            for (let pass = 0; pass < 3; pass++) {
                for (let i = 1; i < samples; i++) {
                    left[i] = left[i] * 0.25 + left[i-1] * 0.75;
                    right[i] = right[i] * 0.25 + right[i-1] * 0.75;
                }
            }

            // Occasional muffled cheer/shout
            for (let c = 0; c < 2; c++) {
                const cheerPos = Math.floor(Math.random() * (samples - sampleRate * 2));
                const cheerLen = Math.floor(sampleRate * (0.5 + Math.random() * 0.5));
                for (let i = 0; i < cheerLen && cheerPos + i < samples; i++) {
                    const t = i / cheerLen;
                    const env = Math.sin(t * Math.PI) * 0.015;
                    const noise = (Math.random() * 2 - 1) * env;
                    left[cheerPos + i] += noise;
                    right[cheerPos + i] += noise * 0.9;
                }
            }
        }

        function generateStreetBusker(left, right, samples) {
            const sampleRate = 44100;

            // Distant acoustic guitar strumming
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Simple chord progression timing
                const chordDuration = 2; // seconds per chord
                const chordPhase = t % chordDuration;
                const strumPhase = chordPhase % 0.5; // Strum every half second

                // Chord root notes (simplified progression)
                const chordIndex = Math.floor(t / chordDuration) % 4;
                const roots = [110, 146.83, 130.81, 98]; // Am, D, C, G bass notes
                const root = roots[chordIndex];

                // Strum envelope
                const strumEnv = strumPhase < 0.1 ?
                    Math.exp(-strumPhase * 20) * 0.03 :
                    Math.exp(-(strumPhase - 0.1) * 3) * 0.015;

                // Guitar chord (root + 5th + octave + harmonics)
                let guitar = 0;
                guitar += Math.sin(t * root * Math.PI * 2) * strumEnv;
                guitar += Math.sin(t * root * 1.5 * Math.PI * 2) * strumEnv * 0.7;
                guitar += Math.sin(t * root * 2 * Math.PI * 2) * strumEnv * 0.5;
                guitar += Math.sin(t * root * 3 * Math.PI * 2) * strumEnv * 0.3;

                // String noise
                guitar += (Math.random() * 2 - 1) * strumEnv * 0.3;

                // Street ambience
                const amb = (Math.random() * 2 - 1) * 0.008;

                left[i] = guitar + amb;
                right[i] = guitar * 0.95 + amb * 1.02;
            }

            // Occasional coin drop in hat
            for (let c = 0; c < 2; c++) {
                const coinPos = Math.floor(Math.random() * (samples - sampleRate));
                const coinLen = Math.floor(sampleRate * 0.2);
                const coinFreq = 3000 + Math.random() * 1000;
                for (let i = 0; i < coinLen && coinPos + i < samples; i++) {
                    const env = Math.exp(-i / (coinLen * 0.1)) * 0.02;
                    const coin = Math.sin(i / sampleRate * coinFreq * Math.PI * 2) * env;
                    left[coinPos + i] += coin * 0.6;
                    right[coinPos + i] += coin * 0.4;
                }
            }
        }

        // ============ MECHANICAL SOUNDS ============

        function generateEngineIdle(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Realistic 4-cylinder idle at ~800 RPM
                const rpm = 800 + Math.sin(t * 0.3) * 20; // Slight RPM variation
                const firingFreq = rpm / 60 * 2; // 4-stroke, 4-cylinder = 2 power strokes per revolution

                // Individual cylinder firings
                const firing1 = Math.sin(t * firingFreq * Math.PI * 2);
                const firing2 = Math.sin(t * firingFreq * Math.PI * 2 + Math.PI / 2);
                const firing3 = Math.sin(t * firingFreq * Math.PI * 2 + Math.PI);
                const firing4 = Math.sin(t * firingFreq * Math.PI * 2 + Math.PI * 1.5);

                // Create combustion "pulses"
                const pulse1 = firing1 > 0.7 ? (firing1 - 0.7) * 3 : 0;
                const pulse2 = firing2 > 0.7 ? (firing2 - 0.7) * 3 : 0;
                const pulse3 = firing3 > 0.7 ? (firing3 - 0.7) * 3 : 0;
                const pulse4 = firing4 > 0.7 ? (firing4 - 0.7) * 3 : 0;

                const combustion = (pulse1 + pulse2 + pulse3 + pulse4) * 0.015;

                // Low-end rumble
                const rumble = Math.sin(t * 35 * Math.PI * 2) * 0.025;
                const rumble2 = Math.sin(t * 70 * Math.PI * 2) * 0.012;

                // Valve train noise
                const valves = (Math.random() * 2 - 1) * 0.008;

                // Occasional idle lope variation
                const lope = Math.sin(t * 0.5 * Math.PI * 2) * 0.1 + 0.9;

                const signal = (combustion + rumble + rumble2 + valves) * lope;
                left[i] = signal;
                right[i] = signal * 0.97;
            }

            // Gentle lowpass
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.5 + left[i-1] * 0.5;
                right[i] = right[i] * 0.5 + right[i-1] * 0.5;
            }
        }

        function generateShipEngine(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Deep marine diesel throb - very low frequency
                const throb1 = Math.sin(t * 12 * Math.PI * 2) * 0.05;
                const throb2 = Math.sin(t * 24 * Math.PI * 2) * 0.03;
                const throb3 = Math.sin(t * 36 * Math.PI * 2) * 0.015;

                // Propeller shaft rotation
                const shaft = Math.sin(t * 3 * Math.PI * 2) * 0.02;

                // Hull vibration
                const hull = (Math.random() * 2 - 1) * 0.02;

                // Periodic load variations
                const load = Math.sin(t * 0.1 * Math.PI * 2) * 0.15 + 0.85;

                // Occasional bilge pump (very subtle)
                let pump = 0;
                if (Math.sin(t * 0.02 * Math.PI * 2) > 0.95) {
                    pump = Math.sin(t * 200 * Math.PI * 2) * 0.008;
                }

                const signal = (throb1 + throb2 + throb3 + shaft + hull + pump) * load;
                left[i] = signal;
                right[i] = signal * 0.95;
            }

            // Heavy lowpass for that through-the-hull feel
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.3 + left[i-1] * 0.7;
                right[i] = right[i] * 0.3 + right[i-1] * 0.7;
            }
        }

        function generateGenerator(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Generator at 3600 RPM (60Hz output)
                const baseFreq = 60;

                // Main electrical hum
                const hum1 = Math.sin(t * baseFreq * Math.PI * 2) * 0.03;
                const hum2 = Math.sin(t * baseFreq * 2 * Math.PI * 2) * 0.02;
                const hum3 = Math.sin(t * baseFreq * 3 * Math.PI * 2) * 0.01;

                // Engine mechanical noise
                const engine = Math.sin(t * 30 * Math.PI * 2) * 0.02;

                // Cooling fan
                const fan = (Math.random() * 2 - 1) * 0.02;

                // Load fluctuation
                const loadVar = Math.sin(t * 0.15 * Math.PI * 2) * 0.08 + 0.92;

                // Fuel pump rhythm
                const fuelPump = Math.sin(t * 5 * Math.PI * 2) > 0.9 ? 0.005 : 0;

                const signal = (hum1 + hum2 + hum3 + engine + fan + fuelPump) * loadVar;
                left[i] = signal;
                right[i] = signal * 0.97;
            }
        }

        function generateMachinery(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Multiple machines with different rhythms (factory floor)
                // Press machine - slow, heavy
                const pressPhase = (t * 0.8) % 1;
                const press = pressPhase < 0.1 ? Math.sin(pressPhase * 10 * Math.PI) * 0.04 : 0;

                // Conveyor belt - continuous
                const conveyor = Math.sin(t * 3 * Math.PI * 2) * 0.01;

                // Hydraulic pump - pulsing
                const hydraulic = Math.sin(t * 5 * Math.PI * 2) > 0.7 ?
                    Math.sin(t * 150 * Math.PI * 2) * 0.015 : 0;

                // Spinning motor
                const motor = Math.sin(t * 80 * Math.PI * 2) * 0.015;
                const motor2 = Math.sin(t * 120 * Math.PI * 2) * 0.008;

                // General mechanical noise
                const noise = (Math.random() * 2 - 1) * 0.02;

                // Impact wrench occasionally
                let impact = 0;
                if (Math.random() < 0.0003) {
                    const impactLen = Math.floor(Math.random() * 4000 + 2000);
                    for (let j = 0; j < impactLen && i + j < samples; j++) {
                        const burstPhase = (j / sampleRate * 20) % 1;
                        const burst = burstPhase < 0.3 ? (Math.random() * 2 - 1) * 0.05 : 0;
                        left[i + j] += burst;
                        right[i + j] += burst * 0.9;
                    }
                }

                left[i] = press + conveyor + hydraulic + motor + motor2 + noise;
                right[i] = press * 0.95 + conveyor + hydraulic * 0.9 + motor + motor2 + noise * 0.97;
            }
        }

        function generateServerRoom(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Many fans
                const fans = Math.sin(t * 80 * Math.PI * 2) * 0.01 +
                            Math.sin(t * 95 * Math.PI * 2) * 0.01 +
                            Math.sin(t * 110 * Math.PI * 2) * 0.008;
                // Airflow
                const air = (Math.random() * 2 - 1) * 0.05;
                left[i] = fans + air;
                right[i] = fans + air * 0.98;
            }
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.35 + left[i-1] * 0.65;
                right[i] = right[i] * 0.35 + right[i-1] * 0.65;
            }
        }

        function generateHardDrive(left, right, samples) {
            // Spin noise
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                const spin = Math.sin(t * 120 * Math.PI * 2) * 0.008;
                left[i] = spin + (Math.random() * 2 - 1) * 0.005;
                right[i] = spin + (Math.random() * 2 - 1) * 0.005;
            }
            // Head seeks
            for (let s = 0; s < 40; s++) {
                const pos = Math.floor(Math.random() * (samples - 2000));
                const len = Math.floor(Math.random() * 500 + 100);
                for (let i = 0; i < len && pos + i < samples; i++) {
                    const env = Math.exp(-i / 50);
                    const click = (Math.random() * 2 - 1) * env * 0.03;
                    left[pos + i] += click;
                    right[pos + i] += click;
                }
            }
        }

        function generatePrinter(left, right, samples) {
            // Printing phases
            let printing = false;
            let printStart = Math.floor(Math.random() * 44100);
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                if (!printing && i >= printStart) {
                    printing = true;
                }
                if (printing) {
                    // Carriage movement
                    const carriage = Math.sin(t * 8 * Math.PI * 2) > 0 ? 0.03 : 0.01;
                    const motor = Math.sin(t * 200 * Math.PI * 2) * 0.01;
                    const mech = (Math.random() * 2 - 1) * carriage;
                    left[i] = motor + mech;
                    right[i] = motor + mech * 0.95;
                }
            }
        }

        function generateVentilation(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                // Constant airflow
                const air = (Math.random() * 2 - 1) * 0.06;
                // Duct resonance
                const t = i / 44100;
                const resonance = Math.sin(t * 65 * Math.PI * 2) * 0.01;
                left[i] = air + resonance;
                right[i] = air * 0.97 + resonance;
            }
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.4 + left[i-1] * 0.6;
                right[i] = right[i] * 0.4 + right[i-1] * 0.6;
            }
        }

        function generateElectricHum(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // 60Hz mains hum with harmonics
                const h1 = Math.sin(t * 60 * Math.PI * 2) * 0.05;
                const h2 = Math.sin(t * 120 * Math.PI * 2) * 0.025;
                const h3 = Math.sin(t * 180 * Math.PI * 2) * 0.015;
                const h4 = Math.sin(t * 240 * Math.PI * 2) * 0.008;
                left[i] = h1 + h2 + h3 + h4;
                right[i] = (h1 + h2 + h3 + h4) * 0.98;
            }
        }

        function generateTransformer(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Core vibration
                const core = Math.sin(t * 100 * Math.PI * 2) * 0.04;
                const core2 = Math.sin(t * 200 * Math.PI * 2) * 0.02;
                // Coil noise
                const coil = (Math.random() * 2 - 1) * 0.01;
                left[i] = core + core2 + coil;
                right[i] = core + core2 + coil * 0.97;
            }
        }

        // ============ SCI-FI SOUNDS ============

        function generateSpaceship(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Multi-layered engine drone with slight instability
                const engineWobble = 1 + Math.sin(t * 0.2) * 0.02;
                const engine1 = Math.sin(t * 35 * engineWobble * Math.PI * 2) * 0.035;
                const engine2 = Math.sin(t * 70 * engineWobble * Math.PI * 2) * 0.02;
                const engine3 = Math.sin(t * 140 * Math.PI * 2) * 0.01;

                // Life support ventilation
                const ventNoise = (Math.random() * 2 - 1) * 0.025;
                const ventTone = Math.sin(t * 180 * Math.PI * 2) * 0.008;

                // Distant reactor hum
                const reactor = Math.sin(t * 25 * Math.PI * 2) * 0.03 * (Math.sin(t * 0.1) * 0.1 + 0.9);

                // Occasional panel beep
                let beep = 0;
                if (Math.sin(t * 0.15 * Math.PI * 2) > 0.98) {
                    beep = Math.sin(t * 880 * Math.PI * 2) * 0.015 * Math.exp(-((t * 0.15) % 1) * 10);
                }

                // Hull creaks (very occasional)
                let creak = 0;
                if (Math.random() < 0.00005) {
                    const creakLen = Math.floor(Math.random() * 3000 + 1000);
                    const creakFreq = Math.random() * 100 + 50;
                    for (let j = 0; j < creakLen && i + j < samples; j++) {
                        const env = Math.sin(j / creakLen * Math.PI) * 0.02;
                        creak = Math.sin(j / sampleRate * creakFreq * (1 + j / creakLen * 0.5) * Math.PI * 2) * env;
                        left[i + j] += creak;
                        right[i + j] += creak * 0.7;
                    }
                }

                left[i] = engine1 + engine2 + engine3 + ventNoise + ventTone + reactor + beep;
                right[i] = engine1 * 0.98 + engine2 + engine3 + ventNoise * 0.95 + ventTone + reactor * 1.02 + beep;
            }

            // Gentle lowpass for that enclosed feeling
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.4 + left[i-1] * 0.6;
                right[i] = right[i] * 0.4 + right[i-1] * 0.6;
            }
        }

        function generateWarpDrive(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Core warp frequency sweep - creates sense of speed/dimension
                const warpPhase = t * 0.3;
                const coreFreq = 150 + Math.sin(warpPhase * Math.PI * 2) * 100 + Math.sin(warpPhase * 3.7 * Math.PI * 2) * 50;
                const core = Math.sin(t * coreFreq * Math.PI * 2) * 0.03;

                // Subspace harmonics - ethereal overtones
                const harmonic1 = Math.sin(t * (coreFreq * 1.5) * Math.PI * 2) * 0.015;
                const harmonic2 = Math.sin(t * (coreFreq * 2.3) * Math.PI * 2) * 0.01;

                // Deep rumble - feels like reality bending
                const rumble = Math.sin(t * 20 * Math.PI * 2) * 0.04;
                const rumble2 = Math.sin(t * 15 * Math.PI * 2) * 0.025;

                // Pulsing intensity
                const pulse = Math.sin(t * 1.5 * Math.PI * 2) * 0.2 + 0.8;

                // Spatial distortion noise
                const distort = (Math.random() * 2 - 1) * 0.02 * pulse;

                // Occasional "fold" sounds - like space compressing
                let fold = 0;
                if (Math.random() < 0.0002) {
                    const foldLen = Math.floor(sampleRate * 0.5);
                    for (let j = 0; j < foldLen && i + j < samples; j++) {
                        const fT = j / foldLen;
                        const env = Math.sin(fT * Math.PI) * 0.04;
                        const sweep = Math.sin(j / sampleRate * (800 - fT * 600) * Math.PI * 2) * env;
                        left[i + j] += sweep;
                        right[i + j] += sweep * 0.8;
                    }
                }

                const signal = (core + harmonic1 + harmonic2 + rumble + rumble2 + distort) * pulse;
                left[i] = signal;
                right[i] = signal * 0.97 + (core * 0.05); // Slight stereo separation
            }
        }

        function generateAlienPlanet(left, right, samples) {
            const sampleRate = 44100;

            // Strange atmospheric wind
            let windL = 0, windR = 0;
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                windL += (Math.random() * 2 - 1) * 0.008;
                windR += (Math.random() * 2 - 1) * 0.008;
                windL *= 0.998;
                windR *= 0.998;

                // Eerie atmospheric tones - non-earthly harmonics
                const atmo1 = Math.sin(t * 137 * Math.PI * 2) * Math.sin(t * 0.25 * Math.PI * 2) * 0.018;
                const atmo2 = Math.sin(t * 211 * Math.PI * 2) * Math.sin(t * 0.18 * Math.PI * 2) * 0.012;
                const atmo3 = Math.sin(t * 89 * Math.PI * 2) * Math.sin(t * 0.4 * Math.PI * 2) * 0.015;

                // Distant geological rumbles
                const geo = Math.sin(t * 18 * Math.PI * 2) * Math.sin(t * 0.08 * Math.PI * 2) * 0.025;

                left[i] = windL + atmo1 + atmo3 + geo;
                right[i] = windR + atmo2 + atmo3 * 0.8 + geo;
            }

            // Alien creature calls - strange, otherworldly
            const numCalls = Math.floor(Math.random() * 4) + 3;
            for (let a = 0; a < numCalls; a++) {
                const pos = Math.floor(Math.random() * (samples - sampleRate * 2));
                const callLen = Math.floor(sampleRate * (0.5 + Math.random() * 1.5));
                const baseFreq = Math.random() * 400 + 80;
                const pan = Math.random();
                const callType = Math.floor(Math.random() * 3);

                for (let i = 0; i < callLen && pos + i < samples; i++) {
                    const t = i / callLen;
                    let sound = 0;

                    if (callType === 0) {
                        // Warbling call
                        const env = Math.sin(t * Math.PI) * 0.03;
                        const warp = 1 + Math.sin(t * 12 * Math.PI * 2) * 0.3;
                        sound = Math.sin(i / sampleRate * baseFreq * warp * Math.PI * 2) * env;
                    } else if (callType === 1) {
                        // Descending howl
                        const env = Math.sin(t * Math.PI) * Math.exp(-t * 0.5) * 0.035;
                        const freq = baseFreq * (2 - t * 1.5);
                        sound = Math.sin(i / sampleRate * freq * Math.PI * 2) * env;
                    } else {
                        // Clicking/chirping
                        const env = (t < 0.5 ? t * 2 : (1 - t) * 2) * 0.025;
                        const clicks = Math.sin(i / sampleRate * 15 * Math.PI * 2) > 0.7 ? 1 : 0.3;
                        sound = Math.sin(i / sampleRate * baseFreq * 3 * Math.PI * 2) * env * clicks;
                    }

                    left[pos + i] += sound * (1 - pan);
                    right[pos + i] += sound * pan;
                }
            }
        }

        function generateSpaceStation(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Multiple system hums at different frequencies
                const sys1 = Math.sin(t * 50 * Math.PI * 2) * 0.012;
                const sys2 = Math.sin(t * 75 * Math.PI * 2) * 0.008;
                const sys3 = Math.sin(t * 100 * Math.PI * 2) * 0.006;
                const sys4 = Math.sin(t * 120 * Math.PI * 2) * 0.005;

                // Life support cycling
                const lifeCycle = Math.sin(t * 0.05 * Math.PI * 2) * 0.15 + 0.85;
                const lifeSupport = (Math.random() * 2 - 1) * 0.02 * lifeCycle;

                // Gravity generator hum
                const gravity = Math.sin(t * 30 * Math.PI * 2) * 0.015;

                // Occasional computer chirps
                let chirp = 0;
                if (Math.sin(t * 0.12 * Math.PI * 2) > 0.97) {
                    const chirpPhase = (t * 0.12) % 1;
                    chirp = Math.sin(t * 1200 * Math.PI * 2) * Math.exp(-chirpPhase * 15) * 0.012;
                }
                if (Math.sin(t * 0.08 * Math.PI * 2 + 1) > 0.98) {
                    const chirpPhase = (t * 0.08) % 1;
                    chirp += Math.sin(t * 800 * Math.PI * 2) * Math.exp(-chirpPhase * 12) * 0.01;
                }

                // Distant footsteps (very subtle)
                let footstep = 0;
                if (Math.random() < 0.00008) {
                    for (let j = 0; j < 200 && i + j < samples; j++) {
                        footstep = (Math.random() * 2 - 1) * Math.exp(-j / 30) * 0.015;
                        left[i + j] += footstep * 0.3;
                        right[i + j] += footstep * 0.7;
                    }
                }

                left[i] = sys1 + sys2 + sys3 + sys4 + lifeSupport + gravity + chirp;
                right[i] = sys1 * 0.95 + sys2 + sys3 + sys4 * 1.05 + lifeSupport * 0.97 + gravity + chirp;
            }

            // Subtle reverb simulation
            for (let i = 1; i < samples; i++) {
                left[i] = left[i] * 0.6 + left[i-1] * 0.4;
                right[i] = right[i] * 0.6 + right[i-1] * 0.4;
            }
        }

        function generateUnderwaterBase(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Deep pressure sounds - hull under stress
                const pressure = Math.sin(t * 20 * Math.PI * 2) * 0.025;
                const pressure2 = Math.sin(t * 35 * Math.PI * 2) * 0.015;

                // Water movement against hull
                let waterL = 0, waterR = 0;
                waterL += (Math.random() * 2 - 1) * 0.015;
                waterR += (Math.random() * 2 - 1) * 0.015;

                // Periodic bubble streams
                let bubbles = 0;
                const bubblePhase = (t * 0.3) % 1;
                if (bubblePhase < 0.2) {
                    const freq = 600 + Math.random() * 400;
                    bubbles = Math.sin(t * freq * Math.PI * 2) * Math.sin(bubblePhase / 0.2 * Math.PI) * 0.015;
                }

                // Sonar ping (periodic)
                let sonar = 0;
                const sonarPhase = (t * 0.08) % 1;
                if (sonarPhase < 0.05) {
                    sonar = Math.sin(t * 1800 * Math.PI * 2) * Math.exp(-sonarPhase * 40) * 0.025;
                }

                // Distant whale-like sounds (very deep)
                let whale = 0;
                if (Math.sin(t * 0.03 * Math.PI * 2) > 0.95) {
                    const whalePhase = (t * 0.03) % 1;
                    whale = Math.sin(t * (50 + Math.sin(whalePhase * Math.PI * 4) * 20) * Math.PI * 2) * 0.02;
                }

                left[i] = pressure + pressure2 + waterL + bubbles + sonar + whale;
                right[i] = pressure * 0.95 + pressure2 + waterR + bubbles * 0.8 + sonar * 0.7 + whale * 0.9;
            }

            // Heavy lowpass for underwater muffling
            for (let pass = 0; pass < 2; pass++) {
                for (let i = 1; i < samples; i++) {
                    left[i] = left[i] * 0.35 + left[i-1] * 0.65;
                    right[i] = right[i] * 0.35 + right[i-1] * 0.65;
                }
            }
        }

        function generateRadioactive(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Geiger counter clicks - Poisson-distributed
                if (Math.random() < 0.008) {
                    const clickLen = Math.floor(Math.random() * 40 + 15);
                    const clickFreq = 4000 + Math.random() * 2000;
                    for (let j = 0; j < clickLen && i + j < samples; j++) {
                        const env = Math.exp(-j / 8);
                        const click = Math.sin(j / sampleRate * clickFreq * Math.PI * 2) * env * 0.06;
                        const pan = Math.random();
                        left[i + j] += click * (1 - pan * 0.3);
                        right[i + j] += click * (0.7 + pan * 0.3);
                    }
                }

                // Low ominous drone
                const drone = Math.sin(t * 40 * Math.PI * 2) * 0.02;
                const drone2 = Math.sin(t * 60 * Math.PI * 2) * 0.01;

                // Unsettling high frequency whine
                const whine = Math.sin(t * 2200 * Math.PI * 2) * 0.003 * (Math.sin(t * 0.2) * 0.3 + 0.7);

                // Occasional electrical sparks
                let spark = 0;
                if (Math.random() < 0.0003) {
                    for (let j = 0; j < 500 && i + j < samples; j++) {
                        spark = (Math.random() * 2 - 1) * Math.exp(-j / 50) * 0.08;
                        left[i + j] += spark;
                        right[i + j] += spark * 0.9;
                    }
                }

                left[i] += drone + drone2 + whine;
                right[i] += drone + drone2 + whine * 0.95;
            }
        }

        function generateEnergyField(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Core field oscillation with beating
                const f1 = 180 + Math.sin(t * 2) * 15;
                const f2 = 185 + Math.sin(t * 2.3) * 12;
                const field1 = Math.sin(t * f1 * Math.PI * 2) * 0.03;
                const field2 = Math.sin(t * f2 * Math.PI * 2) * 0.025;

                // Higher harmonics for shimmer
                const shimmer1 = Math.sin(t * f1 * 2 * Math.PI * 2) * 0.012;
                const shimmer2 = Math.sin(t * f1 * 3 * Math.PI * 2) * 0.006;

                // Crackling energy arcs
                let crackle = 0;
                if (Math.random() < 0.015) {
                    const arcLen = Math.floor(Math.random() * 300 + 50);
                    for (let j = 0; j < arcLen && i + j < samples; j++) {
                        const env = Math.exp(-j / (arcLen * 0.2));
                        crackle = (Math.random() * 2 - 1) * env * 0.08;
                        left[i + j] += crackle;
                        right[i + j] += crackle * (0.7 + Math.random() * 0.3);
                    }
                }

                // Power fluctuation
                const fluctuate = Math.sin(t * 0.5 * Math.PI * 2) * 0.1 + 0.9;

                const signal = (field1 + field2 + shimmer1 + shimmer2) * fluctuate;
                left[i] = signal;
                right[i] = signal * 0.96;
            }
        }

        function generateQuantumHum(left, right, samples) {
            const sampleRate = 44100;

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;

                // Multiple close frequencies creating interference/beating patterns
                const f1 = 100;
                const f2 = 100.3;
                const f3 = 100.7;
                const f4 = 99.5;

                const wave1 = Math.sin(t * f1 * Math.PI * 2) * 0.02;
                const wave2 = Math.sin(t * f2 * Math.PI * 2) * 0.02;
                const wave3 = Math.sin(t * f3 * Math.PI * 2) * 0.015;
                const wave4 = Math.sin(t * f4 * Math.PI * 2) * 0.015;

                // Phase-shifted versions for stereo width
                const phase = Math.sin(t * 0.1 * Math.PI * 2);
                const shifted = Math.sin(t * (120 + phase * 30) * Math.PI * 2) * 0.015;

                // Subtle "uncertainty" noise
                const uncertainty = (Math.random() * 2 - 1) * 0.005 * (Math.sin(t * 0.3) * 0.5 + 0.5);

                // Occasional "collapse" events
                let collapse = 0;
                if (Math.random() < 0.0001) {
                    for (let j = 0; j < 2000 && i + j < samples; j++) {
                        const env = Math.exp(-j / 400);
                        collapse = Math.sin(j / sampleRate * 150 * (1 - j / 4000) * Math.PI * 2) * env * 0.03;
                        left[i + j] += collapse;
                        right[i + j] += collapse * 0.85;
                    }
                }

                left[i] = wave1 + wave2 + wave3 + shifted + uncertainty;
                right[i] = wave1 + wave3 + wave4 + shifted * 0.8 + uncertainty;
            }
        }

        // ============ NEW ABSTRACT SOUNDS ============

        function generateBlueNoise(left, right, samples) {
            // Blue noise - high frequency emphasis
            let prev = 0;
            for (let i = 0; i < samples; i++) {
                const white = Math.random() * 2 - 1;
                const blue = white - prev;
                prev = white;
                left[i] = blue * 0.1;
                right[i] = blue * 0.1 + (Math.random() * 2 - 1) * 0.01;
            }
        }

        function generateGreyNoise(left, right, samples) {
            // Grey noise - psychoacoustically flat
            let b0 = 0, b1 = 0, b2 = 0;
            for (let i = 0; i < samples; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99765 * b0 + white * 0.0990460;
                b1 = 0.96300 * b1 + white * 0.2965164;
                b2 = 0.57000 * b2 + white * 1.0526913;
                const grey = (b0 + b1 + b2 + white * 0.1848) * 0.08;
                left[i] = grey;
                right[i] = grey + (Math.random() * 2 - 1) * 0.005;
            }
        }

        function generateBinauralAlpha(left, right, samples) {
            // Alpha waves 8-12Hz - relaxation
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                left[i] = Math.sin(t * 200 * Math.PI * 2) * 0.06;
                right[i] = Math.sin(t * 210 * Math.PI * 2) * 0.06; // 10Hz beat
            }
        }

        function generateBinauralTheta(left, right, samples) {
            // Theta waves 4-8Hz - deep relaxation/sleep
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                left[i] = Math.sin(t * 150 * Math.PI * 2) * 0.06;
                right[i] = Math.sin(t * 156 * Math.PI * 2) * 0.06; // 6Hz beat
            }
        }

        function generateDroneDark(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Low minor tones
                const d1 = Math.sin(t * 36.71 * Math.PI * 2) * 0.08; // D1
                const d2 = Math.sin(t * 43.65 * Math.PI * 2) * 0.05; // F1
                const d3 = Math.sin(t * 55 * Math.PI * 2) * 0.04; // A1
                const mod = Math.sin(t * 0.05 * Math.PI * 2) * 0.2 + 0.8;
                left[i] = (d1 + d2 + d3) * mod;
                right[i] = (d1 + d2 + d3) * mod * 0.98;
            }
        }

        function generateDroneLight(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                // Higher major tones
                const d1 = Math.sin(t * 220 * Math.PI * 2) * 0.04; // A3
                const d2 = Math.sin(t * 277.18 * Math.PI * 2) * 0.03; // C#4
                const d3 = Math.sin(t * 329.63 * Math.PI * 2) * 0.025; // E4
                const d4 = Math.sin(t * 440 * Math.PI * 2) * 0.02; // A4
                const mod = Math.sin(t * 0.08 * Math.PI * 2) * 0.15 + 0.85;
                left[i] = (d1 + d2 + d3 + d4) * mod;
                right[i] = (d1 + d2 + d3 + d4) * mod * 0.97;
            }
        }

        function generateSine60Hz(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                const sine = Math.sin(t * 60 * Math.PI * 2) * 0.08;
                left[i] = sine;
                right[i] = sine;
            }
        }

        function generateSine432Hz(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                const sine = Math.sin(t * 432 * Math.PI * 2) * 0.06;
                // Add subtle harmonics
                const h2 = Math.sin(t * 864 * Math.PI * 2) * 0.015;
                const h3 = Math.sin(t * 1296 * Math.PI * 2) * 0.008;
                left[i] = sine + h2 + h3;
                right[i] = sine + h2 + h3;
            }
        }

        function generateHarmonicSeries(left, right, samples) {
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                const fundamental = 110; // A2
                let sum = 0;
                for (let h = 1; h <= 8; h++) {
                    sum += Math.sin(t * fundamental * h * Math.PI * 2) * (0.06 / h);
                }
                const mod = Math.sin(t * 0.1 * Math.PI * 2) * 0.2 + 0.8;
                left[i] = sum * mod;
                right[i] = sum * mod * 0.98;
            }
        }

        function generateShepardTone(left, right, samples) {
            // Shepard tone - eternally rising/falling illusion
            for (let i = 0; i < samples; i++) {
                const t = i / 44100;
                let sum = 0;
                const baseFreq = 55;
                const riseRate = 0.05; // Octaves per second
                for (let octave = 0; octave < 6; octave++) {
                    const freq = baseFreq * Math.pow(2, octave + (t * riseRate) % 1);
                    // Gaussian envelope centered at middle frequencies
                    const logFreq = Math.log2(freq / 440);
                    const envelope = Math.exp(-logFreq * logFreq / 2);
                    sum += Math.sin(t * freq * Math.PI * 2) * envelope * 0.02;
                }
                left[i] = sum;
                right[i] = sum * 0.98;
            }
        }

        // Play a sound
        async function playSound(id) {
            initAudio();

            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            const sound = activeSounds.get(id);
            if (!sound) return;

            // Generate buffer if not cached
            if (!sound.buffer) {
                sound.buffer = generateSound(id);
            }

            // Create source and gain nodes
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            source.buffer = sound.buffer;
            source.loop = true;
            source.connect(gainNode);
            gainNode.connect(masterGainNode);
            gainNode.gain.value = sound.volume;

            source.start();

            sound.sourceNode = source;
            sound.gainNode = gainNode;
        }

        // Stop a sound
        function stopSound(id) {
            const sound = activeSounds.get(id);
            if (sound && sound.sourceNode) {
                sound.sourceNode.stop();
                sound.sourceNode = null;
                sound.gainNode = null;
            }
        }

        // Toggle sound
        function toggleSound(id) {
            if (activeSounds.has(id)) {
                // Remove sound
                stopSound(id);
                activeSounds.delete(id);
            } else {
                // Add sound
                activeSounds.set(id, { volume: 0.5, buffer: null, sourceNode: null, gainNode: null });
                if (isPlaying) {
                    playSound(id);
                }
            }

            updateUI();
            saveState();
        }

        // Set volume for a sound
        function setVolume(id, volume) {
            const sound = activeSounds.get(id);
            if (sound) {
                sound.volume = volume;
                if (sound.gainNode) {
                    sound.gainNode.gain.setTargetAtTime(volume, audioContext.currentTime, 0.1);
                }
            }
            saveState();
        }

        // Remove sound from mix
        function removeSound(id) {
            stopSound(id);
            activeSounds.delete(id);
            updateUI();
            saveState();
        }

        // Play/pause all
        function togglePlayPause() {
            if (isPlaying) {
                // Pause all
                activeSounds.forEach((sound, id) => {
                    stopSound(id);
                });
                isPlaying = false;
            } else {
                // Play all
                activeSounds.forEach((sound, id) => {
                    playSound(id);
                });
                isPlaying = true;
            }
            updateUI();
        }

        // Load preset
        function loadPreset(presetId) {
            // Clear current sounds
            activeSounds.forEach((sound, id) => {
                stopSound(id);
            });
            activeSounds.clear();

            // Load preset sounds
            const preset = PRESETS[presetId];
            if (preset) {
                preset.forEach(({ id, volume }) => {
                    activeSounds.set(id, { volume, buffer: null, sourceNode: null, gainNode: null });
                    if (isPlaying) {
                        playSound(id);
                    }
                });
            }

            updateUI();
            saveState();

            // Close dropdown
            presetsDropdown.classList.remove('open');
        }

        // Timer functions
        function setTimer(minutes) {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            if (minutes === 0) {
                timerEndTime = null;
                timerDisplay.classList.remove('visible');
                timerBtn.classList.remove('active');
                return;
            }

            timerEndTime = Date.now() + minutes * 60 * 1000;
            timerBtn.classList.add('active');
            timerDisplay.classList.add('visible');

            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 1000);

            // Close dropdown
            timerDropdown.classList.remove('open');
        }

        function updateTimerDisplay() {
            if (!timerEndTime) return;

            const remaining = Math.max(0, timerEndTime - Date.now());
            const hours = Math.floor(remaining / 3600000);
            const minutes = Math.floor((remaining % 3600000) / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);

            if (hours > 0) {
                timerDisplayTime.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                timerDisplayTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            if (remaining <= 0) {
                // Timer finished - fade out
                clearInterval(timerInterval);
                timerInterval = null;
                timerEndTime = null;
                timerDisplay.classList.remove('visible');
                timerBtn.classList.remove('active');

                // Fade out audio
                if (masterGainNode) {
                    masterGainNode.gain.setTargetAtTime(0, audioContext.currentTime, 2);
                    setTimeout(() => {
                        if (isPlaying) {
                            togglePlayPause();
                        }
                        masterGainNode.gain.value = masterVolume.value / 100;
                    }, 5000);
                }
            }
        }

        function cancelTimer() {
            setTimer(0);
        }

        // Render sounds grid
        function renderSoundGrid() {
            const sounds = SOUNDS[currentCategory];
            soundGrid.innerHTML = sounds.map(sound => `
                <button class="sound-card ${activeSounds.has(sound.id) ? 'active' : ''}" data-id="${sound.id}">
                    <div class="sound-icon">${sound.icon}</div>
                    <span class="sound-name">${sound.name}</span>
                </button>
            `).join('');

            // Add click listeners
            soundGrid.querySelectorAll('.sound-card').forEach(card => {
                card.addEventListener('click', () => {
                    toggleSound(card.dataset.id);
                });
            });
        }

        // Render mixer
        function renderMixer() {
            if (activeSounds.size === 0) {
                mixerContent.innerHTML = `
                    <div class="mixer-empty">
                        <div class="mixer-empty-icon">„Ä∞Ô∏è</div>
                        <p>Select sounds to generate your atmosphere</p>
                        <p class="mixer-empty-sub">Every sound is synthesized in real-time ‚Äî no recordings</p>
                    </div>
                `;
                mixerSubtitle.textContent = 'No sounds playing';
                return;
            }

            mixerSubtitle.textContent = `${activeSounds.size} sound${activeSounds.size > 1 ? 's' : ''} in mix`;

            // Find sound info for each active sound
            const allSounds = Object.values(SOUNDS).flat();

            mixerContent.innerHTML = Array.from(activeSounds.entries()).map(([id, data]) => {
                const soundInfo = allSounds.find(s => s.id === id);
                if (!soundInfo) return '';

                return `
                    <div class="channel-strip" data-id="${id}">
                        <div class="channel-icon">${soundInfo.icon}</div>
                        <div class="channel-info">
                            <div class="channel-name">${soundInfo.name}</div>
                            <input type="range" class="volume-slider" min="0" max="100" value="${Math.round(data.volume * 100)}">
                        </div>
                        <span class="channel-volume">${Math.round(data.volume * 100)}%</span>
                        <button class="channel-remove" title="Remove">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"/>
                                <line x1="6" y1="6" x2="18" y2="18"/>
                            </svg>
                        </button>
                    </div>
                `;
            }).join('');

            // Add event listeners
            mixerContent.querySelectorAll('.channel-strip').forEach(strip => {
                const id = strip.dataset.id;
                const slider = strip.querySelector('.volume-slider');
                const volumeDisplay = strip.querySelector('.channel-volume');
                const removeBtn = strip.querySelector('.channel-remove');

                slider.addEventListener('input', () => {
                    const volume = slider.value / 100;
                    setVolume(id, volume);
                    volumeDisplay.textContent = `${slider.value}%`;
                });

                removeBtn.addEventListener('click', () => {
                    removeSound(id);
                });
            });
        }

        // Update UI
        function updateUI() {
            // Update sound cards
            soundGrid.querySelectorAll('.sound-card').forEach(card => {
                card.classList.toggle('active', activeSounds.has(card.dataset.id));
            });

            // Update category tab counts
            categoryTabs.forEach(tab => {
                const category = tab.dataset.category;
                const count = SOUNDS[category].filter(s => activeSounds.has(s.id)).length;
                const countEl = tab.querySelector('.count');
                countEl.classList.toggle('visible', count > 0);
            });

            // Update play button
            playIcon.style.display = isPlaying ? 'none' : 'block';
            pauseIcon.style.display = isPlaying ? 'block' : 'none';
            playBtn.classList.toggle('playing', isPlaying);

            // Update ambient glow
            ambientGlow.classList.toggle('active', isPlaying && activeSounds.size > 0);

            // Check if fireplace is active for cozy mode
            document.body.classList.toggle('cozy-mode', activeSounds.has('fireplace'));

            // Render mixer
            renderMixer();
        }

        // Save state to localStorage
        function saveState() {
            const state = {
                activeSounds: Array.from(activeSounds.entries()).map(([id, data]) => ({
                    id,
                    volume: data.volume
                })),
                masterVolume: masterVolume.value,
                category: currentCategory
            };
            localStorage.setItem('roomtone-state', JSON.stringify(state));
        }

        // Load state from localStorage
        function loadState() {
            try {
                const state = JSON.parse(localStorage.getItem('roomtone-state'));
                if (state) {
                    if (state.activeSounds) {
                        state.activeSounds.forEach(({ id, volume }) => {
                            activeSounds.set(id, { volume, buffer: null, sourceNode: null, gainNode: null });
                        });
                    }
                    if (state.masterVolume) {
                        masterVolume.value = state.masterVolume;
                    }
                    if (state.category) {
                        currentCategory = state.category;
                        categoryTabs.forEach(tab => {
                            tab.classList.toggle('active', tab.dataset.category === currentCategory);
                        });
                    }
                }
            } catch (e) {
                console.error('Failed to load state:', e);
            }
        }

        // Event listeners
        categoryTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                currentCategory = tab.dataset.category;
                categoryTabs.forEach(t => t.classList.toggle('active', t === tab));
                renderSoundGrid();
                saveState();
            });
        });

        playBtn.addEventListener('click', togglePlayPause);

        masterVolume.addEventListener('input', () => {
            if (masterGainNode) {
                masterGainNode.gain.setTargetAtTime(masterVolume.value / 100, audioContext.currentTime, 0.1);
            }
            saveState();
        });

        timerBtn.addEventListener('click', () => {
            timerDropdown.classList.toggle('open');
            presetsDropdown.classList.remove('open');
        });

        // Timer input elements
        const timerHoursInput = document.getElementById('timerHours');
        const timerMinutesInput = document.getElementById('timerMinutes');
        const timerSecondsInput = document.getElementById('timerSeconds');
        const timerStartBtn = document.getElementById('timerStartBtn');
        const timerClearBtn = document.getElementById('timerClearBtn');

        // Helper to get total seconds from inputs
        function getTimerSeconds() {
            const hours = parseInt(timerHoursInput.value) || 0;
            const minutes = parseInt(timerMinutesInput.value) || 0;
            const seconds = parseInt(timerSecondsInput.value) || 0;
            return hours * 3600 + minutes * 60 + seconds;
        }

        // Helper to set input values from total minutes
        function setTimerInputs(totalMinutes, totalSeconds = 0) {
            const hours = Math.floor(totalMinutes / 60);
            const mins = totalMinutes % 60;
            timerHoursInput.value = hours;
            timerMinutesInput.value = mins;
            timerSecondsInput.value = totalSeconds;
        }

        // Update start button state based on input values
        function updateStartButtonState() {
            const totalSeconds = getTimerSeconds();
            timerStartBtn.disabled = totalSeconds === 0;
            timerStartBtn.textContent = totalSeconds > 0 ? 'Start Timer' : 'Enter Time';
        }

        // Input validation and formatting
        [timerHoursInput, timerMinutesInput, timerSecondsInput].forEach(input => {
            input.addEventListener('input', () => {
                // Clamp values
                let val = parseInt(input.value) || 0;
                const max = parseInt(input.max);
                const min = parseInt(input.min);
                if (val > max) input.value = max;
                if (val < min) input.value = min;
                updateStartButtonState();
            });

            // Select all on focus for easy editing
            input.addEventListener('focus', () => {
                input.select();
            });

            // Handle arrow keys for increment/decrement
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (getTimerSeconds() > 0) {
                        startCustomTimer();
                    }
                }
            });
        });

        // Quick preset buttons
        timerDropdown.querySelectorAll('.timer-preset').forEach(btn => {
            btn.addEventListener('click', () => {
                const [mins, secs] = btn.dataset.time.split(':').map(Number);
                setTimerInputs(mins, secs || 0);
                updateStartButtonState();
            });
        });

        // Start timer from custom inputs
        function startCustomTimer() {
            const totalSeconds = getTimerSeconds();
            if (totalSeconds > 0) {
                setTimerFromSeconds(totalSeconds);
                timerDropdown.classList.remove('open');
            }
        }

        // Modified setTimer to accept seconds
        function setTimerFromSeconds(seconds) {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            if (seconds === 0) {
                timerEndTime = null;
                timerDisplay.classList.remove('visible');
                timerBtn.classList.remove('active');
                return;
            }

            timerEndTime = Date.now() + seconds * 1000;
            timerBtn.classList.add('active');
            timerDisplay.classList.add('visible');

            updateTimerDisplay();
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }

        timerStartBtn.addEventListener('click', startCustomTimer);

        timerClearBtn.addEventListener('click', () => {
            setTimerInputs(0, 0);
            timerHoursInput.value = 0;
            updateStartButtonState();
            cancelTimer();
        });

        timerCancel.addEventListener('click', cancelTimer);

        presetsBtn.addEventListener('click', () => {
            presetsDropdown.classList.toggle('open');
            timerDropdown.classList.remove('open');
        });

        presetsDropdown.querySelectorAll('.preset-option').forEach(opt => {
            opt.addEventListener('click', () => {
                loadPreset(opt.dataset.preset);
            });
        });

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!timerBtn.contains(e.target) && !timerDropdown.contains(e.target)) {
                timerDropdown.classList.remove('open');
            }
            if (!presetsBtn.contains(e.target) && !presetsDropdown.contains(e.target)) {
                presetsDropdown.classList.remove('open');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.matches('input, textarea')) return;

            if (e.code === 'Space') {
                e.preventDefault();
                togglePlayPause();
            } else if (e.key.toLowerCase() === 'm') {
                e.preventDefault();
                if (masterGainNode) {
                    const isMuted = masterGainNode.gain.value === 0;
                    masterGainNode.gain.setTargetAtTime(isMuted ? masterVolume.value / 100 : 0, audioContext.currentTime, 0.1);
                }
            }
        });

        // Initialize
        loadState();
        renderSoundGrid();
        updateUI();
    </script>
</body>
</html>
