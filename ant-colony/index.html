<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-D19M0488B7"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-D19M0488B7');</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ant Colony - hafnr</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%230f0f0f'/><text x='4' y='26' font-family='Arial' font-size='26' font-weight='bold' fill='%23fff'>h</text><circle cx='26' cy='24' r='3' fill='%23fff'/></svg>">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7723236991764317"
        crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #1a2418;
            --surface: rgba(28, 32, 26, 0.92);
            --border: rgba(100, 120, 80, 0.3);
            --text: #f0ebe0;
            --text-muted: #a8b0a0;
            --accent: #b8d468;
            --accent-glow: rgba(184, 212, 104, 0.15);
            --gold: #f4d03f;
        }

        body {
            background: var(--bg);
            min-height: 100vh;
            min-height: 100dvh;
            font-family: 'Playfair Display', Georgia, serif;
            color: var(--text);
            overflow: hidden;
            touch-action: none;
        }

        /* Work in Progress Overlay */
        .wip-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
        }

        .wip-overlay.hidden {
            display: none;
        }

        .wip-icon {
            font-size: 64px;
            animation: wip-bounce 2s ease-in-out infinite;
        }

        @keyframes wip-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .wip-title {
            font-family: 'Playfair Display', serif;
            font-size: 32px;
            color: var(--accent);
            text-align: center;
        }

        .wip-message {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            text-align: center;
            max-width: 400px;
            line-height: 1.6;
        }

        .wip-back-link {
            margin-top: 16px;
            font-family: 'DM Mono', monospace;
            font-size: 13px;
            color: var(--text-muted);
            text-decoration: none;
            padding: 10px 20px;
            border: 1px solid var(--border);
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .wip-back-link:hover {
            color: var(--accent);
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            cursor: crosshair;
            z-index: 1;
        }

        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 13px;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            backdrop-filter: blur(16px);
            transition: all 0.25s ease;
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.5px;
        }

        .back-link:hover {
            color: var(--text);
            background: rgba(35, 40, 32, 0.95);
            border-color: rgba(120, 160, 80, 0.4);
            transform: translateX(-2px);
        }

        .info-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 12px;
            padding: 20px 22px;
            font-size: 14px;
            color: var(--text-muted);
            max-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .info-panel h3 {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: var(--accent);
            margin-bottom: 16px;
            letter-spacing: 3px;
            text-transform: uppercase;
            padding-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .info-panel h3 .collapse-icon {
            font-size: 14px;
            transition: transform 0.3s ease;
        }

        .info-panel.collapsed h3 .collapse-icon {
            transform: rotate(180deg);
        }

        .info-panel.collapsed .panel-content {
            display: none;
        }

        .info-panel h3:hover {
            color: var(--text);
            border-bottom: 1px solid var(--border);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .stat-label {
            opacity: 0.7;
        }

        .stat-value {
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-weight: 500;
            font-size: 14px;
        }

        .stat-value.coins {
            color: var(--gold);
        }

        .ant-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 12px;
            font-family: 'DM Mono', monospace;
            font-size: 11px;
        }

        .ant-type {
            padding: 2px 8px;
            border-radius: 4px;
            opacity: 0.9;
        }

        .ant-type.worker {
            background: rgba(70, 50, 35, 0.5);
            color: #a08060;
        }


        /* Character Card Styles - Tactical Dossier Theme */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&display=swap');

        /* ============================================
           COMPACT ANT CARD - RPG Stat Card Style
           ============================================ */
        .character-card {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 280px;
            background: linear-gradient(180deg, rgba(15, 18, 22, 0.97) 0%, rgba(10, 12, 16, 0.99) 100%);
            border: 1px solid rgba(0, 255, 136, 0.25);
            border-radius: 8px;
            box-shadow:
                0 4px 24px rgba(0, 0, 0, 0.7),
                0 0 1px rgba(0, 255, 136, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
            z-index: 1000;
            overflow: visible;  /* Allow tooltips to extend outside */
            animation: cardAppear 0.25s cubic-bezier(0.23, 1, 0.32, 1);
            font-family: 'DM Mono', 'Share Tech Mono', monospace;
        }

        @keyframes cardAppear {
            from {
                opacity: 0;
                transform: translateX(20px) scale(0.96);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        .character-card.hidden {
            display: none;
        }

        /* Compact Header */
        .card-header {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.08) 0%, transparent 100%);
            border-bottom: 1px solid rgba(0, 255, 136, 0.12);
            gap: 10px;
        }

        .card-icon {
            font-size: 32px;
            filter: drop-shadow(0 0 6px rgba(0, 255, 136, 0.4));
        }

        .card-title-section {
            flex: 1;
            min-width: 0;
        }

        .card-title-section h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.4);
            letter-spacing: 0.5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-subtitle {
            font-size: 10px;
            color: rgba(0, 255, 136, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        .card-close {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.4);
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.15s;
            line-height: 1;
        }

        .card-close:hover {
            background: rgba(255, 60, 60, 0.15);
            color: #ff4444;
        }

        /* Compact Body */
        .card-body {
            padding: 10px 12px 12px;
        }

        /* HP and XP Bars Section */
        .card-exp-section {
            margin-bottom: 10px;
        }

        .compact-bar-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .compact-bar-row:last-child {
            margin-bottom: 0;
        }

        .compact-bar-label {
            font-size: 9px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 22px;
            flex-shrink: 0;
        }

        .compact-bar-container {
            flex: 1;
            height: 14px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .compact-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.4s ease;
            position: relative;
        }

        .compact-bar.hp {
            background: linear-gradient(90deg, #22c55e, #4ade80);
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.4);
        }

        .compact-bar.hp.low {
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
        }

        .compact-bar.hp.critical {
            background: linear-gradient(90deg, #ef4444, #f87171);
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
            animation: criticalPulse 1s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .compact-bar.xp {
            background: linear-gradient(90deg, #06b6d4, #22d3ee);
            box-shadow: 0 0 8px rgba(6, 182, 212, 0.3);
        }

        .compact-bar.xp.max {
            background: linear-gradient(90deg, #fbbf24, #fcd34d);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .compact-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 9px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            white-space: nowrap;
            letter-spacing: 0.5px;
        }

        .compact-bar-level {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 9px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        /* Stats Grid - 3x2 layout */
        .card-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 4px;
            padding: 6px 8px;
            text-align: center;
            transition: all 0.15s;
            cursor: help;
            position: relative;
        }

        .stat-item:hover {
            border-color: rgba(0, 255, 136, 0.3);
            background: rgba(0, 255, 136, 0.05);
        }

        .stat-item:hover .stat-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .stat-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .stat-item .stat-name {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .stat-item .stat-val {
            font-size: 14px;
            font-weight: 700;
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            line-height: 1;
        }

        /* WoW/Hearthstone-style stat rarity colors */
        .stat-item .stat-val.common { color: #ffffff; }  /* White - base stats */
        .stat-item .stat-val.uncommon { color: #1eff00; }  /* Green - good */
        .stat-item .stat-val.rare { color: #0070dd; }  /* Blue - great */
        .stat-item .stat-val.epic { color: #a335ee; }  /* Purple - exceptional */
        .stat-item .stat-val.legendary { color: #ff8000; }  /* Orange - legendary */

        /* Legacy class mappings for backwards compatibility */
        .stat-item .stat-val.good { color: #1eff00; }
        .stat-item .stat-val.exceptional { color: #a335ee; }
        .stat-item .stat-val.weak { color: #9d9d9d; }
        .stat-item .stat-val.poor { color: #9d9d9d; }

        /* Hide stat bars in compact mode */
        .stat-bar-container {
            display: none;
        }

        /* Compact Tooltip */
        .stat-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) translateY(5px);
            background: rgba(10, 12, 16, 0.98);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            padding: 8px 10px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.9);
            width: 160px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.15s ease-out;
            z-index: 1000;
            line-height: 1.4;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            text-align: center;
        }

        .stat-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 255, 136, 0.3);
        }

        .stat-tooltip .hp-current { font-weight: 700; color: #4ade80; font-size: 11px; }
        .stat-tooltip .hp-max { font-weight: 700; color: rgba(255, 255, 255, 0.7); font-size: 11px; }
        .stat-tooltip .hp-status { display: block; margin-top: 3px; font-weight: 600; font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-tooltip .hp-status.good { color: #4ade80; }
        .stat-tooltip .hp-status.weak { color: #fbbf24; }
        .stat-tooltip .hp-status.bad { color: #f87171; }
        .stat-tooltip small { display: block; margin-top: 4px; color: rgba(255, 255, 255, 0.4); font-size: 9px; }

        /* WoW-style Ability Tooltip */
        .ability-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(5px);
            background: linear-gradient(180deg, rgba(20, 18, 28, 0.98) 0%, rgba(12, 10, 18, 0.99) 100%);
            border: 2px solid;
            border-image: linear-gradient(135deg, rgba(255, 180, 100, 0.6) 0%, rgba(255, 140, 60, 0.4) 100%) 1;
            padding: 12px 14px;
            width: 220px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.2s ease-out;
            z-index: 1100;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.8), 0 0 1px rgba(255, 180, 100, 0.3);
        }

        .ability-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(255, 180, 100, 0.5);
        }

        .ability-tooltip-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 180, 100, 0.2);
        }

        .ability-tooltip-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 6px rgba(255, 180, 100, 0.5));
        }

        .ability-tooltip-title {
            flex: 1;
        }

        .ability-tooltip-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: 700;
            color: #ffb464;
            text-shadow: 0 0 8px rgba(255, 180, 100, 0.4);
        }

        .ability-tooltip-type {
            font-size: 9px;
            color: rgba(255, 180, 100, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ability-tooltip-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .ability-tooltip-meta {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            padding-top: 6px;
            border-top: 1px solid rgba(255, 180, 100, 0.15);
        }

        .ability-tooltip-cooldown {
            color: #00d4ff;
        }

        .card-skill:hover .ability-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* Tooltip for skilled ant buttons (appears to the left) */
        .skilled-ant-btn:hover .ability-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-10px) translateY(0);
        }

        .skilled-ant-btn .ability-tooltip::after {
            display: none;
        }

        .card-skill {
            position: relative;
        }

        .skilled-ant-btn {
            position: relative;
        }

        /* Compact Skill Section */
        .card-skill-section {
            display: none;
        }

        /* Skills row container for multiple skills */
        .card-skills-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* WoW-style skill icon - square with radial cooldown */
        .card-skill {
            position: relative;
            display: inline-block;
        }

        .wow-skill-icon {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 4px;
            overflow: hidden;
            background: linear-gradient(145deg, rgba(30, 25, 40, 0.95) 0%, rgba(15, 12, 22, 0.98) 100%);
            border: 2px solid rgba(255, 180, 100, 0.4);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .wow-skill-icon:hover {
            border-color: rgba(255, 180, 100, 0.8);
            box-shadow: 0 0 12px rgba(255, 180, 100, 0.4);
        }

        .wow-skill-icon.passive {
            border-color: rgba(100, 200, 100, 0.4);
        }

        .wow-skill-icon.passive:hover {
            border-color: rgba(100, 200, 100, 0.8);
            box-shadow: 0 0 12px rgba(100, 200, 100, 0.4);
        }

        .wow-skill-icon .skill-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 22px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
            transition: filter 0.2s ease;
            z-index: 1;
        }

        .wow-skill-icon.on-cooldown .skill-emoji {
            filter: brightness(0.4) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .wow-skill-icon.ready .skill-emoji {
            filter: brightness(1.1) drop-shadow(0 0 6px rgba(255, 180, 100, 0.6));
        }

        /* Radial cooldown sweep overlay */
        .wow-cooldown-sweep {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: conic-gradient(
                from 0deg,
                rgba(0, 0, 0, 0.8) var(--cooldown-percent, 0%),
                transparent var(--cooldown-percent, 0%)
            );
            pointer-events: none;
            z-index: 2;
        }

        .wow-skill-icon.ready .wow-cooldown-sweep {
            display: none;
        }

        /* Cooldown seconds text */
        .wow-cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.95), 0 0 8px rgba(0, 0, 0, 0.8);
            z-index: 3;
        }

        .wow-skill-icon.ready .wow-cooldown-text {
            display: none;
        }

        /* Ready glow pulse */
        .wow-ready-glow {
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 6px;
            border: 2px solid rgba(0, 255, 136, 0.6);
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }

        .wow-skill-icon.ready .wow-ready-glow {
            opacity: 1;
            animation: wowReadyPulse 1.5s ease-in-out infinite;
        }

        @keyframes wowReadyPulse {
            0%, 100% {
                opacity: 0.4;
                box-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 16px rgba(0, 255, 136, 0.6);
            }
        }

        /* Passive skill indicator (small P badge) */
        .wow-passive-badge {
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            font-size: 8px;
            font-weight: bold;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4;
        }

        /* Hide description in compact mode */
        .card-description {
            display: none;
        }

        /* Compact Traits */
        .card-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .trait-tag {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 136, 0.15);
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 9px;
            color: rgba(0, 255, 136, 0.7);
            font-family: 'DM Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            transition: all 0.15s;
            position: relative;
            cursor: help;
        }

        .trait-tag:hover {
            background: rgba(0, 255, 136, 0.08);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .trait-tag .trait-tooltip {
            position: absolute;
            bottom: calc(100% + 6px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 12, 16, 0.98);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 9px;
            font-family: 'DM Mono', monospace;
            text-transform: none;
            letter-spacing: 0;
            color: #c0c0c0;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .trait-tag .trait-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: rgba(0, 255, 136, 0.3);
        }

        .trait-tag:hover .trait-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .trait-tag.positive { border-color: rgba(125, 206, 160, 0.4); color: #7dcea0; }
        .trait-tag.negative { border-color: rgba(239, 68, 68, 0.4); color: #ef4444; }
        .trait-tag.special { border-color: rgba(255, 215, 0, 0.4); color: #ffd700; }
        .trait-tag.legendary {
            border-color: rgba(255, 215, 0, 0.6);
            color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 170, 0, 0.1));
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
            animation: legendaryPulse 2s ease-in-out infinite;
        }
        .trait-tag.exceptional {
            border-color: rgba(167, 139, 250, 0.5);
            color: #a78bfa;
            background: rgba(167, 139, 250, 0.1);
        }
        .trait-tag.good { border-color: rgba(0, 255, 136, 0.4); color: #00ff88; }
        .trait-tag.weak { border-color: rgba(156, 163, 175, 0.3); color: #9ca3af; }
        .trait-tag.poor { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .trait-tag.skill {
            border-color: rgba(59, 130, 246, 0.6);
            color: #60a5fa;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.1));
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
            animation: skillGlow 2.5s ease-in-out infinite;
        }

        @keyframes skillGlow {
            0%, 100% { box-shadow: 0 0 8px rgba(59, 130, 246, 0.3); }
            50% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
        }

        /* Level progress bar */
        .level-display {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .level-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
            letter-spacing: 2px;
        }

        .xp-total {
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            color: rgba(0, 255, 136, 0.7);
            background: rgba(0, 255, 136, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .level-bar-container {
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .level-bar {
            height: 100%;
            background: linear-gradient(90deg, #006633, #00aa55, #00ff88);
            transition: width 0.5s ease;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.4);
        }

        .level-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 100%);
            animation: levelShine 2s ease-in-out infinite;
        }

        .level-bar.max {
            background: linear-gradient(90deg, #cc8800, #ffd700, #ffee88, #ffd700, #cc8800);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .level-bar.max::after {
            animation: levelShineGold 1.5s ease-in-out infinite;
        }

        @keyframes levelShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        @keyframes levelShineGold {
            0% { transform: translateX(-100%); opacity: 0.5; }
            100% { transform: translateX(200%); opacity: 0.8; }
        }

        .level-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-family: 'Share Tech Mono', monospace;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9), 0 0 6px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            letter-spacing: 0.5px;
        }

        @keyframes legendaryPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        }

        .card-footer {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.25);
            border-top: 1px solid rgba(0, 255, 136, 0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 8px;
            color: rgba(0, 255, 136, 0.35);
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.5px;
        }

        .card-id {
            opacity: 0.7;
        }

        .card-status {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .status-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: #4ade80;
            animation: statusBlink 2s ease-in-out infinite;
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .instructions {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
            line-height: 1.7;
            font-size: 12px;
            font-style: italic;
            color: rgba(168, 176, 160, 0.75);
        }

        .bottom-ui {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .food-selector, .ant-selector {
            display: flex;
            gap: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 14px;
            padding: 12px 18px;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        /* Food Levels Panel (read-only display) */
        .food-levels-panel {
            display: flex;
            gap: 6px;
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 12px;
            padding: 10px 16px;
            align-items: center;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        }

        .food-levels-label {
            color: var(--text-muted);
            font-size: 10px;
            margin-right: 8px;
            font-family: 'DM Mono', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.6;
        }

        .food-level-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 6px 8px;
            background: rgba(50, 60, 45, 0.3);
            border-radius: 8px;
            min-width: 40px;
        }

        .food-level-item .emoji {
            font-size: 18px;
        }

        .food-level-item .food-level {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--accent);
            font-weight: 600;
        }

        .food-level-item .food-level.max-level {
            color: var(--gold);
            text-shadow: 0 0 8px rgba(244, 208, 63, 0.6);
        }

        .food-label, .ant-label {
            color: var(--text-muted);
            font-size: 11px;
            margin-right: 10px;
            font-family: 'DM Mono', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.6;
            min-width: 45px;
        }

        .food-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(50, 60, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .food-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .food-btn:hover::before {
            opacity: 1;
        }

        .food-btn:hover {
            background: rgba(70, 80, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .food-btn.active {
            border-color: var(--accent);
            background: rgba(80, 100, 60, 0.45);
            box-shadow: 0 0 24px var(--accent-glow), inset 0 0 20px var(--accent-glow);
        }

        .food-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Food cooldown overlay styles */
        .food-btn.on-cooldown {
            pointer-events: none;
            cursor: not-allowed;
        }

        .food-btn .cooldown-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .food-btn.on-cooldown .cooldown-overlay {
            opacity: 1;
        }

        .food-btn .cooldown-timer {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .food-btn .cooldown-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--gold), var(--accent));
            border-radius: 0 0 8px 8px;
            transition: width 0.1s linear;
        }

        .food-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        .food-btn span.cost, .ant-btn span.cost {
            font-size: 9px;
            font-family: 'DM Mono', monospace;
            color: var(--gold);
            opacity: 0.9;
        }

        .ant-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(60, 50, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .ant-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .ant-btn:hover::before {
            opacity: 1;
        }

        .ant-btn:hover {
            background: rgba(80, 70, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .ant-btn:active {
            transform: translateY(-1px) scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .ant-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ant-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        @media (max-width: 600px) {
            .info-panel {
                max-width: 180px;
                padding: 14px 16px;
            }

            .ui-overlay {
                top: 12px;
                left: 12px;
            }

            .bottom-ui {
                bottom: 12px;
                gap: 6px;
            }

            .food-selector, .ant-selector {
                padding: 8px 12px;
                gap: 6px;
            }

            .food-btn, .ant-btn {
                width: 42px;
                height: 42px;
            }

            .food-btn span.emoji, .ant-btn span.emoji {
                font-size: 16px;
            }

            .food-btn span.cost, .ant-btn span.cost {
                font-size: 8px;
            }

            .food-label, .ant-label {
                display: none;
            }
        }

        /* Hive Placement Overlay */
        .hive-placement-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            cursor: none;
            transition: opacity 0.4s ease;
        }

        /* Hive cursor that follows mouse during placement */
        .hive-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 1600;
            font-size: 48px;
            transform: translate(-50%, -50%);
            opacity: 0.85;
            filter: drop-shadow(0 0 12px rgba(244, 208, 63, 0.8)) drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
            transition: transform 0.1s ease-out, opacity 0.2s ease;
        }

        .hive-cursor.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .hive-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 2px dashed rgba(244, 208, 63, 0.5);
            border-radius: 50%;
            animation: hiveCursorPulse 1.5s ease-in-out infinite;
        }

        @keyframes hiveCursorPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.15); opacity: 0.8; }
        }

        .hive-placement-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .hive-placement-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(244, 208, 63, 0.6);
            letter-spacing: 3px;
            margin-bottom: 16px;
            animation: hivePulse 2s ease-in-out infinite;
        }

        .hive-placement-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            letter-spacing: 2px;
        }

        @keyframes hivePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }

        /* Game Over Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .game-over-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .game-over-content {
            background: linear-gradient(165deg, rgba(20, 24, 18, 0.98), rgba(12, 14, 10, 0.99));
            border: 2px solid rgba(180, 60, 60, 0.5);
            border-radius: 16px;
            padding: 48px 64px;
            text-align: center;
            box-shadow: 0 0 60px rgba(180, 60, 60, 0.3), inset 0 0 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .game-over-modal.visible .game-over-content {
            transform: scale(1);
        }

        .game-over-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 42px;
            color: #ff6b6b;
            margin-bottom: 12px;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            letter-spacing: 4px;
        }

        .game-over-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 32px;
            letter-spacing: 2px;
        }

        .survival-time {
            font-family: 'Orbitron', sans-serif;
            font-size: 64px;
            color: var(--gold);
            text-shadow: 0 0 30px rgba(244, 208, 63, 0.6);
            margin-bottom: 8px;
        }

        .survival-label {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: var(--text-muted);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 32px;
        }

        .game-stats {
            display: flex;
            gap: 32px;
            justify-content: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .game-stat {
            text-align: center;
        }

        .game-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--accent);
        }

        .game-stat-label {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-top: 4px;
        }

        .restart-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            padding: 16px 48px;
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.2), rgba(184, 212, 104, 0.1));
            border: 2px solid var(--accent);
            color: var(--accent);
            border-radius: 8px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.3), rgba(184, 212, 104, 0.2));
            box-shadow: 0 0 30px rgba(184, 212, 104, 0.3);
            transform: scale(1.05);
        }

        /* Timer Display */
        .timer-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: var(--gold);
            text-align: center;
            padding: 12px;
            margin-bottom: 12px;
            background: rgba(244, 208, 63, 0.1);
            border: 1px solid rgba(244, 208, 63, 0.3);
            border-radius: 8px;
            letter-spacing: 2px;
        }

        .timer-label {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: var(--text-muted);
            letter-spacing: 2px;
            text-transform: uppercase;
            display: block;
            margin-bottom: 4px;
        }

        /* Danger warning pulse */
        .danger-warning {
            animation: dangerPulse 1s ease-in-out infinite;
        }

        @keyframes dangerPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 60, 60, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 60, 60, 0.6); }
        }

        /* Upgrade Selection Panel - RPG Card Style (matches Ant Card aesthetic) */
        .upgrade-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(180deg, rgba(15, 18, 22, 0.97) 0%, rgba(10, 12, 16, 0.99) 100%);
            border: 1px solid rgba(0, 255, 136, 0.25);
            border-radius: 12px;
            padding: 20px 28px 24px;
            z-index: 2000;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow:
                0 4px 40px rgba(0, 0, 0, 0.8),
                0 0 1px rgba(0, 255, 136, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.03);
            min-width: 680px;
            max-width: 820px;
            opacity: 0;
            pointer-events: none;
            backdrop-filter: blur(16px);
            font-family: 'DM Mono', 'Share Tech Mono', monospace;
        }

        .upgrade-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.5), transparent);
            border-radius: 12px 12px 0 0;
        }

        .upgrade-modal.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        .upgrade-modal.minimized {
            transform: translate(-50%, 0) scale(1);
            top: 16px;
            opacity: 1;
            pointer-events: auto;
            padding: 10px 16px;
            min-width: auto;
            max-width: none;
            width: auto;
            border-radius: 8px;
        }

        .upgrade-modal.minimized .upgrade-header,
        .upgrade-modal.minimized .upgrade-subtitle,
        .upgrade-modal.minimized .upgrade-options,
        .upgrade-modal.minimized .upgrade-count {
            display: none;
        }

        .upgrade-modal.minimized .upgrade-timer {
            margin-bottom: 0;
            padding: 4px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .upgrade-modal.minimized .upgrade-timer-bar {
            width: 100px;
            margin-top: 0;
        }

        .upgrade-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .upgrade-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #00ff88;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.5), 0 2px 4px rgba(0, 0, 0, 0.4);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .upgrade-hide-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.5);
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .upgrade-hide-btn:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }

        .upgrade-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            color: rgba(0, 255, 136, 0.5);
            margin-bottom: 14px;
            letter-spacing: 1.5px;
            text-align: center;
            text-transform: uppercase;
        }

        .upgrade-timer {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: rgba(0, 255, 136, 0.8);
            text-align: center;
            margin-bottom: 16px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 136, 0.15);
        }

        .upgrade-timer-bar {
            height: 3px;
            background: rgba(0, 255, 136, 0.15);
            border-radius: 3px;
            margin-top: 6px;
            overflow: hidden;
        }

        .upgrade-timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #22d3ee);
            transition: width 0.1s linear;
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
        }

        .upgrade-expand-btn {
            display: none;
            background: transparent;
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-left: auto;
        }

        .upgrade-expand-btn:hover {
            background: rgba(0, 255, 136, 0.15);
            border-color: rgba(0, 255, 136, 0.5);
        }

        .upgrade-modal.minimized .upgrade-expand-btn {
            display: flex;
        }

        /* Horizontal Card Layout */
        .upgrade-options {
            display: flex;
            flex-direction: row;
            gap: 12px;
            justify-content: center;
            padding: 4px 0;
        }

        /* RPG-Style Upgrade Card (matches Ant Card aesthetic) */
        .upgrade-card {
            background: linear-gradient(180deg, rgba(20, 24, 28, 0.95) 0%, rgba(12, 15, 18, 0.98) 100%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 16px 14px 14px;
            text-align: center;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 170px;
            max-width: 200px;
            min-height: 180px;
        }

        .upgrade-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.6), transparent);
            opacity: 0;
            transition: opacity 0.25s;
        }

        .upgrade-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center top, rgba(0, 255, 136, 0.06) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.25s;
            pointer-events: none;
        }

        .upgrade-card:hover {
            border-color: rgba(0, 255, 136, 0.4);
            transform: translateY(-4px) scale(1.02);
            box-shadow:
                0 8px 24px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 136, 0.15);
        }

        .upgrade-card:hover::before {
            opacity: 1;
        }

        .upgrade-card:hover::after {
            opacity: 1;
        }

        .upgrade-card:active {
            transform: translateY(-4px) scale(1.01);
        }

        /* Card Emoji/Icon */
        .upgrade-emoji {
            font-size: 36px;
            filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.3));
            flex-shrink: 0;
            transition: transform 0.25s cubic-bezier(0.23, 1, 0.32, 1);
            margin-top: 4px;
        }

        .upgrade-card:hover .upgrade-emoji {
            transform: scale(1.1);
        }

        /* Card Info Container */
        .upgrade-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Card Name */
        .upgrade-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #00ff88;
            letter-spacing: 0.5px;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
            line-height: 1.3;
        }

        /* Card Description */
        .upgrade-desc {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.4;
        }

        /* Stack Count Badge */
        .upgrade-stacks {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            font-weight: bold;
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        /* Upgrade count display in UI */
        .upgrade-count {
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            color: var(--accent);
            text-align: center;
            padding: 10px 16px;
            margin-top: 16px;
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.1) 0%, rgba(184, 212, 104, 0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(184, 212, 104, 0.2);
        }

        /* Upgrade card wrapper for premium layout */
        .upgrade-card-wrapper {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex: 1;
            min-width: 180px;
            max-width: 220px;
        }

        /* Category label above upgrade card */
        .upgrade-category {
            font-family: 'DM Mono', monospace;
            font-size: 8px;
            letter-spacing: 1.5px;
            text-align: center;
            padding: 3px 10px;
            margin-bottom: 4px;
            border: 1px solid;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.4);
            text-transform: uppercase;
        }

        /* When wrapper has premium, adjust card border radius */
        .upgrade-card-wrapper:has(.upgrade-premium) .upgrade-card {
            border-radius: 16px 16px 0 0;
            border-bottom: none;
        }

        /* Premium upgrade option - connected to card */
        .upgrade-premium {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: linear-gradient(165deg, rgba(255, 180, 100, 0.08) 0%, rgba(255, 140, 60, 0.04) 100%);
            border: 1px solid rgba(255, 180, 100, 0.25);
            border-top: 1px dashed rgba(255, 180, 100, 0.3);
            border-radius: 0 0 8px 8px;
            padding: 8px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 0;
            position: relative;
        }

        /* Subtle connector line between card and premium */
        .upgrade-premium::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 180, 100, 0.4), transparent);
        }

        .upgrade-premium:hover:not(.disabled) {
            background: linear-gradient(165deg, rgba(244, 208, 63, 0.2) 0%, rgba(244, 180, 63, 0.15) 100%);
            border-color: var(--gold);
            border-top-color: rgba(244, 208, 63, 0.6);
            box-shadow: 0 4px 15px rgba(244, 208, 63, 0.2);
        }

        /* Hover on wrapper lifts both elements together */
        .upgrade-card-wrapper:hover .upgrade-premium:not(.disabled) {
            border-top-color: rgba(244, 208, 63, 0.5);
        }

        .upgrade-premium.disabled {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.6);
        }

        .premium-cost {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--gold);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            flex-shrink: 0;
        }

        .premium-desc {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: var(--gold);
            opacity: 0.9;
            text-align: center;
        }

        /* Food Level Display */
        .food-level {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: var(--accent);
            display: block;
            margin-top: 2px;
        }

        .food-btn .food-level.max-level {
            color: var(--gold);
            text-shadow: 0 0 6px rgba(244, 208, 63, 0.6);
        }

        /* Cycle Timer Display */
        .cycle-timer {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: 'DM Mono', monospace;
            font-size: 11px;
        }

        .cycle-label {
            color: var(--text-muted);
        }

        .cycle-countdown {
            color: var(--accent);
            font-weight: 500;
            min-width: 30px;
        }

        .cycle-bar {
            width: 60px;
            height: 4px;
            background: rgba(184, 212, 104, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .cycle-bar-fill {
            height: 100%;
            background: var(--accent);
            width: 100%;
            transition: width 0.5s linear;
        }

        /* Next Ant Preview - hidden since auto-spawn doesn't use bonuses */
        .next-ant-preview {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0, 255, 136, 0.08);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            font-family: 'DM Mono', monospace;
            font-size: 10px;
        }

        .preview-title {
            color: rgba(0, 255, 136, 0.7);
        }

        .preview-stats {
            color: #00ff88;
        }

        /* Harvest Summary Modal */
        .harvest-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(180deg, rgba(12, 18, 14, 0.98) 0%, rgba(8, 12, 10, 0.99) 100%);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-radius: 16px;
            padding: 28px 36px;
            z-index: 3000;
            min-width: 400px;
            max-width: 500px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow:
                0 0 60px rgba(0, 0, 0, 0.8),
                0 0 30px rgba(0, 255, 136, 0.15);
            backdrop-filter: blur(10px);
        }

        .harvest-modal.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        .harvest-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .harvest-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            letter-spacing: 2px;
            display: block;
            margin-bottom: 8px;
        }

        .harvest-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: rgba(0, 255, 136, 0.6);
        }

        .harvest-body {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 24px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 136, 0.15);
        }

        .harvest-deliveries {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            max-width: 180px;
        }

        .harvest-food-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 6px rgba(0, 255, 136, 0.4));
            animation: harvestBounce 0.5s ease-out;
        }

        @keyframes harvestBounce {
            0% { transform: scale(0) rotate(-20deg); }
            60% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .harvest-arrow {
            font-size: 32px;
            color: var(--gold);
            animation: arrowPulse 1s ease-in-out infinite;
        }

        @keyframes arrowPulse {
            0%, 100% { opacity: 0.6; transform: translateX(0); }
            50% { opacity: 1; transform: translateX(5px); }
        }

        .harvest-ant {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .harvest-ant-icon {
            font-size: 48px;
            filter: drop-shadow(0 0 12px rgba(0, 255, 136, 0.6));
            animation: antHatch 0.8s ease-out 0.3s both;
        }

        @keyframes antHatch {
            0% { transform: scale(0) rotate(-30deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .harvest-ant-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #00ff88;
            letter-spacing: 1px;
        }

        .harvest-stats {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
        }

        .harvest-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 10px 16px;
            background: rgba(0, 255, 136, 0.08);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            min-width: 60px;
        }

        .harvest-stat-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: rgba(0, 255, 136, 0.7);
            letter-spacing: 1px;
        }

        .harvest-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: #00ff88;
            font-weight: 700;
        }

        .harvest-stat-value.has-bonus {
            color: var(--gold);
            text-shadow: 0 0 8px rgba(244, 208, 63, 0.5);
        }

        .harvest-abilities {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .harvest-ability {
            padding: 8px 14px;
            background: linear-gradient(165deg, rgba(244, 208, 63, 0.15) 0%, rgba(244, 180, 63, 0.1) 100%);
            border: 1px solid rgba(244, 208, 63, 0.4);
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--gold);
            letter-spacing: 1px;
            animation: abilityGlow 1.5s ease-in-out infinite;
        }

        @keyframes abilityGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(244, 208, 63, 0.2); }
            50% { box-shadow: 0 0 20px rgba(244, 208, 63, 0.4); }
        }

        .harvest-continue-btn {
            display: block;
            width: 100%;
            padding: 14px 24px;
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 200, 100, 0.15) 100%);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 10px;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .harvest-continue-btn:hover {
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.3) 0%, rgba(0, 200, 100, 0.25) 100%);
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
        }

        /* No deliveries state */
        .harvest-no-deliveries {
            text-align: center;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            padding: 20px;
        }

        /* ===========================================
           SKILL CHOICE MODAL
           =========================================== */
        .skill-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(180deg, rgba(15, 10, 25, 0.98) 0%, rgba(10, 5, 20, 0.99) 100%);
            border: 2px solid rgba(255, 180, 100, 0.5);
            border-radius: 16px;
            padding: 28px 36px;
            z-index: 3500;
            min-width: 500px;
            max-width: 600px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow:
                0 0 60px rgba(0, 0, 0, 0.9),
                0 0 40px rgba(255, 180, 100, 0.2);
            backdrop-filter: blur(12px);
        }

        .skill-modal.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        .skill-modal-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .skill-modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #ffb464;
            text-shadow: 0 0 20px rgba(255, 180, 100, 0.6);
            letter-spacing: 3px;
            display: block;
            margin-bottom: 8px;
        }

        .skill-modal-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: rgba(255, 180, 100, 0.7);
        }

        .skill-ant-info {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            border: 1px solid rgba(255, 180, 100, 0.2);
            margin-bottom: 24px;
        }

        .skill-ant-icon {
            font-size: 40px;
            filter: drop-shadow(0 0 10px rgba(255, 180, 100, 0.4));
        }

        .skill-ant-details {
            flex: 1;
        }

        .skill-ant-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: #fff;
            margin-bottom: 4px;
        }

        .skill-ant-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            margin-top: 6px;
        }

        .skill-ant-stat {
            padding: 4px 6px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            text-align: center;
        }

        .skill-ant-stat .stat-label {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: block;
        }

        .skill-ant-stat .stat-value {
            font-weight: 600;
            display: block;
            color: #ffffff;  /* Default white */
        }

        /* WoW/Hearthstone-style rarity colors for skill modal stats */
        .skill-ant-stat .stat-value.common { color: #ffffff; }
        .skill-ant-stat .stat-value.uncommon { color: #1eff00; }
        .skill-ant-stat .stat-value.rare { color: #0070dd; }
        .skill-ant-stat .stat-value.epic { color: #a335ee; }
        .skill-ant-stat .stat-value.legendary { color: #ff8000; }

        .skill-ant-passive {
            margin-top: 8px;
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            color: #ffd700;
        }

        .skill-options {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 180, 100, 0.4) rgba(0, 0, 0, 0.2);
        }

        .skill-options::-webkit-scrollbar {
            width: 8px;
        }

        .skill-options::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .skill-options::-webkit-scrollbar-thumb {
            background: rgba(255, 180, 100, 0.4);
            border-radius: 4px;
        }

        .skill-options::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 180, 100, 0.6);
        }

        .skill-card {
            flex: 1;
            min-width: 150px;
            max-width: calc(33.33% - 8px);
            padding: 20px 16px;
            background: linear-gradient(180deg, rgba(40, 30, 50, 0.8) 0%, rgba(25, 20, 35, 0.9) 100%);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .skill-card:hover {
            border-color: rgba(255, 180, 100, 0.6);
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(255, 180, 100, 0.2);
        }

        .skill-card.selected {
            border-color: #ffb464;
            background: linear-gradient(180deg, rgba(255, 180, 100, 0.15) 0%, rgba(200, 140, 80, 0.1) 100%);
        }

        .skill-card-icon {
            font-size: 36px;
            display: block;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
        }

        .skill-card-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #fff;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .skill-card-type {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .skill-card-desc {
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
        }

        .skill-confirm-btn {
            display: none;
            width: 100%;
            padding: 14px 24px;
            background: linear-gradient(180deg, rgba(255, 180, 100, 0.25) 0%, rgba(200, 140, 80, 0.2) 100%);
            border: 2px solid rgba(255, 180, 100, 0.5);
            border-radius: 10px;
            color: #ffb464;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .skill-confirm-btn:hover {
            background: linear-gradient(180deg, rgba(255, 180, 100, 0.35) 0%, rgba(200, 140, 80, 0.3) 100%);
            border-color: #ffb464;
            box-shadow: 0 0 25px rgba(255, 180, 100, 0.3);
            transform: translateY(-2px);
        }

        .skill-confirm-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* ===========================================
           SKILLED ANTS SIDEBAR (Bottom Right)
           =========================================== */
        .skilled-ants-panel {
            position: fixed;
            bottom: 100px;
            right: 12px;
            z-index: 800;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-end;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            scrollbar-width: none;
        }

        .skilled-ants-panel::-webkit-scrollbar {
            display: none;
        }

        .skilled-ant-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 10px;
            background: linear-gradient(180deg, rgba(15, 12, 22, 0.92) 0%, rgba(10, 8, 18, 0.95) 100%);
            border: 1px solid rgba(255, 180, 100, 0.25);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(6px);
            min-width: 120px;
            pointer-events: auto;
            user-select: none;
        }

        .skilled-ant-btn:hover {
            border-color: rgba(255, 180, 100, 0.6);
            transform: translateX(-3px);
            box-shadow: 0 2px 12px rgba(255, 180, 100, 0.2);
            background: linear-gradient(180deg, rgba(25, 20, 35, 0.95) 0%, rgba(15, 12, 25, 0.98) 100%);
        }

        .skilled-ant-btn:active {
            transform: translateX(-1px) scale(0.98);
        }

        .skilled-ant-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .skilled-ant-info {
            text-align: left;
            flex: 1;
            min-width: 0;
        }

        .skilled-ant-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .skilled-ant-skill {
            font-family: 'DM Mono', monospace;
            font-size: 8px;
            color: #ffb464;
        }

        .skilled-ant-cooldown {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255, 180, 100, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: #ffb464;
            flex-shrink: 0;
        }

        .skilled-ant-cooldown.ready {
            border-color: #00ff88;
            color: #00ff88;
            animation: readyPulse 1.5s ease-in-out infinite;
        }

        @keyframes readyPulse {
            0%, 100% { box-shadow: 0 0 4px rgba(0, 255, 136, 0.2); }
            50% { box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
        }

        /* Level up effect */
        @keyframes levelUpBurst {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- Work in Progress Overlay - shown on public site, hidden on localhost -->
    <div class="wip-overlay" id="wip-overlay">
        <div class="wip-icon"></div>
        <h1 class="wip-title">Work in Progress</h1>
        <p class="wip-message">
            The ant colony simulation is currently under development.
            Check back soon for the full experience!
        </p>
        <a href="/" class="wip-back-link"> back to hafnr</a>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-overlay">
        <a href="/" class="back-link">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            back
        </a>
        <div class="info-panel" id="info-panel">
            <h3 onclick="toggleInfoPanel()">Ant Colony <span class="collapse-icon"></span></h3>
            <div class="panel-content">
                <div class="timer-display" id="timer-display">
                    <span class="timer-label">Survival Time</span>
                    <span id="survival-timer">0:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Coins</span>
                    <span class="stat-value coins" id="coins">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Population</span>
                    <span class="stat-value" id="ant-count">0</span>
                </div>
                <div class="ant-breakdown">
                    <span class="ant-type worker" id="worker-count" title="Workers">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Food stored</span>
                    <span class="stat-value" id="food-collected">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Character Card Modal -->
    <div id="character-card" class="character-card hidden">
        <div class="card-header">
            <span class="card-icon" id="card-icon"></span>
            <div class="card-title-section">
                <h3 id="card-title">Worker</h3>
                <span class="card-subtitle" id="card-subtitle">Ant</span>
            </div>
            <button class="card-close" onclick="closeCharacterCard()"></button>
        </div>
        <div class="card-body">
            <!-- HP and XP bars -->
            <div class="card-exp-section" id="card-exp-section">
                <div class="compact-bar-row" id="hp-bar-row">
                    <span class="compact-bar-label">HP</span>
                    <div class="compact-bar-container">
                        <div class="compact-bar hp" id="compact-hp-bar" style="width: 100%"></div>
                        <span class="compact-bar-text" id="compact-hp-text">10/10</span>
                    </div>
                </div>
                <div class="compact-bar-row">
                    <span class="compact-bar-label">XP</span>
                    <div class="compact-bar-container">
                        <div class="compact-bar xp" id="compact-xp-bar" style="width: 0%"></div>
                        <span class="compact-bar-level" id="compact-level">Lv.1</span>
                    </div>
                </div>
            </div>
            <!-- Stat grid -->
            <div class="card-stats" id="card-stats"></div>
            <!-- Skill section -->
            <div class="card-skill-section" id="card-skill-section"></div>
            <!-- Traits -->
            <div class="card-traits" id="card-traits"></div>
            <!-- Hidden elements for compatibility -->
            <div class="card-description" id="card-description" style="display:none"></div>
        </div>
        <div class="card-footer">
            <span class="card-id" id="card-id">ID: #000</span>
            <div class="card-status">
                <span class="status-dot"></span>
                <span>ACTIVE</span>
            </div>
        </div>
    </div>

    <div class="bottom-ui">
        <!-- Food Levels Display -->
        <div class="food-levels-panel">
            <span class="food-levels-label">Food Levels</span>
            <div class="food-level-item" title="Sugar - +HP per unit. Lv.10: Gold Hunter">
                <span class="emoji"></span>
                <span class="food-level" id="sugar-level">1</span>
            </div>
            <div class="food-level-item" title="Protein - +ATK per unit. Lv.10: Lifesteal">
                <span class="emoji"></span>
                <span class="food-level" id="protein-level">1</span>
            </div>
            <div class="food-level-item" title="Fruit - +SPD per unit. Lv.10: Fresh Keeper">
                <span class="emoji"></span>
                <span class="food-level" id="fruit-level">1</span>
            </div>
            <div class="food-level-item" title="Feast - +DEF per unit. Lv.10: Thorns">
                <span class="emoji"></span>
                <span class="food-level" id="feast-level">1</span>
            </div>
            <div class="food-level-item" title="Nectar - +HP5 per unit (heal 1 HP/5s). Lv.10: Regeneration">
                <span class="emoji"></span>
                <span class="food-level" id="nectar-level">1</span>
            </div>
        </div>
        <!-- Cycle Timer Display -->
        <div class="cycle-timer" id="cycle-timer">
            <span class="cycle-label">Next Ant:</span>
            <span class="cycle-countdown" id="cycle-countdown">60s</span>
            <div class="cycle-bar">
                <div class="cycle-bar-fill" id="cycle-bar-fill"></div>
            </div>
        </div>
        <!-- Next Ant Preview -->
        <div class="next-ant-preview" id="next-ant-preview">
            <span class="preview-title">Bonuses:</span>
            <span class="preview-stats" id="preview-stats">--</span>
        </div>
    </div>

    <!-- Hive Placement Overlay -->
    <div id="hive-placement-overlay" class="hive-placement-overlay">
        <div class="hive-placement-text">CLICK TO PLACE YOUR HIVE</div>
        <div class="hive-placement-subtitle">Choose where your colony will begin</div>
    </div>

    <!-- Hive Cursor (follows mouse during placement) -->
    <div id="hive-cursor" class="hive-cursor hidden"></div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="game-over-modal">
        <div class="game-over-content">
            <div class="game-over-title">COLONY EXTINCT</div>
            <div class="game-over-subtitle">The darkness has consumed your colony</div>
            <div class="survival-time" id="final-time">0:00</div>
            <div class="survival-label">Survival Time</div>
            <div class="game-stats">
                <div class="game-stat">
                    <div class="game-stat-value" id="final-food">0</div>
                    <div class="game-stat-label">Food Collected</div>
                </div>
                <div class="game-stat">
                    <div class="game-stat-value" id="final-coins">0</div>
                    <div class="game-stat-label">Coins Earned</div>
                </div>
                <div class="game-stat">
                    <div class="game-stat-value" id="final-ants">0</div>
                    <div class="game-stat-label">Ants Spawned</div>
                </div>
            </div>
            <button class="restart-btn" onclick="restartGame()">RESTART</button>
        </div>
    </div>

    <!-- Skill Choice Modal -->
    <div id="skill-modal" class="skill-modal">
        <div class="skill-modal-header">
            <span class="skill-modal-title">LEVEL 3!</span>
            <span class="skill-modal-subtitle">Choose a skill for this ant</span>
        </div>
        <div class="skill-ant-info" id="skill-ant-info">
            <span class="skill-ant-icon"></span>
            <div class="skill-ant-details">
                <div class="skill-ant-name" id="skill-ant-name">Ant #1</div>
                <div class="skill-ant-stats" id="skill-ant-stats">
                    <span class="skill-ant-stat hp">HP: 10</span>
                    <span class="skill-ant-stat atk">ATK: 5</span>
                    <span class="skill-ant-stat def">DEF: 3</span>
                </div>
                <div class="skill-ant-passive" id="skill-ant-passive"></div>
            </div>
        </div>
        <div class="skill-options" id="skill-options">
            <!-- Skill cards inserted by JS -->
        </div>
        <button class="skill-confirm-btn" id="skill-confirm-btn" disabled>SELECT A SKILL</button>
    </div>

    <!-- Skilled Ants Panel (Bottom Right) -->
    <div class="skilled-ants-panel" id="skilled-ants-panel">
        <!-- Skilled ant buttons inserted by JS -->
    </div>

    <!-- Harvest Summary Modal -->
    <div id="harvest-modal" class="harvest-modal">
        <div class="harvest-header">
            <span class="harvest-title">HARVEST COMPLETE</span>
            <span class="harvest-subtitle">New ant is hatching...</span>
        </div>
        <div class="harvest-body">
            <div class="harvest-deliveries" id="harvest-deliveries">
                <!-- Food icons delivered this cycle -->
            </div>
            <div class="harvest-arrow"></div>
            <div class="harvest-ant">
                <span class="harvest-ant-icon"></span>
                <span class="harvest-ant-label">New Ant</span>
            </div>
        </div>
        <div class="harvest-stats" id="harvest-stats">
            <div class="harvest-stat">
                <span class="harvest-stat-label">HP</span>
                <span class="harvest-stat-value" id="harvest-hp">+0</span>
            </div>
            <div class="harvest-stat">
                <span class="harvest-stat-label">ATK</span>
                <span class="harvest-stat-value" id="harvest-atk">+0</span>
            </div>
            <div class="harvest-stat">
                <span class="harvest-stat-label">DEF</span>
                <span class="harvest-stat-value" id="harvest-def">+0</span>
            </div>
            <div class="harvest-stat">
                <span class="harvest-stat-label">CARRY</span>
                <span class="harvest-stat-value" id="harvest-carry">+0</span>
            </div>
        </div>
        <div class="harvest-abilities" id="harvest-abilities">
            <!-- Abilities earned this cycle -->
        </div>
        <button class="harvest-continue-btn" id="harvest-continue-btn">SPAWN ANT</button>
    </div>

    <!-- Upgrade Selection Panel -->
    <div id="upgrade-modal" class="upgrade-modal">
        <div class="upgrade-header">
            <div class="upgrade-title">EVOLVE</div>
            <button class="upgrade-hide-btn" id="upgrade-hide-btn" title="Hide (still counting down)"></button>
        </div>
        <div class="upgrade-subtitle">Pick an upgrade</div>
        <div class="upgrade-timer" id="upgrade-timer">
            <span class="upgrade-timer-text">Auto-select in: <span id="upgrade-countdown">60</span>s</span>
            <button class="upgrade-expand-btn" id="upgrade-expand-btn" title="Show upgrade choices"></button>
            <div class="upgrade-timer-bar">
                <div class="upgrade-timer-fill" id="upgrade-timer-fill" style="width: 100%"></div>
            </div>
        </div>
        <div class="upgrade-options" id="upgrade-options">
            <!-- Upgrade cards will be inserted here by JavaScript -->
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let dpr = window.devicePixelRatio || 1;
        let width = window.innerWidth;
        let height = window.innerHeight;
        let time = 0;

        // ===========================================
        // FLOATING TEXT & COMBAT EFFECTS SYSTEM
        // ===========================================

        let floatingTexts = [];
        let combatEffects = [];
        let deathEffects = [];

        // Spawn a death effect (particle explosion + skull)
        function spawnDeathEffect(x, y, type = 'ant', color = null) {
            const isAnt = type === 'ant';
            const baseColor = color || (isAnt ? { r: 80, g: 50, b: 30 } : { r: 100, g: 100, b: 100 });
            const particleCount = isAnt ? 12 : 20;
            const particles = [];

            // Create particles that explode outward
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.3;
                const speed = 1.5 + Math.random() * 2.5;
                particles.push({
                    x: 0,
                    y: 0,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,  // Slight upward bias
                    size: isAnt ? (2 + Math.random() * 2) : (3 + Math.random() * 3),
                    color: `rgb(${baseColor.r + Math.random() * 30}, ${baseColor.g + Math.random() * 30}, ${baseColor.b + Math.random() * 20})`,
                    rotation: Math.random() * Math.PI * 2
                });
            }

            deathEffects.push({
                x: x,
                y: y,
                type: type,
                particles: particles,
                life: 50,  // frames
                maxLife: 50,
                skullScale: 0,
                emoji: isAnt ? '' : ''
            });
        }

        function updateDeathEffects() {
            for (let i = deathEffects.length - 1; i >= 0; i--) {
                const de = deathEffects[i];
                de.life--;

                // Animate skull pop-in then fade
                if (de.life > 35) {
                    de.skullScale += (1.2 - de.skullScale) * 0.3;
                } else if (de.life > 25) {
                    de.skullScale += (1.0 - de.skullScale) * 0.2;
                }

                // Update particles
                for (const p of de.particles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15;  // Gravity
                    p.vx *= 0.96;  // Air resistance
                    p.rotation += 0.1;
                }

                if (de.life <= 0) {
                    deathEffects.splice(i, 1);
                }
            }
        }

        function drawDeathEffects() {
            ctx.save();
            for (const de of deathEffects) {
                const alpha = de.life / de.maxLife;

                // Draw particles
                for (const p of de.particles) {
                    ctx.save();
                    ctx.globalAlpha = alpha * 0.8;
                    ctx.translate(de.x + p.x, de.y + p.y);
                    ctx.rotate(p.rotation);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    ctx.restore();
                }

                // Draw skull emoji with pop-in effect
                if (de.skullScale > 0.1) {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.translate(de.x, de.y - 10);
                    ctx.scale(de.skullScale, de.skullScale);
                    ctx.font = de.type === 'ant' ? '16px serif' : '22px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(de.emoji, 0, 0);
                    ctx.restore();
                }
            }
            ctx.restore();
        }

        function spawnFloatingText(x, y, text, color = '#ffd700', size = 14, duration = 120, followTarget = null) {
            floatingTexts.push({
                x: x,
                y: y,
                offsetY: 0,  // Accumulated vertical offset from floating
                text: text,
                color: color,
                size: size,
                alpha: 1,
                life: duration,  // frames (doubled from 60 to 120 for slower animation)
                maxLife: duration,
                vy: -0.3,   // float upward slower when following
                followTarget: followTarget  // Ant or entity to follow (optional)
            });
        }

        function spawnCombatEffect(x, y, antHp, antMaxHp, predatorHp, predatorMaxHp) {
            combatEffects.push({
                x: x,
                y: y,
                antHp: antHp,
                antMaxHp: antMaxHp,
                predatorHp: predatorHp,
                predatorMaxHp: predatorMaxHp,
                life: 40,  // frames
                scale: 0,
                targetScale: 1
            });
        }

        // Level up visual effects array
        let levelUpEffects = [];

        function spawnLevelUpEffect(x, y, level) {
            // Level up effect - just spawn floating text, no ring animation
            const colors = {
                2: '#00ffd5',  // Cyan
                3: '#ffb464',  // Orange (skill unlock!)
                4: '#a855f7',  // Purple
                5: '#ffd700'   // Gold
            };
            const color = colors[level] || '#00ff88';

            // Spawn floating level up text only
            spawnFloatingText(x, y - 20, `Level ${level}!`, color, 18, 420);  // 7 seconds
        }

        function updateLevelUpEffects() {
            for (let i = levelUpEffects.length - 1; i >= 0; i--) {
                const le = levelUpEffects[i];
                le.life--;

                // Expand rings much slower (0.05 instead of 0.15)
                for (const ring of le.rings) {
                    ring.radius += (ring.targetRadius - ring.radius) * 0.05;
                    ring.alpha *= 0.99;  // Fade much slower (0.99 instead of 0.96)
                }

                // Move particles outward slower
                for (const p of le.particles) {
                    p.dist += p.speed * 0.4;  // 40% of original speed
                }

                if (le.life <= 0) {
                    levelUpEffects.splice(i, 1);
                }
            }
        }

        function drawLevelUpEffects() {
            ctx.save();
            for (const le of levelUpEffects) {
                const progress = 1 - (le.life / le.maxLife);

                // Draw expanding rings
                for (const ring of le.rings) {
                    ctx.strokeStyle = le.color;
                    ctx.lineWidth = 3 * ring.alpha;
                    ctx.globalAlpha = ring.alpha * 0.8;
                    ctx.beginPath();
                    ctx.arc(le.x, le.y, ring.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw particles
                ctx.globalAlpha = Math.max(0, 1 - progress * 1.5);
                ctx.fillStyle = le.color;
                for (const p of le.particles) {
                    const px = le.x + Math.cos(p.angle) * p.dist;
                    const py = le.y + Math.sin(p.angle) * p.dist;
                    ctx.beginPath();
                    ctx.arc(px, py, p.size * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // ===========================================
        // SKILL CHOICE SYSTEM
        // ===========================================

        function queueSkillChoice(ant, skillSlot = 1) {
            // Add to pending queue with skill slot info
            const existing = pendingSkillChoices.find(p => p.ant === ant && p.slot === skillSlot);
            if (!existing) {
                pendingSkillChoices.push({ ant: ant, slot: skillSlot });
            }
            // If no modal open, show next skill choice
            if (!skillChoiceModalOpen && !harvestModalOpen && !upgradesPaused) {
                showNextSkillChoice();
            }
        }

        let currentSkillSlot = 1;  // Which skill slot we're choosing for

        function showNextSkillChoice() {
            if (pendingSkillChoices.length === 0) return;

            const pending = pendingSkillChoices[0];
            const ant = pending.ant;
            currentSkillSlot = pending.slot;

            // Check if ant is still alive
            if (!ants.includes(ant)) {
                pendingSkillChoices.shift();
                showNextSkillChoice();
                return;
            }

            skillChoiceAnt = ant;
            skillChoiceModalOpen = true;

            // Pause game
            if (pauseStartTime === null) {
                pauseStartTime = Date.now();
            }

            // Populate modal
            const modal = document.getElementById('skill-modal');
            const titleEl = document.querySelector('.skill-modal-title');
            const subtitleEl = document.querySelector('.skill-modal-subtitle');
            const nameEl = document.getElementById('skill-ant-name');
            const statsEl = document.getElementById('skill-ant-stats');
            const passiveEl = document.getElementById('skill-ant-passive');
            const optionsEl = document.getElementById('skill-options');
            const confirmBtn = document.getElementById('skill-confirm-btn');

            // Update title based on skill slot
            if (currentSkillSlot === 1) {
                titleEl.textContent = 'LEVEL 3!';
                subtitleEl.textContent = 'Choose a skill for this ant';
            } else {
                titleEl.textContent = 'LEVEL 7!';
                subtitleEl.textContent = 'Choose a second skill for this ant';
            }

            nameEl.textContent = `${ant.name} #${ant.id}`;

            // Show all stats like the compact card with rarity colors
            const spdVal = ant.speed * upgradeMultipliers.antSpeed;
            const detVal = ant.foodDetectRadius * upgradeMultipliers.detectionRadius;
            const capVal = ant.carryCapacity + upgradeMultipliers.carryCapacity;
            const pherVal = ant.pheromoneStrength;

            // Get rarity classes for each stat
            const hpRarity = getStatRarity('HP', ant.maxHp);
            const atkRarity = getStatRarity('ATK', ant.atk);
            const defRarity = getStatRarity('DEF', ant.def);
            const spdRarity = getStatRarity('SPD', spdVal);
            const detRarity = getStatRarity('DET', detVal);
            const capRarity = getStatRarity('CAP', capVal);
            const pherRarity = getStatRarity('PHER', pherVal);

            statsEl.innerHTML = `
                <span class="skill-ant-stat"><span class="stat-label">HP</span><span class="stat-value ${hpRarity}">${Math.floor(ant.maxHp)}</span></span>
                <span class="skill-ant-stat"><span class="stat-label">ATK</span><span class="stat-value ${atkRarity}">${Math.floor(ant.atk)}</span></span>
                <span class="skill-ant-stat"><span class="stat-label">DEF</span><span class="stat-value ${defRarity}">${Math.floor(ant.def)}</span></span>
                <span class="skill-ant-stat"><span class="stat-label">SPD</span><span class="stat-value ${spdRarity}">${spdVal.toFixed(2)}</span></span>
                <span class="skill-ant-stat"><span class="stat-label">DET</span><span class="stat-value ${detRarity}">${Math.round(detVal)}</span></span>
                <span class="skill-ant-stat"><span class="stat-label">CAP</span><span class="stat-value ${capRarity}">${Math.round(capVal)}</span></span>
                <span class="skill-ant-stat"><span class="stat-label">PHER</span><span class="stat-value ${pherRarity}">${pherVal.toFixed(1)}</span></span>
            `;

            // Show current skill if choosing second skill
            if (currentSkillSlot === 2 && ant.chosenSkill) {
                passiveEl.style.display = 'block';
                passiveEl.innerHTML = `<span style="color: ${ant.chosenSkill.color}">Current: ${ant.chosenSkill.icon} ${ant.chosenSkill.name}</span>`;
            } else {
                passiveEl.style.display = 'none';
            }

            // Generate skill options, excluding skills the ant already has
            const allSkillKeys = Object.keys(ANT_SKILLS);
            const excludeKeys = [];
            if (ant.skillKey) excludeKeys.push(ant.skillKey);
            if (ant.skillKey2) excludeKeys.push(ant.skillKey2);
            const availableKeys = allSkillKeys.filter(k => !excludeKeys.includes(k));

            // Debug mode on localhost: show ALL skills in a scrollable list
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            let selectedSkillKeys;
            if (isLocalhost) {
                // Sort skills alphabetically for easier finding
                selectedSkillKeys = availableKeys.sort((a, b) => ANT_SKILLS[a].name.localeCompare(ANT_SKILLS[b].name));
                optionsEl.style.maxHeight = '400px';
                optionsEl.style.overflowY = 'auto';
            } else {
                // Shuffle and pick 3 random skills for production
                const shuffled = availableKeys.sort(() => Math.random() - 0.5);
                selectedSkillKeys = shuffled.slice(0, 3);
                optionsEl.style.maxHeight = '';
                optionsEl.style.overflowY = '';
            }
            optionsEl.innerHTML = '';

            for (const key of selectedSkillKeys) {
                const skill = ANT_SKILLS[key];
                const card = document.createElement('div');
                card.className = 'skill-card';
                card.dataset.skill = key;
                card.innerHTML = `
                    <span class="skill-card-icon">${skill.icon}</span>
                    <div class="skill-card-name">${skill.name}</div>
                    <div class="skill-card-type">${skill.type}</div>
                    <div class="skill-card-desc">${skill.description}</div>
                `;
                card.onclick = () => selectSkillCard(key);
                optionsEl.appendChild(card);
            }

            confirmBtn.disabled = true;
            confirmBtn.textContent = 'SELECT A SKILL';
            confirmBtn.onclick = confirmSkillChoice;

            modal.classList.add('visible');
        }

        let selectedSkillKey = null;

        function selectSkillCard(skillKey) {
            selectedSkillKey = skillKey;

            // Update visual selection
            document.querySelectorAll('.skill-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.skill === skillKey);
            });

            // Directly confirm the skill choice (no button needed)
            confirmSkillChoice();
        }

        function confirmSkillChoice() {
            if (!selectedSkillKey || !skillChoiceAnt) return;

            const skill = ANT_SKILLS[selectedSkillKey];

            // Assign skill to the appropriate slot
            if (currentSkillSlot === 1) {
                skillChoiceAnt.chosenSkill = skill;
                skillChoiceAnt.skillKey = selectedSkillKey;
                skillChoiceAnt.lastSkillUse = 0;
            } else {
                skillChoiceAnt.chosenSkill2 = skill;
                skillChoiceAnt.skillKey2 = selectedSkillKey;
                skillChoiceAnt.lastSkillUse2 = 0;
            }

            // Recalculate stats in case the new skill affects them (like Pathfinder, Heavy Lifter)
            skillChoiceAnt.recalculateStats();

            // Add to skilled ants list
            if (!skilledAnts.includes(skillChoiceAnt)) {
                skilledAnts.push(skillChoiceAnt);
            }

            // Show skill learned effect
            spawnFloatingText(skillChoiceAnt.x, skillChoiceAnt.y - 30,
                `${skill.icon} ${skill.name}!`,
                skill.color, 16);

            // Close modal
            closeSkillModal();

            // Update UI
            updateSkilledAntsPanel();
        }

        function closeSkillModal() {
            const modal = document.getElementById('skill-modal');
            modal.classList.remove('visible');

            skillChoiceModalOpen = false;
            selectedSkillKey = null;

            // Remove from queue (find by ant reference)
            const idx = pendingSkillChoices.findIndex(p => p.ant === skillChoiceAnt);
            if (idx > -1) pendingSkillChoices.splice(idx, 1);
            skillChoiceAnt = null;

            // Resume game if no other modals
            if (!harvestModalOpen && !upgradesPaused && pendingSkillChoices.length === 0) {
                if (pauseStartTime !== null) {
                    pausedTime += Date.now() - pauseStartTime;
                    pauseStartTime = null;
                }
            }

            // Show next skill choice if any
            if (pendingSkillChoices.length > 0) {
                setTimeout(showNextSkillChoice, 300);
            }
        }

        // Track which ants have buttons in the panel (to avoid recreating every frame)
        let skilledAntButtonsMap = new Map();  // antId -> { btn, cooldownEl }

        function updateSkilledAntsPanel() {
            const panel = document.getElementById('skilled-ants-panel');

            // Clean up dead ants from the list
            skilledAnts = skilledAnts.filter(ant => ants.includes(ant));

            // Remove buttons for ants no longer in skilledAnts
            const currentAntIds = new Set(skilledAnts.map(a => a.id));
            for (const [antId, data] of skilledAntButtonsMap) {
                if (!currentAntIds.has(antId)) {
                    data.btn.remove();
                    skilledAntButtonsMap.delete(antId);
                }
            }

            for (const ant of skilledAnts) {
                const skill = ant.chosenSkill;
                const now = Date.now();
                const cooldownRemaining = Math.max(0, (ant.lastSkillUse + skill.cooldown) - now);
                const isReady = cooldownRemaining === 0 || skill.type === 'passive';
                const cooldownText = skill.type === 'active' ? `${skill.cooldown / 1000}s cooldown` : 'Passive';

                // Check if button already exists for this ant
                let data = skilledAntButtonsMap.get(ant.id);

                if (!data) {
                    // Create new button for this ant
                    const btn = document.createElement('div');
                    btn.className = 'skilled-ant-btn';
                    btn.dataset.antId = ant.id;

                    btn.innerHTML = `
                        <span class="skilled-ant-icon">${skill.icon}</span>
                        <div class="skilled-ant-info">
                            <div class="skilled-ant-name">${ant.name}</div>
                            <div class="skilled-ant-skill">${skill.name}</div>
                        </div>
                        ${skill.type === 'active' ? `
                            <div class="skilled-ant-cooldown ${isReady ? 'ready' : ''}" data-cooldown>
                                ${isReady ? '' : Math.ceil(cooldownRemaining / 1000)}
                            </div>
                        ` : ''}
                        <div class="ability-tooltip" style="right: 100%; left: auto; transform: translateX(-10px) translateY(5px);">
                            <div class="ability-tooltip-header">
                                <span class="ability-tooltip-icon">${skill.icon}</span>
                                <div class="ability-tooltip-title">
                                    <div class="ability-tooltip-name">${skill.name}</div>
                                    <div class="ability-tooltip-type">${skill.type === 'active' ? 'Active Ability' : 'Passive Ability'}</div>
                                </div>
                            </div>
                            <div class="ability-tooltip-desc">${skill.description}</div>
                            <div class="ability-tooltip-meta">
                                <span class="ability-tooltip-cooldown">${cooldownText}</span>
                                <span>${ant.name} Lv.${ant.getLevel()}</span>
                            </div>
                        </div>
                    `;

                    // Click to select/focus on ant and show card
                    const antId = ant.id;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();

                        const clickedAnt = ants.find(a => a.id === antId);
                        if (clickedAnt) {
                            selectedAnt = clickedAnt;
                            showCharacterCard(generateAntCardData(clickedAnt), clickedAnt);
                        }
                    });

                    panel.appendChild(btn);
                    const cooldownEl = btn.querySelector('[data-cooldown]');
                    skilledAntButtonsMap.set(ant.id, { btn, cooldownEl });
                    data = { btn, cooldownEl };
                }

                // Only update the cooldown display (not the entire innerHTML)
                if (data.cooldownEl && skill.type === 'active') {
                    const newText = isReady ? '' : Math.ceil(cooldownRemaining / 1000);
                    if (data.cooldownEl.textContent !== String(newText)) {
                        data.cooldownEl.textContent = newText;
                    }
                    data.cooldownEl.className = `skilled-ant-cooldown ${isReady ? 'ready' : ''}`;
                }
            }
        }

        // ===========================================
        // POUNCE ANIMATION EFFECTS
        // ===========================================

        let pounceEffects = [];

        function spawnPounceEffect(startX, startY, endX, endY, ant) {
            pounceEffects.push({
                ant: ant,
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY,
                progress: 0,
                life: 20,  // frames
                particles: []
            });
        }

        function updatePounceEffects() {
            for (let i = pounceEffects.length - 1; i >= 0; i--) {
                const pe = pounceEffects[i];
                pe.life--;
                pe.progress = Math.min(1, pe.progress + 0.12);

                // Add dust particles at landing
                if (pe.progress >= 0.9 && pe.particles.length === 0) {
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        pe.particles.push({
                            x: pe.endX,
                            y: pe.endY,
                            vx: Math.cos(angle) * (2 + Math.random() * 2),
                            vy: Math.sin(angle) * (2 + Math.random() * 2),
                            size: 4 + Math.random() * 4,
                            alpha: 1
                        });
                    }
                }

                // Update dust particles
                for (const p of pe.particles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.9;
                    p.vy *= 0.9;
                    p.alpha *= 0.9;
                    p.size *= 0.95;
                }

                if (pe.life <= 0) {
                    pounceEffects.splice(i, 1);
                }
            }
        }

        function drawPounceEffects() {
            ctx.save();
            for (const pe of pounceEffects) {
                // Draw arc trajectory line
                const midX = (pe.startX + pe.endX) / 2;
                const midY = Math.min(pe.startY, pe.endY) - 40;  // Arc peak

                ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(pe.startX, pe.startY);
                ctx.quadraticCurveTo(midX, midY, pe.endX, pe.endY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw landing impact circle
                if (pe.progress >= 0.8) {
                    const impactProgress = (pe.progress - 0.8) / 0.2;
                    ctx.strokeStyle = `rgba(255, 100, 100, ${0.6 * (1 - impactProgress)})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(pe.endX, pe.endY, 20 + impactProgress * 30, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw dust particles
                for (const p of pe.particles) {
                    ctx.fillStyle = `rgba(180, 150, 120, ${p.alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // ===========================================
        // GOLD BURST EFFECT (for Gold Rush skill)
        // ===========================================

        let goldBurstEffects = [];

        function spawnGoldBurst(x, y, amount) {
            const particles = [];
            const coinCount = Math.min(amount, 8);

            for (let i = 0; i < coinCount; i++) {
                const angle = (i / coinCount) * Math.PI * 2 + Math.random() * 0.5;
                particles.push({
                    x: 0,
                    y: 0,
                    vx: Math.cos(angle) * (3 + Math.random() * 3),
                    vy: Math.sin(angle) * (3 + Math.random() * 3) - 4,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.3
                });
            }

            goldBurstEffects.push({
                x: x,
                y: y,
                amount: amount,
                particles: particles,
                life: 45,
                maxLife: 45
            });
        }

        function updateGoldBurstEffects() {
            for (let i = goldBurstEffects.length - 1; i >= 0; i--) {
                const ge = goldBurstEffects[i];
                ge.life--;

                for (const p of ge.particles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.3;  // Gravity
                    p.vx *= 0.98;
                    p.rotation += p.rotSpeed;
                }

                if (ge.life <= 0) {
                    goldBurstEffects.splice(i, 1);
                }
            }
        }

        function drawGoldBurstEffects() {
            ctx.save();
            for (const ge of goldBurstEffects) {
                const alpha = ge.life / ge.maxLife;

                for (const p of ge.particles) {
                    ctx.save();
                    ctx.translate(ge.x + p.x, ge.y + p.y);
                    ctx.rotate(p.rotation);
                    ctx.globalAlpha = alpha;

                    // Draw coin
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#b8860b';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Shine
                    ctx.fillStyle = '#fff8dc';
                    ctx.beginPath();
                    ctx.ellipse(-2, -1, 2, 1, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
            }
            ctx.restore();
        }

        // ===========================================
        // SHOCKWAVE EFFECT (for Shockwave skill)
        // ===========================================

        let shockwaveEffects = [];

        function spawnShockwaveEffect(x, y, radius = 100) {
            // Scale rings based on the effect radius
            shockwaveEffects.push({
                x: x,
                y: y,
                life: 45,
                maxLife: 45,
                effectRadius: radius,
                rings: [
                    { radius: 0, targetRadius: radius, delay: 0 },
                    { radius: 0, targetRadius: radius * 0.8, delay: 5 },
                    { radius: 0, targetRadius: radius * 0.6, delay: 10 }
                ],
                sparks: Array.from({ length: 16 }, (_, i) => ({
                    angle: (i / 16) * Math.PI * 2,
                    dist: 0,
                    speed: (4 + Math.random() * 3) * (radius / 100),  // Scale spark speed with radius
                    size: 3 + Math.random() * 3
                }))
            });
        }

        function updateShockwaveEffects() {
            for (let i = shockwaveEffects.length - 1; i >= 0; i--) {
                const se = shockwaveEffects[i];
                se.life--;
                const elapsed = se.maxLife - se.life;

                // Expand rings
                for (const ring of se.rings) {
                    if (elapsed > ring.delay) {
                        ring.radius += (ring.targetRadius - ring.radius) * 0.15;
                    }
                }

                // Move sparks outward
                for (const spark of se.sparks) {
                    spark.dist += spark.speed;
                    spark.speed *= 0.92;
                }

                if (se.life <= 0) {
                    shockwaveEffects.splice(i, 1);
                }
            }
        }

        function drawShockwaveEffects() {
            ctx.save();
            for (const se of shockwaveEffects) {
                const alpha = se.life / se.maxLife;
                const elapsed = se.maxLife - se.life;

                // Draw expanding electric rings
                for (let r = 0; r < se.rings.length; r++) {
                    const ring = se.rings[r];
                    if (elapsed <= ring.delay) continue;

                    const ringAlpha = alpha * (1 - r * 0.2);
                    ctx.strokeStyle = `rgba(0, 212, 255, ${ringAlpha * 0.8})`;
                    ctx.lineWidth = 4 - r;
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 15;

                    // Draw jagged electric ring
                    ctx.beginPath();
                    const segments = 24;
                    for (let j = 0; j <= segments; j++) {
                        const a = (j / segments) * Math.PI * 2;
                        const jitter = (Math.random() - 0.5) * 8;
                        const px = se.x + Math.cos(a) * (ring.radius + jitter);
                        const py = se.y + Math.sin(a) * (ring.radius + jitter);
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }

                // Draw electric sparks
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 10;
                for (const spark of se.sparks) {
                    const px = se.x + Math.cos(spark.angle) * spark.dist;
                    const py = se.y + Math.sin(spark.angle) * spark.dist;
                    ctx.beginPath();
                    ctx.arc(px, py, spark.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Center flash
                if (elapsed < 10) {
                    const flashAlpha = 1 - (elapsed / 10);
                    ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(se.x, se.y, 30 * flashAlpha, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // RALLY CRY EFFECT (for Rally Cry skill)
        // ===========================================

        let rallyCryEffects = [];

        function spawnRallyCryEffect(x, y, radius = 120) {
            // Scale waves and notes based on the effect radius
            rallyCryEffects.push({
                x: x,
                y: y,
                life: 50,
                maxLife: 50,
                effectRadius: radius,
                waves: [
                    { radius: 0, maxRadius: radius, delay: 0 },
                    { radius: 0, maxRadius: radius * 0.83, delay: 8 },
                    { radius: 0, maxRadius: radius * 0.67, delay: 16 }
                ],
                notes: Array.from({ length: 8 }, (_, i) => ({
                    angle: (i / 8) * Math.PI * 2 + Math.random() * 0.5,
                    dist: 20,
                    targetDist: (radius * 0.83) + Math.random() * (radius * 0.33),  // Scale note distance
                    size: 6 + Math.random() * 4,
                    rotation: Math.random() * Math.PI * 2
                }))
            });
        }

        function updateRallyCryEffects() {
            for (let i = rallyCryEffects.length - 1; i >= 0; i--) {
                const re = rallyCryEffects[i];
                re.life--;

                // Expand waves
                const elapsed = re.maxLife - re.life;
                for (const wave of re.waves) {
                    if (elapsed > wave.delay) {
                        wave.radius += (wave.maxRadius - wave.radius) * 0.12;
                    }
                }

                // Move music notes outward
                for (const note of re.notes) {
                    note.dist += (note.targetDist - note.dist) * 0.08;
                    note.rotation += 0.05;
                }

                if (re.life <= 0) {
                    rallyCryEffects.splice(i, 1);
                }
            }
        }

        function drawRallyCryEffects() {
            ctx.save();
            for (const re of rallyCryEffects) {
                const alpha = re.life / re.maxLife;
                const elapsed = re.maxLife - re.life;

                // Draw golden waves
                for (let w = 0; w < re.waves.length; w++) {
                    const wave = re.waves[w];
                    if (elapsed <= wave.delay) continue;

                    const waveAlpha = alpha * (1 - w * 0.25);
                    ctx.strokeStyle = `rgba(241, 196, 15, ${waveAlpha * 0.6})`;
                    ctx.lineWidth = 3 - w;
                    ctx.shadowColor = '#f1c40f';
                    ctx.shadowBlur = 12;

                    ctx.beginPath();
                    ctx.arc(re.x, re.y, wave.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw musical notes
                ctx.fillStyle = `rgba(241, 196, 15, ${alpha})`;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#f1c40f';
                ctx.shadowBlur = 8;
                const noteChars = ['', '', '', ''];
                for (let n = 0; n < re.notes.length; n++) {
                    const note = re.notes[n];
                    const px = re.x + Math.cos(note.angle) * note.dist;
                    const py = re.y + Math.sin(note.angle) * note.dist;
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(Math.sin(note.rotation) * 0.3);
                    ctx.fillText(noteChars[n % noteChars.length], 0, 0);
                    ctx.restore();
                }

                // Center burst
                if (elapsed < 15) {
                    const burstAlpha = 1 - (elapsed / 15);
                    ctx.fillStyle = `rgba(255, 215, 0, ${burstAlpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(re.x, re.y, 25 * burstAlpha + 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // VAMPIRE BITE EFFECT
        // ===========================================

        let vampireBiteEffects = [];

        function spawnVampireBiteEffect(antX, antY, predatorX, predatorY) {
            vampireBiteEffects.push({
                antX: antX,
                antY: antY,
                predatorX: predatorX,
                predatorY: predatorY,
                life: 40,
                maxLife: 40,
                bloodDrops: Array.from({ length: 8 }, () => ({
                    progress: 0,
                    offsetX: (Math.random() - 0.5) * 20,
                    offsetY: (Math.random() - 0.5) * 20,
                    size: 3 + Math.random() * 3
                }))
            });
        }

        function updateVampireBiteEffects() {
            for (let i = vampireBiteEffects.length - 1; i >= 0; i--) {
                const ve = vampireBiteEffects[i];
                ve.life--;

                // Move blood drops from predator to ant
                for (const drop of ve.bloodDrops) {
                    drop.progress += 0.06;
                }

                if (ve.life <= 0) {
                    vampireBiteEffects.splice(i, 1);
                }
            }
        }

        function drawVampireBiteEffects() {
            ctx.save();
            for (const ve of vampireBiteEffects) {
                const alpha = ve.life / ve.maxLife;

                // Draw blood drops flowing from predator to ant
                for (const drop of ve.bloodDrops) {
                    if (drop.progress > 1) continue;
                    const t = Math.min(1, drop.progress);

                    // Curved path
                    const midX = (ve.predatorX + ve.antX) / 2 + drop.offsetX;
                    const midY = (ve.predatorY + ve.antY) / 2 - 30 + drop.offsetY;

                    // Quadratic bezier position
                    const x = (1 - t) * (1 - t) * ve.predatorX + 2 * (1 - t) * t * midX + t * t * ve.antX;
                    const y = (1 - t) * (1 - t) * ve.predatorY + 2 * (1 - t) * t * midY + t * t * ve.antY;

                    // Draw blood drop with glow
                    ctx.shadowColor = '#9b59b6';
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = `rgba(155, 89, 182, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.arc(x, y, drop.size * (1 - t * 0.5), 0, Math.PI * 2);
                    ctx.fill();

                    // Inner glow
                    ctx.fillStyle = `rgba(230, 126, 230, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(x, y, drop.size * 0.5 * (1 - t * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Healing aura on ant
                const healPulse = Math.sin((ve.maxLife - ve.life) * 0.3) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(155, 89, 182, ${alpha * healPulse * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ve.antX, ve.antY, 20 + (1 - alpha) * 15, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // BERSERKER RAGE EFFECT (visual indicator)
        // ===========================================

        let berserkerEffects = [];

        function spawnBerserkerEffect(x, y) {
            berserkerEffects.push({
                x: x,
                y: y,
                life: 30,
                maxLife: 30,
                flames: Array.from({ length: 6 }, (_, i) => ({
                    angle: (i / 6) * Math.PI * 2,
                    height: 15 + Math.random() * 10,
                    phase: Math.random() * Math.PI * 2
                }))
            });
        }

        function updateBerserkerEffects() {
            for (let i = berserkerEffects.length - 1; i >= 0; i--) {
                const be = berserkerEffects[i];
                be.life--;
                if (be.life <= 0) {
                    berserkerEffects.splice(i, 1);
                }
            }
        }

        function drawBerserkerEffects() {
            ctx.save();
            for (const be of berserkerEffects) {
                const alpha = be.life / be.maxLife;
                const time = Date.now() / 100;

                // Draw flame particles around ant
                for (const flame of be.flames) {
                    const flicker = Math.sin(time + flame.phase) * 0.3 + 0.7;
                    const h = flame.height * flicker * alpha;

                    const baseX = be.x + Math.cos(flame.angle) * 12;
                    const baseY = be.y + Math.sin(flame.angle) * 12;

                    // Flame gradient
                    const gradient = ctx.createRadialGradient(baseX, baseY - h / 2, 0, baseX, baseY - h / 2, h);
                    gradient.addColorStop(0, `rgba(255, 255, 100, ${alpha * 0.8})`);
                    gradient.addColorStop(0.3, `rgba(255, 100, 50, ${alpha * 0.6})`);
                    gradient.addColorStop(1, `rgba(255, 50, 50, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(baseX - 5, baseY);
                    ctx.quadraticCurveTo(baseX - 3, baseY - h / 2, baseX, baseY - h);
                    ctx.quadraticCurveTo(baseX + 3, baseY - h / 2, baseX + 5, baseY);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // ===========================================
        // SECOND WIND PHOENIX REVIVAL EFFECT
        // ===========================================

        let secondWindEffects = [];

        function spawnSecondWindEffect(x, y) {
            const feathers = [];
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                feathers.push({
                    x: 0, y: 0,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 3,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.3,
                    size: 4 + Math.random() * 6,
                    hue: 20 + Math.random() * 30  // Orange to yellow
                });
            }
            secondWindEffects.push({
                x, y,
                life: 60,
                maxLife: 60,
                feathers,
                ringRadius: 0,
                burstPhase: 0
            });
        }

        function updateSecondWindEffects() {
            for (let i = secondWindEffects.length - 1; i >= 0; i--) {
                const se = secondWindEffects[i];
                se.life--;
                se.burstPhase += 0.15;
                se.ringRadius += (50 - se.ringRadius) * 0.1;

                for (const f of se.feathers) {
                    f.x += f.vx;
                    f.y += f.vy;
                    f.vy += 0.15;  // Gravity
                    f.vx *= 0.98;
                    f.rotation += f.rotSpeed;
                }

                if (se.life <= 0) secondWindEffects.splice(i, 1);
            }
        }

        function drawSecondWindEffects() {
            ctx.save();
            for (const se of secondWindEffects) {
                const alpha = se.life / se.maxLife;
                const elapsed = se.maxLife - se.life;

                // Phoenix ring burst
                if (elapsed < 30) {
                    const ringAlpha = (1 - elapsed / 30) * 0.8;
                    const gradient = ctx.createRadialGradient(se.x, se.y, 0, se.x, se.y, se.ringRadius);
                    gradient.addColorStop(0, `rgba(255, 200, 50, 0)`);
                    gradient.addColorStop(0.7, `rgba(255, 150, 50, ${ringAlpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(255, 80, 30, ${ringAlpha})`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(se.x, se.y, se.ringRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Central phoenix fire
                ctx.shadowColor = '#ff9f43';
                ctx.shadowBlur = 20;
                for (let i = 0; i < 5; i++) {
                    const flameAngle = (i / 5) * Math.PI * 2 + se.burstPhase;
                    const flameLen = 20 + Math.sin(se.burstPhase * 2 + i) * 8;
                    const fx = se.x + Math.cos(flameAngle) * 8;
                    const fy = se.y + Math.sin(flameAngle) * 8;

                    const flameGrad = ctx.createRadialGradient(fx, fy - flameLen/2, 0, fx, fy - flameLen/2, flameLen);
                    flameGrad.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
                    flameGrad.addColorStop(0.4, `rgba(255, 180, 50, ${alpha * 0.8})`);
                    flameGrad.addColorStop(1, `rgba(255, 80, 20, 0)`);
                    ctx.fillStyle = flameGrad;
                    ctx.beginPath();
                    ctx.moveTo(fx - 6, fy);
                    ctx.quadraticCurveTo(fx - 4, fy - flameLen/2, fx, fy - flameLen);
                    ctx.quadraticCurveTo(fx + 4, fy - flameLen/2, fx + 6, fy);
                    ctx.closePath();
                    ctx.fill();
                }

                // Floating feathers
                for (const f of se.feathers) {
                    ctx.save();
                    ctx.translate(se.x + f.x, se.y + f.y);
                    ctx.rotate(f.rotation);
                    ctx.fillStyle = `hsla(${f.hue}, 100%, 60%, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, f.size, f.size / 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // SCAVENGER XP SPARKLE EFFECT
        // ===========================================

        let scavengerEffects = [];

        function spawnScavengerEffect(x, y) {
            const sparkles = [];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                sparkles.push({
                    angle,
                    dist: 5,
                    targetDist: 25 + Math.random() * 15,
                    size: 3 + Math.random() * 3,
                    phase: Math.random() * Math.PI * 2
                });
            }
            scavengerEffects.push({
                x, y, life: 40, maxLife: 40, sparkles
            });
        }

        function updateScavengerEffects() {
            for (let i = scavengerEffects.length - 1; i >= 0; i--) {
                const se = scavengerEffects[i];
                se.life--;
                for (const s of se.sparkles) {
                    s.dist += (s.targetDist - s.dist) * 0.12;
                    s.phase += 0.2;
                }
                if (se.life <= 0) scavengerEffects.splice(i, 1);
            }
        }

        function drawScavengerEffects() {
            ctx.save();
            for (const se of scavengerEffects) {
                const alpha = se.life / se.maxLife;
                ctx.shadowColor = '#a0d468';
                ctx.shadowBlur = 8;

                for (const s of se.sparkles) {
                    const px = se.x + Math.cos(s.angle) * s.dist;
                    const py = se.y + Math.sin(s.angle) * s.dist;
                    const twinkle = Math.sin(s.phase) * 0.5 + 0.5;

                    // Star shape
                    ctx.fillStyle = `rgba(160, 212, 104, ${alpha * twinkle})`;
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const a = (i / 4) * Math.PI * 2 + s.phase * 0.1;
                        const r = i % 2 === 0 ? s.size : s.size * 0.4;
                        const sx = px + Math.cos(a) * r;
                        const sy = py + Math.sin(a) * r;
                        if (i === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // HEAVY LIFTER STRENGTH AURA EFFECT
        // ===========================================

        let heavyLifterEffects = [];

        function spawnHeavyLifterEffect(x, y) {
            heavyLifterEffects.push({
                x, y, life: 35, maxLife: 35,
                rings: [
                    { radius: 0, maxRadius: 30, delay: 0 },
                    { radius: 0, maxRadius: 25, delay: 5 }
                ],
                muscles: Array.from({ length: 4 }, (_, i) => ({
                    angle: (i / 4) * Math.PI * 2,
                    scale: 0
                }))
            });
        }

        function updateHeavyLifterEffects() {
            for (let i = heavyLifterEffects.length - 1; i >= 0; i--) {
                const he = heavyLifterEffects[i];
                he.life--;
                const elapsed = he.maxLife - he.life;

                for (const r of he.rings) {
                    if (elapsed > r.delay) {
                        r.radius += (r.maxRadius - r.radius) * 0.15;
                    }
                }
                for (const m of he.muscles) {
                    m.scale += (1 - m.scale) * 0.1;
                }

                if (he.life <= 0) heavyLifterEffects.splice(i, 1);
            }
        }

        function drawHeavyLifterEffects() {
            ctx.save();
            for (const he of heavyLifterEffects) {
                const alpha = he.life / he.maxLife;
                const elapsed = he.maxLife - he.life;

                // Power rings
                for (let r = 0; r < he.rings.length; r++) {
                    const ring = he.rings[r];
                    if (elapsed <= ring.delay) continue;
                    ctx.strokeStyle = `rgba(150, 122, 220, ${alpha * (1 - r * 0.3)})`;
                    ctx.lineWidth = 4 - r * 2;
                    ctx.beginPath();
                    ctx.arc(he.x, he.y, ring.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Flexing muscle symbols
                ctx.fillStyle = `rgba(150, 122, 220, ${alpha})`;
                ctx.font = `bold ${14}px Arial`;
                ctx.textAlign = 'center';
                for (const m of he.muscles) {
                    const px = he.x + Math.cos(m.angle) * 25 * m.scale;
                    const py = he.y + Math.sin(m.angle) * 25 * m.scale;
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.scale(m.scale, m.scale);
                    ctx.fillText('', 0, 5);
                    ctx.restore();
                }
            }
            ctx.restore();
        }

        // ===========================================
        // PATHFINDER COMPASS PULSE EFFECT
        // ===========================================

        let pathfinderEffects = [];

        function spawnPathfinderEffect(x, y) {
            pathfinderEffects.push({
                x, y, life: 45, maxLife: 45,
                compassRotation: 0,
                pulseRadius: 0,
                trailParticles: []
            });
        }

        function updatePathfinderEffects() {
            for (let i = pathfinderEffects.length - 1; i >= 0; i--) {
                const pe = pathfinderEffects[i];
                pe.life--;
                pe.compassRotation += 0.15;
                pe.pulseRadius += (60 - pe.pulseRadius) * 0.08;

                // Add trail particles
                if (pe.life > 20 && pe.life % 3 === 0) {
                    const angle = Math.random() * Math.PI * 2;
                    pe.trailParticles.push({
                        x: Math.cos(angle) * 20,
                        y: Math.sin(angle) * 20,
                        vx: Math.cos(angle) * 1.5,
                        vy: Math.sin(angle) * 1.5,
                        alpha: 1, size: 3 + Math.random() * 2
                    });
                }

                for (const p of pe.trailParticles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.alpha *= 0.92;
                }
                pe.trailParticles = pe.trailParticles.filter(p => p.alpha > 0.1);

                if (pe.life <= 0) pathfinderEffects.splice(i, 1);
            }
        }

        function drawPathfinderEffects() {
            ctx.save();
            for (const pe of pathfinderEffects) {
                const alpha = pe.life / pe.maxLife;

                // Pulse ring
                ctx.strokeStyle = `rgba(55, 188, 155, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pe.x, pe.y, pe.pulseRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Compass needle
                ctx.save();
                ctx.translate(pe.x, pe.y);
                ctx.rotate(pe.compassRotation);
                ctx.shadowColor = '#37bc9b';
                ctx.shadowBlur = 10;

                // North pointer (red)
                ctx.fillStyle = `rgba(220, 80, 80, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(-5, 0);
                ctx.lineTo(5, 0);
                ctx.closePath();
                ctx.fill();

                // South pointer (white)
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(-5, 0);
                ctx.lineTo(5, 0);
                ctx.closePath();
                ctx.fill();

                ctx.restore();

                // Trail particles
                for (const p of pe.trailParticles) {
                    ctx.fillStyle = `rgba(55, 188, 155, ${p.alpha * alpha})`;
                    ctx.beginPath();
                    ctx.arc(pe.x + p.x, pe.y + p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // MOMENTUM SPEED STREAK EFFECT
        // ===========================================

        let momentumEffects = [];

        function spawnMomentumEffect(x, y, stacks) {
            const streaks = [];
            for (let i = 0; i < Math.min(stacks, 10); i++) {
                streaks.push({
                    offsetY: (Math.random() - 0.5) * 20,
                    length: 20 + Math.random() * 15,
                    alpha: 0.5 + Math.random() * 0.5
                });
            }
            momentumEffects.push({
                x, y, life: 25, maxLife: 25, streaks, stacks
            });
        }

        function updateMomentumEffects() {
            for (let i = momentumEffects.length - 1; i >= 0; i--) {
                const me = momentumEffects[i];
                me.life--;
                for (const s of me.streaks) {
                    s.length *= 1.05;  // Streaks extend
                }
                if (me.life <= 0) momentumEffects.splice(i, 1);
            }
        }

        function drawMomentumEffects() {
            ctx.save();
            for (const me of momentumEffects) {
                const alpha = me.life / me.maxLife;

                // Speed streaks behind ant
                for (const s of me.streaks) {
                    const gradient = ctx.createLinearGradient(
                        me.x - s.length, me.y + s.offsetY,
                        me.x, me.y + s.offsetY
                    );
                    gradient.addColorStop(0, `rgba(79, 193, 233, 0)`);
                    gradient.addColorStop(1, `rgba(79, 193, 233, ${alpha * s.alpha})`);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(me.x - s.length, me.y + s.offsetY);
                    ctx.lineTo(me.x, me.y + s.offsetY);
                    ctx.stroke();
                }

                // Stack counter
                ctx.fillStyle = `rgba(79, 193, 233, ${alpha})`;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`x${me.stacks}`, me.x, me.y - 20);
            }
            ctx.restore();
        }

        // ===========================================
        // BLOODLUST CRIMSON AURA EFFECT
        // ===========================================

        let bloodlustEffects = [];

        function spawnBloodlustEffect(x, y, stacks) {
            const droplets = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                droplets.push({
                    angle,
                    dist: 5,
                    targetDist: 20 + Math.random() * 10,
                    size: 3 + Math.random() * 2,
                    drip: 0
                });
            }
            bloodlustEffects.push({
                x, y, life: 40, maxLife: 40, droplets, stacks,
                pulsePhase: 0
            });
        }

        function updateBloodlustEffects() {
            for (let i = bloodlustEffects.length - 1; i >= 0; i--) {
                const be = bloodlustEffects[i];
                be.life--;
                be.pulsePhase += 0.2;
                for (const d of be.droplets) {
                    d.dist += (d.targetDist - d.dist) * 0.1;
                    d.drip += 0.5;
                }
                if (be.life <= 0) bloodlustEffects.splice(i, 1);
            }
        }

        function drawBloodlustEffects() {
            ctx.save();
            for (const be of bloodlustEffects) {
                const alpha = be.life / be.maxLife;
                const pulse = Math.sin(be.pulsePhase) * 0.3 + 0.7;

                // Crimson aura
                const gradient = ctx.createRadialGradient(be.x, be.y, 0, be.x, be.y, 30);
                gradient.addColorStop(0, `rgba(218, 68, 83, ${alpha * pulse * 0.3})`);
                gradient.addColorStop(1, `rgba(218, 68, 83, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(be.x, be.y, 30, 0, Math.PI * 2);
                ctx.fill();

                // Blood droplets
                ctx.fillStyle = `rgba(218, 68, 83, ${alpha})`;
                for (const d of be.droplets) {
                    const px = be.x + Math.cos(d.angle) * d.dist;
                    const py = be.y + Math.sin(d.angle) * d.dist + d.drip * 0.5;

                    // Teardrop shape
                    ctx.beginPath();
                    ctx.moveTo(px, py - d.size);
                    ctx.quadraticCurveTo(px + d.size, py, px, py + d.size);
                    ctx.quadraticCurveTo(px - d.size, py, px, py - d.size);
                    ctx.fill();
                }

                // Stack counter
                ctx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#da4453';
                ctx.shadowBlur = 5;
                ctx.fillText(`+${be.stacks} ATK`, be.x, be.y - 25);
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // ADRENALINE LIGHTNING SURGE EFFECT
        // ===========================================

        let adrenalineEffects = [];

        function spawnAdrenalineEffect(x, y) {
            const bolts = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                bolts.push({
                    angle,
                    segments: Array.from({ length: 5 }, (_, j) => ({
                        offset: (Math.random() - 0.5) * 15
                    }))
                });
            }
            adrenalineEffects.push({
                x, y, life: 35, maxLife: 35, bolts,
                coreSize: 0, flashIntensity: 1
            });
        }

        function updateAdrenalineEffects() {
            for (let i = adrenalineEffects.length - 1; i >= 0; i--) {
                const ae = adrenalineEffects[i];
                ae.life--;
                ae.coreSize += (20 - ae.coreSize) * 0.15;
                ae.flashIntensity *= 0.9;

                // Randomize bolt segments for electric effect
                for (const b of ae.bolts) {
                    for (const s of b.segments) {
                        s.offset += (Math.random() - 0.5) * 8;
                        s.offset *= 0.9;
                    }
                }

                if (ae.life <= 0) adrenalineEffects.splice(i, 1);
            }
        }

        function drawAdrenalineEffects() {
            ctx.save();
            for (const ae of adrenalineEffects) {
                const alpha = ae.life / ae.maxLife;

                // Central flash
                if (ae.flashIntensity > 0.1) {
                    ctx.fillStyle = `rgba(255, 255, 200, ${ae.flashIntensity * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(ae.x, ae.y, 40 * ae.flashIntensity, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Yellow electric core
                ctx.shadowColor = '#ffce54';
                ctx.shadowBlur = 15;
                const coreGradient = ctx.createRadialGradient(ae.x, ae.y, 0, ae.x, ae.y, ae.coreSize);
                coreGradient.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
                coreGradient.addColorStop(0.5, `rgba(255, 206, 84, ${alpha * 0.7})`);
                coreGradient.addColorStop(1, `rgba(255, 206, 84, 0)`);
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(ae.x, ae.y, ae.coreSize, 0, Math.PI * 2);
                ctx.fill();

                // Lightning bolts
                ctx.strokeStyle = `rgba(255, 255, 100, ${alpha})`;
                ctx.lineWidth = 2;
                for (const b of ae.bolts) {
                    ctx.beginPath();
                    const boltLen = 40;
                    const segLen = boltLen / b.segments.length;
                    ctx.moveTo(ae.x, ae.y);
                    for (let j = 0; j < b.segments.length; j++) {
                        const dist = (j + 1) * segLen;
                        const px = ae.x + Math.cos(b.angle) * dist + b.segments[j].offset * Math.sin(b.angle);
                        const py = ae.y + Math.sin(b.angle) * dist - b.segments[j].offset * Math.cos(b.angle);
                        ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // DECOY GHOST ANT EFFECT
        // ===========================================

        let decoyEffects = [];
        let decoyAnts = [];  // Active decoy entities

        function spawnDecoyEffect(x, y, angle) {
            decoyEffects.push({
                x, y, life: 30, maxLife: 30,
                shimmerPhase: 0
            });
        }

        function spawnDecoyAnt(x, y, angle) {
            decoyAnts.push({
                x, y, angle,
                life: 300,  // 5 seconds at 60fps
                shimmerPhase: 0,
                wobble: 0
            });
        }

        function updateDecoyEffects() {
            for (let i = decoyEffects.length - 1; i >= 0; i--) {
                const de = decoyEffects[i];
                de.life--;
                de.shimmerPhase += 0.3;
                if (de.life <= 0) decoyEffects.splice(i, 1);
            }
        }

        function updateDecoyAnts() {
            for (let i = decoyAnts.length - 1; i >= 0; i--) {
                const da = decoyAnts[i];
                da.life--;
                da.shimmerPhase += 0.15;
                da.wobble += 0.1;
                // Slight random movement
                da.x += Math.sin(da.wobble) * 0.5;
                da.y += Math.cos(da.wobble * 0.7) * 0.3;
                da.angle += Math.sin(da.wobble * 0.5) * 0.02;

                if (da.life <= 0) decoyAnts.splice(i, 1);
            }
        }

        function drawDecoyEffects() {
            ctx.save();
            for (const de of decoyEffects) {
                const alpha = de.life / de.maxLife;
                const shimmer = Math.sin(de.shimmerPhase) * 0.3 + 0.7;

                // Spawn shimmer effect
                ctx.shadowColor = '#ac92ec';
                ctx.shadowBlur = 15;
                ctx.fillStyle = `rgba(172, 146, 236, ${alpha * shimmer * 0.5})`;
                ctx.beginPath();
                ctx.arc(de.x, de.y, 25 * alpha, 0, Math.PI * 2);
                ctx.fill();

                // Ghost particles
                for (let i = 0; i < 5; i++) {
                    const a = de.shimmerPhase + (i / 5) * Math.PI * 2;
                    const px = de.x + Math.cos(a) * 20 * alpha;
                    const py = de.y + Math.sin(a) * 20 * alpha - (1 - alpha) * 20;
                    ctx.fillStyle = `rgba(200, 180, 255, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        function drawDecoyAnts() {
            ctx.save();
            for (const da of decoyAnts) {
                const alpha = Math.min(1, da.life / 60) * 0.6;  // Fade in/out
                const shimmer = Math.sin(da.shimmerPhase) * 0.2 + 0.8;

                ctx.save();
                ctx.translate(da.x, da.y);
                ctx.rotate(da.angle);
                ctx.globalAlpha = alpha * shimmer;

                // Ghost ant body (semi-transparent purple)
                ctx.shadowColor = '#ac92ec';
                ctx.shadowBlur = 10;

                // Body segments
                ctx.fillStyle = 'rgba(172, 146, 236, 0.7)';
                ctx.beginPath();
                ctx.ellipse(-8, 0, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(0, 0, 6, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(8, 0, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.strokeStyle = 'rgba(172, 146, 236, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const legX = -4 + i * 4;
                    ctx.beginPath();
                    ctx.moveTo(legX, 0);
                    ctx.lineTo(legX - 5, 8);
                    ctx.moveTo(legX, 0);
                    ctx.lineTo(legX + 5, -8);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
                ctx.restore();
            }
            ctx.restore();
        }

        // ===========================================
        // LAST STAND SKULL AURA EFFECT
        // ===========================================

        let lastStandEffects = [];

        function spawnLastStandEffect(x, y) {
            lastStandEffects.push({
                x, y, life: 50, maxLife: 50,
                skullScale: 0,
                auraPhase: 0,
                cracks: Array.from({ length: 6 }, () => ({
                    angle: Math.random() * Math.PI * 2,
                    length: 0,
                    targetLength: 20 + Math.random() * 20
                }))
            });
        }

        function updateLastStandEffects() {
            for (let i = lastStandEffects.length - 1; i >= 0; i--) {
                const le = lastStandEffects[i];
                le.life--;
                le.skullScale += (1 - le.skullScale) * 0.12;
                le.auraPhase += 0.15;

                for (const c of le.cracks) {
                    c.length += (c.targetLength - c.length) * 0.1;
                }

                if (le.life <= 0) lastStandEffects.splice(i, 1);
            }
        }

        function drawLastStandEffects() {
            ctx.save();
            for (const le of lastStandEffects) {
                const alpha = le.life / le.maxLife;
                const pulse = Math.sin(le.auraPhase) * 0.3 + 0.7;

                // Dark aura
                const auraGradient = ctx.createRadialGradient(le.x, le.y, 0, le.x, le.y, 40);
                auraGradient.addColorStop(0, `rgba(50, 50, 60, ${alpha * pulse * 0.4})`);
                auraGradient.addColorStop(1, `rgba(50, 50, 60, 0)`);
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(le.x, le.y, 40, 0, Math.PI * 2);
                ctx.fill();

                // Cracks emanating outward
                ctx.strokeStyle = `rgba(100, 100, 110, ${alpha * 0.7})`;
                ctx.lineWidth = 2;
                for (const c of le.cracks) {
                    ctx.beginPath();
                    ctx.moveTo(le.x, le.y);
                    ctx.lineTo(
                        le.x + Math.cos(c.angle) * c.length,
                        le.y + Math.sin(c.angle) * c.length
                    );
                    ctx.stroke();
                }

                // Skull emoji with scale
                ctx.font = `${20 * le.skullScale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(100, 109, 120, ${alpha})`;
                ctx.shadowColor = '#656d78';
                ctx.shadowBlur = 8;
                ctx.fillText('', le.x, le.y + 8 * le.skullScale);
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // LUCKY CLOVER SHIMMER EFFECT
        // ===========================================

        let luckyEffects = [];

        function spawnLuckyEffect(x, y) {
            const clovers = [];
            for (let i = 0; i < 6; i++) {
                clovers.push({
                    angle: Math.random() * Math.PI * 2,
                    dist: 0,
                    targetDist: 30 + Math.random() * 20,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.2,
                    size: 8 + Math.random() * 4
                });
            }
            luckyEffects.push({
                x, y, life: 45, maxLife: 45, clovers,
                sparkles: []
            });
        }

        function updateLuckyEffects() {
            for (let i = luckyEffects.length - 1; i >= 0; i--) {
                const le = luckyEffects[i];
                le.life--;

                for (const c of le.clovers) {
                    c.dist += (c.targetDist - c.dist) * 0.1;
                    c.rotation += c.rotSpeed;
                }

                // Add sparkles
                if (le.life > 20 && le.life % 4 === 0) {
                    le.sparkles.push({
                        x: (Math.random() - 0.5) * 60,
                        y: (Math.random() - 0.5) * 60,
                        alpha: 1, size: 2 + Math.random() * 2
                    });
                }
                for (const s of le.sparkles) {
                    s.y -= 1;
                    s.alpha *= 0.9;
                }
                le.sparkles = le.sparkles.filter(s => s.alpha > 0.1);

                if (le.life <= 0) luckyEffects.splice(i, 1);
            }
        }

        function drawLuckyEffects() {
            ctx.save();
            for (const le of luckyEffects) {
                const alpha = le.life / le.maxLife;

                // Draw clovers
                ctx.fillStyle = `rgba(140, 193, 82, ${alpha})`;
                for (const c of le.clovers) {
                    const px = le.x + Math.cos(c.angle) * c.dist;
                    const py = le.y + Math.sin(c.angle) * c.dist;
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(c.rotation);
                    ctx.font = `${c.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('', 0, 0);
                    ctx.restore();
                }

                // Draw sparkles
                ctx.fillStyle = `rgba(255, 255, 150, ${alpha})`;
                for (const s of le.sparkles) {
                    ctx.beginPath();
                    ctx.arc(le.x + s.x, le.y + s.y, s.size * s.alpha, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        // ===========================================
        // PACK HUNTER WOLF HOWL EFFECT
        // ===========================================

        let packHunterEffects = [];

        function spawnPackHunterEffect(x, y, allyCount) {
            const waves = [];
            for (let i = 0; i < 3; i++) {
                waves.push({
                    radius: 0,
                    maxRadius: 50 + i * 20,
                    delay: i * 8
                });
            }
            packHunterEffects.push({
                x, y, life: 45, maxLife: 45, waves, allyCount,
                howlPhase: 0
            });
        }

        function updatePackHunterEffects() {
            for (let i = packHunterEffects.length - 1; i >= 0; i--) {
                const pe = packHunterEffects[i];
                pe.life--;
                pe.howlPhase += 0.2;
                const elapsed = pe.maxLife - pe.life;

                for (const w of pe.waves) {
                    if (elapsed > w.delay) {
                        w.radius += (w.maxRadius - w.radius) * 0.12;
                    }
                }

                if (pe.life <= 0) packHunterEffects.splice(i, 1);
            }
        }

        function drawPackHunterEffects() {
            ctx.save();
            for (const pe of packHunterEffects) {
                const alpha = pe.life / pe.maxLife;
                const elapsed = pe.maxLife - pe.life;

                // Blue connection waves
                for (let w = 0; w < pe.waves.length; w++) {
                    const wave = pe.waves[w];
                    if (elapsed <= wave.delay) continue;

                    ctx.strokeStyle = `rgba(93, 156, 236, ${alpha * (1 - w * 0.25)})`;
                    ctx.lineWidth = 3 - w;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(pe.x, pe.y, wave.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Wolf icon with howl effect
                const howlScale = 1 + Math.sin(pe.howlPhase) * 0.15;
                ctx.font = `${16 * howlScale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(93, 156, 236, ${alpha})`;
                ctx.shadowColor = '#5d9cec';
                ctx.shadowBlur = 10;
                ctx.fillText('', pe.x, pe.y + 5);

                // Ally count bonus
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = `rgba(150, 200, 255, ${alpha})`;
                ctx.fillText(`+${pe.allyCount * 25}% ATK`, pe.x, pe.y - 20);
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ===========================================
        // DASH TELEPORT EFFECT
        // ===========================================

        let dashEffects = [];

        function spawnDashEffect(startX, startY, endX, endY) {
            const afterImages = [];
            const dist = Math.hypot(endX - startX, endY - startY);
            const imageCount = Math.min(8, Math.floor(dist / 10));
            for (let i = 0; i < imageCount; i++) {
                const t = i / imageCount;
                afterImages.push({
                    x: startX + (endX - startX) * t,
                    y: startY + (endY - startY) * t,
                    alpha: 1 - t * 0.5,
                    scale: 1 - t * 0.3
                });
            }
            dashEffects.push({
                startX, startY, endX, endY,
                life: 30, maxLife: 30,
                afterImages,
                sparkTrail: [],
                impactRing: 0
            });
        }

        function updateDashEffects() {
            for (let i = dashEffects.length - 1; i >= 0; i--) {
                const de = dashEffects[i];
                de.life--;
                de.impactRing += (40 - de.impactRing) * 0.15;

                // Fade after images
                for (const ai of de.afterImages) {
                    ai.alpha *= 0.85;
                    ai.scale *= 0.95;
                }

                // Add spark trail particles
                if (de.life > 15) {
                    const t = Math.random();
                    de.sparkTrail.push({
                        x: de.startX + (de.endX - de.startX) * t + (Math.random() - 0.5) * 10,
                        y: de.startY + (de.endY - de.startY) * t + (Math.random() - 0.5) * 10,
                        alpha: 1, size: 2 + Math.random() * 2
                    });
                }
                for (const s of de.sparkTrail) {
                    s.alpha *= 0.9;
                }
                de.sparkTrail = de.sparkTrail.filter(s => s.alpha > 0.1);

                if (de.life <= 0) dashEffects.splice(i, 1);
            }
        }

        function drawDashEffects() {
            ctx.save();
            for (const de of dashEffects) {
                const alpha = de.life / de.maxLife;

                // Dash trail line
                const gradient = ctx.createLinearGradient(de.startX, de.startY, de.endX, de.endY);
                gradient.addColorStop(0, `rgba(236, 135, 192, 0)`);
                gradient.addColorStop(0.5, `rgba(236, 135, 192, ${alpha * 0.6})`);
                gradient.addColorStop(1, `rgba(236, 135, 192, ${alpha})`);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(de.startX, de.startY);
                ctx.lineTo(de.endX, de.endY);
                ctx.stroke();

                // After images
                for (const ai of de.afterImages) {
                    ctx.fillStyle = `rgba(236, 135, 192, ${ai.alpha * alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(ai.x, ai.y, 6 * ai.scale, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Spark trail
                ctx.fillStyle = `rgba(255, 200, 230, ${alpha})`;
                for (const s of de.sparkTrail) {
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.size * s.alpha, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Impact ring at destination
                if (de.life < 25) {
                    ctx.strokeStyle = `rgba(236, 135, 192, ${alpha * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(de.endX, de.endY, de.impactRing, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Star burst at end point
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('', de.endX, de.endY + 5);
            }
            ctx.restore();
        }

        // =============================================
        // EARTHQUAKE EFFECT - Ground slam with cracks
        // =============================================
        let earthquakeEffects = [];
        function spawnEarthquakeEffect(x, y, radius = 80) {
            const cracks = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.3;
                const segments = [];
                let px = x, py = y;
                for (let j = 0; j < 5; j++) {
                    const dist = (j + 1) * (radius / 5) * (0.8 + Math.random() * 0.4);
                    const wobble = (Math.random() - 0.5) * 0.4;
                    px = x + Math.cos(angle + wobble) * dist;
                    py = y + Math.sin(angle + wobble) * dist;
                    segments.push({ x: px, y: py });
                }
                cracks.push({ segments, delay: i * 2 });
            }
            const debris = [];
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * radius * 0.8;
                debris.push({
                    x: x + Math.cos(angle) * dist,
                    y: y + Math.sin(angle) * dist,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 6 - 2,
                    size: 3 + Math.random() * 5,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.3
                });
            }
            earthquakeEffects.push({
                x, y, radius,
                cracks, debris,
                life: 60,
                shockwave: 0,
                groundAlpha: 1
            });
        }
        function updateEarthquakeEffects() {
            for (let i = earthquakeEffects.length - 1; i >= 0; i--) {
                const e = earthquakeEffects[i];
                e.life--;
                e.shockwave += 6;
                e.groundAlpha = e.life / 60;
                for (const d of e.debris) {
                    d.x += d.vx;
                    d.y += d.vy;
                    d.vy += 0.3;
                    d.rotation += d.rotSpeed;
                }
                if (e.life <= 0) earthquakeEffects.splice(i, 1);
            }
        }
        function drawEarthquakeEffects() {
            ctx.save();
            for (const e of earthquakeEffects) {
                const alpha = e.groundAlpha;
                // Shockwave ring
                ctx.strokeStyle = `rgba(139, 69, 19, ${alpha * 0.6})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.shockwave, 0, Math.PI * 2);
                ctx.stroke();
                // Ground cracks
                ctx.strokeStyle = `rgba(60, 30, 10, ${alpha})`;
                ctx.lineWidth = 3;
                for (const crack of e.cracks) {
                    if (e.life > 60 - crack.delay) continue;
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y);
                    for (const seg of crack.segments) {
                        ctx.lineTo(seg.x, seg.y);
                    }
                    ctx.stroke();
                }
                // Debris
                ctx.fillStyle = `rgba(101, 67, 33, ${alpha})`;
                for (const d of e.debris) {
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    ctx.rotate(d.rotation);
                    ctx.fillRect(-d.size/2, -d.size/2, d.size, d.size);
                    ctx.restore();
                }
                // Center impact
                ctx.fillStyle = `rgba(139, 69, 19, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 15 * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('', e.x, e.y + 7);
            }
            ctx.restore();
        }

        // =============================================
        // CHAIN LIGHTNING EFFECT - Arcing electricity
        // =============================================
        let chainLightningEffects = [];
        function spawnChainLightningEffect(targets) {
            if (targets.length < 2) return;
            const chains = [];
            for (let i = 0; i < targets.length - 1; i++) {
                const start = targets[i];
                const end = targets[i + 1];
                const bolts = [];
                for (let b = 0; b < 3; b++) {
                    const points = [{ x: start.x, y: start.y }];
                    const segments = 6;
                    for (let j = 1; j < segments; j++) {
                        const t = j / segments;
                        const baseX = start.x + (end.x - start.x) * t;
                        const baseY = start.y + (end.y - start.y) * t;
                        const perpX = -(end.y - start.y);
                        const perpY = end.x - start.x;
                        const len = Math.hypot(perpX, perpY);
                        const offset = (Math.random() - 0.5) * 25;
                        points.push({
                            x: baseX + (perpX / len) * offset,
                            y: baseY + (perpY / len) * offset
                        });
                    }
                    points.push({ x: end.x, y: end.y });
                    bolts.push(points);
                }
                chains.push({ bolts, delay: i * 5 });
            }
            const sparks = [];
            for (const t of targets) {
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    sparks.push({
                        x: t.x, y: t.y,
                        vx: Math.cos(angle) * (2 + Math.random() * 3),
                        vy: Math.sin(angle) * (2 + Math.random() * 3),
                        life: 20 + Math.random() * 20
                    });
                }
            }
            chainLightningEffects.push({
                chains, sparks, targets,
                life: 45,
                flickerTimer: 0
            });
        }
        function updateChainLightningEffects() {
            for (let i = chainLightningEffects.length - 1; i >= 0; i--) {
                const e = chainLightningEffects[i];
                e.life--;
                e.flickerTimer++;
                for (const s of e.sparks) {
                    s.x += s.vx;
                    s.y += s.vy;
                    s.vx *= 0.95;
                    s.vy *= 0.95;
                    s.life--;
                }
                e.sparks = e.sparks.filter(s => s.life > 0);
                if (e.life <= 0) chainLightningEffects.splice(i, 1);
            }
        }
        function drawChainLightningEffects() {
            ctx.save();
            for (const e of chainLightningEffects) {
                const alpha = Math.min(1, e.life / 20);
                const flicker = Math.sin(e.flickerTimer * 0.5) * 0.3 + 0.7;
                // Lightning bolts
                for (const chain of e.chains) {
                    if (e.life > 45 - chain.delay) continue;
                    for (const bolt of chain.bolts) {
                        ctx.strokeStyle = `rgba(0, 191, 255, ${alpha * flicker})`;
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#00bfff';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.moveTo(bolt[0].x, bolt[0].y);
                        for (let i = 1; i < bolt.length; i++) {
                            ctx.lineTo(bolt[i].x, bolt[i].y);
                        }
                        ctx.stroke();
                    }
                    // Bright core
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * flicker * 0.8})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(chain.bolts[0][0].x, chain.bolts[0][0].y);
                    for (let i = 1; i < chain.bolts[0].length; i++) {
                        ctx.lineTo(chain.bolts[0][i].x, chain.bolts[0][i].y);
                    }
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                // Sparks
                ctx.fillStyle = `rgba(135, 206, 250, ${alpha})`;
                for (const s of e.sparks) {
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Impact icons at targets
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                for (const t of e.targets) {
                    ctx.globalAlpha = alpha;
                    ctx.fillText('', t.x, t.y);
                }
            }
            ctx.restore();
        }

        // =============================================
        // VOID RIFT EFFECT - Swirling dark portal
        // =============================================
        let voidRiftEffects = [];
        function spawnVoidRiftEffect(x, y, duration = 240) {
            const particles = [];
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 60 + Math.random() * 40;
                particles.push({
                    angle, dist, startDist: dist,
                    size: 2 + Math.random() * 4,
                    speed: 0.02 + Math.random() * 0.03,
                    pullSpeed: 0.3 + Math.random() * 0.2
                });
            }
            voidRiftEffects.push({
                x, y, particles,
                life: duration,
                maxLife: duration,
                rotation: 0,
                pulsePhase: 0
            });
        }
        function updateVoidRiftEffects() {
            for (let i = voidRiftEffects.length - 1; i >= 0; i--) {
                const e = voidRiftEffects[i];
                e.life--;
                e.rotation += 0.05;
                e.pulsePhase += 0.1;
                for (const p of e.particles) {
                    p.angle += p.speed;
                    p.dist = Math.max(5, p.dist - p.pullSpeed);
                    if (p.dist < 10) {
                        p.dist = p.startDist;
                        p.angle = Math.random() * Math.PI * 2;
                    }
                }
                if (e.life <= 0) voidRiftEffects.splice(i, 1);
            }
        }
        function drawVoidRiftEffects() {
            ctx.save();
            for (const e of voidRiftEffects) {
                const alpha = Math.min(1, e.life / 30, (e.maxLife - e.life) / 30 + 0.3);
                const pulse = Math.sin(e.pulsePhase) * 0.2 + 0.8;
                // Outer glow
                const gradient = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, 60);
                gradient.addColorStop(0, `rgba(74, 0, 128, ${alpha * 0.8})`);
                gradient.addColorStop(0.5, `rgba(74, 0, 128, ${alpha * 0.4})`);
                gradient.addColorStop(1, `rgba(74, 0, 128, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 60, 0, Math.PI * 2);
                ctx.fill();
                // Swirling particles
                for (const p of e.particles) {
                    const px = e.x + Math.cos(p.angle + e.rotation) * p.dist;
                    const py = e.y + Math.sin(p.angle + e.rotation) * p.dist;
                    const distRatio = p.dist / p.startDist;
                    ctx.fillStyle = `rgba(147, 112, 219, ${alpha * distRatio})`;
                    ctx.beginPath();
                    ctx.arc(px, py, p.size * pulse, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Dark center
                ctx.fillStyle = `rgba(20, 0, 40, ${alpha})`;
                ctx.beginPath();
                ctx.arc(e.x, e.y, 15 * pulse, 0, Math.PI * 2);
                ctx.fill();
                // Spiral arms
                ctx.strokeStyle = `rgba(138, 43, 226, ${alpha * 0.6})`;
                ctx.lineWidth = 2;
                for (let arm = 0; arm < 3; arm++) {
                    ctx.beginPath();
                    for (let t = 0; t < 50; t++) {
                        const angle = e.rotation + arm * (Math.PI * 2 / 3) + t * 0.15;
                        const r = 5 + t * 1.2;
                        const px = e.x + Math.cos(angle) * r;
                        const py = e.y + Math.sin(angle) * r;
                        if (t === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = alpha;
                ctx.fillText('', e.x, e.y + 6);
            }
            ctx.restore();
        }

        // =============================================
        // FIRE BREATH EFFECT - Cone of flames
        // =============================================
        let fireBreathEffects = [];
        function spawnFireBreathEffect(x, y, angle, range = 80) {
            const flames = [];
            for (let i = 0; i < 30; i++) {
                const spreadAngle = angle + (Math.random() - 0.5) * 1.0;
                const dist = Math.random() * range;
                flames.push({
                    x: x + Math.cos(spreadAngle) * dist,
                    y: y + Math.sin(spreadAngle) * dist,
                    vx: Math.cos(spreadAngle) * (3 + Math.random() * 2),
                    vy: Math.sin(spreadAngle) * (3 + Math.random() * 2),
                    size: 8 + Math.random() * 12,
                    life: 30 + Math.random() * 20,
                    hue: Math.random() * 40 // 0 = red, 40 = orange
                });
            }
            fireBreathEffects.push({
                x, y, angle, range, flames,
                life: 50,
                coneAlpha: 1
            });
        }
        function updateFireBreathEffects() {
            for (let i = fireBreathEffects.length - 1; i >= 0; i--) {
                const e = fireBreathEffects[i];
                e.life--;
                e.coneAlpha = e.life / 50;
                for (const f of e.flames) {
                    f.x += f.vx;
                    f.y += f.vy;
                    f.vy -= 0.05; // Fire rises
                    f.vx *= 0.98;
                    f.vy *= 0.98;
                    f.size *= 0.97;
                    f.life--;
                }
                e.flames = e.flames.filter(f => f.life > 0 && f.size > 1);
                if (e.life <= 0) fireBreathEffects.splice(i, 1);
            }
        }
        function drawFireBreathEffects() {
            ctx.save();
            for (const e of fireBreathEffects) {
                // Cone shape
                ctx.fillStyle = `rgba(255, 100, 0, ${e.coneAlpha * 0.2})`;
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);
                ctx.arc(e.x, e.y, e.range, e.angle - 0.5, e.angle + 0.5);
                ctx.closePath();
                ctx.fill();
                // Flame particles
                for (const f of e.flames) {
                    const alpha = f.life / 50;
                    const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size);
                    gradient.addColorStop(0, `rgba(255, 255, 100, ${alpha})`);
                    gradient.addColorStop(0.3, `hsla(${f.hue}, 100%, 50%, ${alpha})`);
                    gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Source icon
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = e.coneAlpha;
                ctx.fillText('', e.x, e.y + 5);
            }
            ctx.restore();
        }

        // =============================================
        // ICE NOVA EFFECT - Freezing burst
        // =============================================
        let iceNovaEffects = [];
        function spawnIceNovaEffect(x, y, radius = 100) {
            const icicles = [];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                icicles.push({
                    angle,
                    length: 0,
                    maxLength: radius * (0.7 + Math.random() * 0.3),
                    width: 4 + Math.random() * 4
                });
            }
            const snowflakes = [];
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * radius;
                snowflakes.push({
                    x: x + Math.cos(angle) * dist,
                    y: y + Math.sin(angle) * dist,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.2,
                    size: 8 + Math.random() * 8
                });
            }
            iceNovaEffects.push({
                x, y, radius, icicles, snowflakes,
                life: 60,
                ring: 0
            });
        }
        function updateIceNovaEffects() {
            for (let i = iceNovaEffects.length - 1; i >= 0; i--) {
                const e = iceNovaEffects[i];
                e.life--;
                e.ring += 8;
                for (const ic of e.icicles) {
                    if (ic.length < ic.maxLength) {
                        ic.length += ic.maxLength / 10;
                    }
                }
                for (const sf of e.snowflakes) {
                    sf.x += sf.vx;
                    sf.y += sf.vy;
                    sf.rotation += sf.rotSpeed;
                }
                if (e.life <= 0) iceNovaEffects.splice(i, 1);
            }
        }
        function drawIceNovaEffects() {
            ctx.save();
            for (const e of iceNovaEffects) {
                const alpha = e.life / 60;
                // Expanding ring
                ctx.strokeStyle = `rgba(135, 206, 235, ${alpha * 0.7})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.ring, 0, Math.PI * 2);
                ctx.stroke();
                // Icicles
                ctx.fillStyle = `rgba(173, 216, 230, ${alpha})`;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 1;
                for (const ic of e.icicles) {
                    const endX = e.x + Math.cos(ic.angle) * ic.length;
                    const endY = e.y + Math.sin(ic.angle) * ic.length;
                    const perpAngle = ic.angle + Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(e.x + Math.cos(perpAngle) * ic.width, e.y + Math.sin(perpAngle) * ic.width);
                    ctx.lineTo(endX, endY);
                    ctx.lineTo(e.x - Math.cos(perpAngle) * ic.width, e.y - Math.sin(perpAngle) * ic.width);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                // Snowflakes
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                for (const sf of e.snowflakes) {
                    ctx.save();
                    ctx.translate(sf.x, sf.y);
                    ctx.rotate(sf.rotation);
                    ctx.fillText('', 0, 0);
                    ctx.restore();
                }
                // Center burst
                ctx.font = '24px Arial';
                ctx.globalAlpha = alpha;
                ctx.fillText('', e.x, e.y + 8);
            }
            ctx.restore();
        }

        // =============================================
        // SHADOW STEP EFFECT - Stealth shimmer
        // =============================================
        let shadowStepEffects = [];
        function spawnShadowStepEffect(x, y) {
            const shadows = [];
            for (let i = 0; i < 15; i++) {
                shadows.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    size: 10 + Math.random() * 20,
                    alpha: 0.5 + Math.random() * 0.5,
                    drift: (Math.random() - 0.5) * 2
                });
            }
            shadowStepEffects.push({
                x, y, shadows,
                life: 40,
                fadeRing: 0
            });
        }
        function spawnShadowStrikeEffect(x, y) {
            // Effect when breaking stealth with an attack
            const slashes = [];
            for (let i = 0; i < 3; i++) {
                const angle = -0.3 + i * 0.3;
                slashes.push({
                    x, y, angle,
                    length: 0,
                    maxLength: 40 + Math.random() * 20
                });
            }
            shadowStepEffects.push({
                x, y, slashes,
                isStrike: true,
                life: 30
            });
        }
        function updateShadowStepEffects() {
            for (let i = shadowStepEffects.length - 1; i >= 0; i--) {
                const e = shadowStepEffects[i];
                e.life--;
                if (e.isStrike) {
                    for (const s of e.slashes) {
                        if (s.length < s.maxLength) s.length += s.maxLength / 5;
                    }
                } else {
                    e.fadeRing += 3;
                    for (const s of e.shadows) {
                        s.y += s.drift;
                        s.alpha *= 0.95;
                    }
                }
                if (e.life <= 0) shadowStepEffects.splice(i, 1);
            }
        }
        function drawShadowStepEffects() {
            ctx.save();
            for (const e of shadowStepEffects) {
                const alpha = e.life / (e.isStrike ? 30 : 40);
                if (e.isStrike) {
                    // Shadow strike slashes
                    ctx.strokeStyle = `rgba(44, 62, 80, ${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    for (const s of e.slashes) {
                        const endX = s.x + Math.cos(s.angle) * s.length;
                        const endY = s.y + Math.sin(s.angle) * s.length;
                        ctx.beginPath();
                        ctx.moveTo(s.x - Math.cos(s.angle) * 10, s.y - Math.sin(s.angle) * 10);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = alpha;
                    ctx.fillText('', e.x, e.y + 7);
                } else {
                    // Vanishing shadows
                    for (const s of e.shadows) {
                        ctx.fillStyle = `rgba(44, 62, 80, ${s.alpha * alpha})`;
                        ctx.beginPath();
                        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Fade ring
                    ctx.strokeStyle = `rgba(44, 62, 80, ${alpha * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.fadeRing, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        // =============================================
        // WAR CRY EFFECT - Terrifying shout
        // =============================================
        let warCryEffects = [];
        function spawnWarCryEffect(x, y, radius = 100) {
            const soundWaves = [];
            for (let i = 0; i < 4; i++) {
                soundWaves.push({ radius: 0, delay: i * 8 });
            }
            const exclamations = [];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                exclamations.push({
                    x: x + Math.cos(angle) * 30,
                    y: y + Math.sin(angle) * 30,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    rotation: (Math.random() - 0.5) * 0.5
                });
            }
            warCryEffects.push({
                x, y, radius, soundWaves, exclamations,
                life: 50,
                shake: 10
            });
        }
        function updateWarCryEffects() {
            for (let i = warCryEffects.length - 1; i >= 0; i--) {
                const e = warCryEffects[i];
                e.life--;
                e.shake *= 0.9;
                for (const sw of e.soundWaves) {
                    if (sw.delay > 0) sw.delay--;
                    else sw.radius += 5;
                }
                for (const ex of e.exclamations) {
                    ex.x += ex.vx;
                    ex.y += ex.vy;
                }
                if (e.life <= 0) warCryEffects.splice(i, 1);
            }
        }
        function drawWarCryEffects() {
            ctx.save();
            for (const e of warCryEffects) {
                const alpha = e.life / 50;
                const shakeX = (Math.random() - 0.5) * e.shake;
                const shakeY = (Math.random() - 0.5) * e.shake;
                // Sound waves
                for (const sw of e.soundWaves) {
                    if (sw.delay > 0) continue;
                    const waveAlpha = Math.max(0, 1 - sw.radius / e.radius) * alpha;
                    ctx.strokeStyle = `rgba(192, 57, 43, ${waveAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(e.x + shakeX, e.y + shakeY, sw.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Exclamation marks
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(192, 57, 43, ${alpha})`;
                for (const ex of e.exclamations) {
                    ctx.save();
                    ctx.translate(ex.x, ex.y);
                    ctx.rotate(ex.rotation);
                    ctx.fillText('!', 0, 0);
                    ctx.restore();
                }
                // Center icon
                ctx.font = '22px Arial';
                ctx.globalAlpha = alpha;
                ctx.fillText('', e.x + shakeX, e.y + shakeY + 7);
            }
            ctx.restore();
        }

        // =============================================
        // HEALING AURA EFFECT - Green restoration glow
        // =============================================
        let healingAuraEffects = [];
        function spawnHealingAuraEffect(x, y, radius = 80, targets = []) {
            const hearts = [];
            for (let i = 0; i < 12; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * radius;
                hearts.push({
                    x: x + Math.cos(angle) * dist,
                    y: y + Math.sin(angle) * dist,
                    vy: -1 - Math.random() * 2,
                    size: 10 + Math.random() * 8,
                    wobble: Math.random() * Math.PI * 2
                });
            }
            const beams = [];
            for (const t of targets) {
                beams.push({ targetX: t.x, targetY: t.y, progress: 0 });
            }
            healingAuraEffects.push({
                x, y, radius, hearts, beams,
                life: 60,
                pulsePhase: 0
            });
        }
        function updateHealingAuraEffects() {
            for (let i = healingAuraEffects.length - 1; i >= 0; i--) {
                const e = healingAuraEffects[i];
                e.life--;
                e.pulsePhase += 0.15;
                for (const h of e.hearts) {
                    h.y += h.vy;
                    h.wobble += 0.1;
                    h.x += Math.sin(h.wobble) * 0.5;
                }
                for (const b of e.beams) {
                    if (b.progress < 1) b.progress += 0.1;
                }
                if (e.life <= 0) healingAuraEffects.splice(i, 1);
            }
        }
        function drawHealingAuraEffects() {
            ctx.save();
            for (const e of healingAuraEffects) {
                const alpha = e.life / 60;
                const pulse = Math.sin(e.pulsePhase) * 0.2 + 0.8;
                // Aura glow
                const gradient = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius * pulse);
                gradient.addColorStop(0, `rgba(46, 204, 113, ${alpha * 0.4})`);
                gradient.addColorStop(0.7, `rgba(46, 204, 113, ${alpha * 0.2})`);
                gradient.addColorStop(1, `rgba(46, 204, 113, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius * pulse, 0, Math.PI * 2);
                ctx.fill();
                // Healing beams to targets
                ctx.strokeStyle = `rgba(46, 204, 113, ${alpha * 0.7})`;
                ctx.lineWidth = 3;
                for (const b of e.beams) {
                    const endX = e.x + (b.targetX - e.x) * b.progress;
                    const endY = e.y + (b.targetY - e.y) * b.progress;
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                // Floating hearts
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(46, 204, 113, ${alpha})`;
                for (const h of e.hearts) {
                    ctx.globalAlpha = alpha;
                    ctx.fillText('', h.x, h.y);
                }
                // Center icon
                ctx.font = '20px Arial';
                ctx.globalAlpha = alpha;
                ctx.fillText('', e.x, e.y + 7);
            }
            ctx.restore();
        }

        // =============================================
        // METEOR STRIKE EFFECT - Falling impact
        // =============================================
        let meteorStrikeEffects = [];
        function spawnMeteorStrikeEffect(x, y, delay = 90) {
            meteorStrikeEffects.push({
                x, y,
                life: delay + 60,
                delay: delay,
                meteorY: y - 400,
                impacted: false,
                craterSize: 0,
                flames: [],
                debris: []
            });
        }
        function updateMeteorStrikeEffects() {
            for (let i = meteorStrikeEffects.length - 1; i >= 0; i--) {
                const e = meteorStrikeEffects[i];
                e.life--;
                if (e.delay > 0) {
                    e.delay--;
                } else if (!e.impacted) {
                    e.meteorY += 20;
                    if (e.meteorY >= e.y) {
                        e.impacted = true;
                        // Spawn impact debris
                        for (let j = 0; j < 30; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            e.debris.push({
                                x: e.x, y: e.y,
                                vx: Math.cos(angle) * (3 + Math.random() * 5),
                                vy: Math.sin(angle) * (3 + Math.random() * 5) - 4,
                                size: 3 + Math.random() * 6
                            });
                            e.flames.push({
                                x: e.x + Math.cos(angle) * Math.random() * 50,
                                y: e.y + Math.sin(angle) * Math.random() * 50,
                                size: 15 + Math.random() * 20,
                                life: 40
                            });
                        }
                    }
                } else {
                    e.craterSize = Math.min(80, e.craterSize + 8);
                    for (const d of e.debris) {
                        d.x += d.vx;
                        d.y += d.vy;
                        d.vy += 0.3;
                        d.vx *= 0.98;
                    }
                    for (const f of e.flames) {
                        f.size *= 0.95;
                        f.life--;
                    }
                    e.flames = e.flames.filter(f => f.life > 0);
                }
                if (e.life <= 0) meteorStrikeEffects.splice(i, 1);
            }
        }
        function drawMeteorStrikeEffects() {
            ctx.save();
            for (const e of meteorStrikeEffects) {
                const alpha = Math.min(1, e.life / 30);
                if (!e.impacted) {
                    // Warning circle
                    const warningAlpha = Math.sin(Date.now() * 0.01) * 0.3 + 0.5;
                    ctx.strokeStyle = `rgba(231, 76, 60, ${warningAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 60, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    // Falling meteor
                    if (e.delay <= 0) {
                        const gradient = ctx.createRadialGradient(e.x, e.meteorY, 0, e.x, e.meteorY, 25);
                        gradient.addColorStop(0, '#ffff00');
                        gradient.addColorStop(0.3, '#ff6600');
                        gradient.addColorStop(1, '#cc0000');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(e.x, e.meteorY, 20, 0, Math.PI * 2);
                        ctx.fill();
                        // Trail
                        ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                        ctx.beginPath();
                        ctx.moveTo(e.x - 15, e.meteorY);
                        ctx.lineTo(e.x, e.meteorY - 100);
                        ctx.lineTo(e.x + 15, e.meteorY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.font = '28px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('', e.x, e.meteorY + 10);
                    }
                } else {
                    // Impact crater
                    const craterGradient = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.craterSize);
                    craterGradient.addColorStop(0, `rgba(50, 30, 20, ${alpha * 0.8})`);
                    craterGradient.addColorStop(0.7, `rgba(100, 50, 30, ${alpha * 0.5})`);
                    craterGradient.addColorStop(1, `rgba(150, 80, 50, 0)`);
                    ctx.fillStyle = craterGradient;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.craterSize, 0, Math.PI * 2);
                    ctx.fill();
                    // Flames
                    for (const f of e.flames) {
                        const fGradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size);
                        fGradient.addColorStop(0, `rgba(255, 200, 50, ${(f.life / 40) * alpha})`);
                        fGradient.addColorStop(0.5, `rgba(255, 100, 0, ${(f.life / 40) * alpha * 0.7})`);
                        fGradient.addColorStop(1, 'rgba(200, 50, 0, 0)');
                        ctx.fillStyle = fGradient;
                        ctx.beginPath();
                        ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Debris
                    ctx.fillStyle = `rgba(80, 50, 30, ${alpha})`;
                    for (const d of e.debris) {
                        ctx.beginPath();
                        ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            ctx.restore();
        }

        // =============================================
        // MIRROR IMAGE EFFECT - Clone illusions
        // =============================================
        let mirrorImageEffects = [];
        function spawnMirrorImageEffect(x, y, ant) {
            const mirrors = [];
            for (let i = 0; i < 2; i++) {
                const angle = (i === 0 ? -1 : 1) * (Math.PI / 4);
                mirrors.push({
                    x: x + Math.cos(angle) * 30,
                    y: y + Math.sin(angle) * 30,
                    angle: ant.angle,
                    shimmerPhase: Math.random() * Math.PI * 2
                });
            }
            mirrorImageEffects.push({
                x, y, mirrors, sourceAnt: ant,
                life: 40
            });
        }
        function updateMirrorImageEffects() {
            for (let i = mirrorImageEffects.length - 1; i >= 0; i--) {
                const e = mirrorImageEffects[i];
                e.life--;
                for (const m of e.mirrors) {
                    m.shimmerPhase += 0.2;
                }
                if (e.life <= 0) mirrorImageEffects.splice(i, 1);
            }
        }
        function drawMirrorImageEffects() {
            ctx.save();
            for (const e of mirrorImageEffects) {
                const alpha = e.life / 40;
                for (const m of e.mirrors) {
                    const shimmer = Math.sin(m.shimmerPhase) * 0.3 + 0.5;
                    // Ghost ant silhouette
                    ctx.fillStyle = `rgba(155, 89, 182, ${alpha * shimmer})`;
                    ctx.save();
                    ctx.translate(m.x, m.y);
                    ctx.rotate(m.angle);
                    // Body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(7, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    // Shimmer particles
                    ctx.fillStyle = `rgba(200, 150, 255, ${alpha * 0.5})`;
                    for (let i = 0; i < 3; i++) {
                        const px = m.x + (Math.random() - 0.5) * 20;
                        const py = m.y + (Math.random() - 0.5) * 20;
                        ctx.beginPath();
                        ctx.arc(px, py, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = alpha;
                ctx.fillText('', e.x, e.y + 5);
            }
            ctx.restore();
        }

        // =============================================
        // MIRROR DECOYS - Global array of decoy entities that can take damage
        // =============================================
        let mirrorDecoys = [];

        function spawnMirrorDecoy(x, y, sourceAnt) {
            const hp = Math.floor(sourceAnt.maxHp * 0.2);
            mirrorDecoys.push({
                x, y,
                currentHp: hp,
                maxHp: hp,
                sourceAnt: sourceAnt,
                angle: sourceAnt.angle,
                color: sourceAnt.color,
                sizeMultiplier: sourceAnt.sizeMultiplier,
                spawnTime: Date.now(),
                duration: 6000,
                shimmerPhase: Math.random() * Math.PI * 2
            });
        }

        function updateMirrorDecoys() {
            const now = Date.now();
            for (let i = mirrorDecoys.length - 1; i >= 0; i--) {
                const decoy = mirrorDecoys[i];
                decoy.shimmerPhase += 0.1;

                // Remove if expired or dead
                if (now - decoy.spawnTime >= decoy.duration || decoy.currentHp <= 0) {
                    // Spawn poof effect when removed
                    spawnMirrorImageEffect(decoy.x, decoy.y, { angle: decoy.angle });
                    mirrorDecoys.splice(i, 1);
                }
            }
        }

        function drawMirrorDecoys() {
            ctx.save();
            for (const decoy of mirrorDecoys) {
                const timeLeft = decoy.duration - (Date.now() - decoy.spawnTime);
                const fadeAlpha = Math.min(1, timeLeft / 1000); // Fade in last second
                const shimmer = Math.sin(decoy.shimmerPhase) * 0.15 + 0.5;

                ctx.save();
                ctx.translate(decoy.x, decoy.y);
                ctx.rotate(decoy.angle);
                ctx.globalAlpha = shimmer * fadeAlpha;

                const size = CONFIG.antSize * decoy.sizeMultiplier * 0.95;

                // Ghost purple tint
                ctx.fillStyle = `rgba(155, 89, 182, 0.7)`;
                ctx.strokeStyle = `rgba(200, 150, 255, 0.8)`;
                ctx.lineWidth = 1;

                // Abdomen
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.5, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Thorax
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 0.35, size * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Head
                ctx.beginPath();
                ctx.arc(size * 0.5, 0, size * 0.22, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.restore();

                // HP bar above decoy
                const hpPercent = decoy.currentHp / decoy.maxHp;
                const barWidth = 20;
                const barHeight = 3;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(decoy.x - barWidth/2, decoy.y - 18, barWidth, barHeight);
                ctx.fillStyle = hpPercent > 0.5 ? '#9b59b6' : '#e74c3c';
                ctx.fillRect(decoy.x - barWidth/2, decoy.y - 18, barWidth * hpPercent, barHeight);

                // Shimmer particles
                ctx.fillStyle = `rgba(200, 150, 255, ${shimmer * fadeAlpha * 0.4})`;
                for (let i = 0; i < 2; i++) {
                    const px = decoy.x + (Math.random() - 0.5) * 25;
                    const py = decoy.y + (Math.random() - 0.5) * 25;
                    ctx.beginPath();
                    ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        function checkMirrorDecoyCombat() {
            const COMBAT_RANGE = 20;
            const allPredators = [...spiderPredators, ...beetlePredators];

            for (const decoy of mirrorDecoys) {
                if (decoy.currentHp <= 0) continue;

                for (const predator of allPredators) {
                    if (predator.state === 'stunned' || predator.state === 'dead') continue;
                    if (predator.frozenTimer > 0) continue;

                    const dist = Math.hypot(decoy.x - predator.x, decoy.y - predator.y);

                    if (dist < COMBAT_RANGE) {
                        // Predator attacks the decoy (decoy has 0 ATK so doesn't fight back)
                        if (time - (predator.lastDecoyAttackTime || 0) >= 60) {
                            predator.lastDecoyAttackTime = time;
                            predator.fightingTimer = 60;

                            const predatorAtk = predator.atk || 10;
                            const damage = Math.max(1, predatorAtk);
                            decoy.currentHp -= damage;

                            // Face the decoy
                            predator.angle = Math.atan2(decoy.y - predator.y, decoy.x - predator.x);

                            spawnFloatingText(decoy.x, decoy.y - 15, `${Math.floor(damage)}`, '#9b59b6', 10);

                            if (decoy.currentHp <= 0) {
                                spawnFloatingText(decoy.x, decoy.y - 25, ' POOF!', '#9b59b6', 12, 90);
                            }
                        }
                    }
                }
            }
        }

        // =============================================
        // BLINK EFFECT - Teleport flash
        // =============================================
        let blinkEffects = [];
        function spawnBlinkEffect(startX, startY, endX, endY) {
            const particles = [];
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: startX,
                    y: startY,
                    targetX: endX + (Math.random() - 0.5) * 30,
                    targetY: endY + (Math.random() - 0.5) * 30,
                    progress: Math.random() * 0.3,
                    size: 3 + Math.random() * 4
                });
            }
            blinkEffects.push({
                startX, startY, endX, endY,
                particles,
                life: 30,
                startFlash: 1,
                endFlash: 0
            });
        }
        function updateBlinkEffects() {
            for (let i = blinkEffects.length - 1; i >= 0; i--) {
                const e = blinkEffects[i];
                e.life--;
                e.startFlash *= 0.85;
                e.endFlash = Math.min(1, e.endFlash + 0.15);
                for (const p of e.particles) {
                    p.progress = Math.min(1, p.progress + 0.08);
                    p.x = e.startX + (p.targetX - e.startX) * p.progress;
                    p.y = e.startY + (p.targetY - e.startY) * p.progress;
                }
                if (e.life <= 0) blinkEffects.splice(i, 1);
            }
        }
        function drawBlinkEffects() {
            ctx.save();
            for (const e of blinkEffects) {
                const alpha = e.life / 30;
                // Start flash
                if (e.startFlash > 0.1) {
                    ctx.fillStyle = `rgba(243, 156, 18, ${e.startFlash})`;
                    ctx.beginPath();
                    ctx.arc(e.startX, e.startY, 20 * e.startFlash, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Teleport particles
                ctx.fillStyle = `rgba(243, 156, 18, ${alpha})`;
                for (const p of e.particles) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * (1 - p.progress * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }
                // End flash
                ctx.fillStyle = `rgba(243, 156, 18, ${e.endFlash * alpha})`;
                ctx.beginPath();
                ctx.arc(e.endX, e.endY, 25 * e.endFlash, 0, Math.PI * 2);
                ctx.fill();
                // Sparkle
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = alpha;
                ctx.fillText('', e.endX, e.endY + 6);
            }
            ctx.restore();
        }

        // =============================================
        // SPIRIT LINK EFFECT - Connection chains
        // =============================================
        let spiritLinkEffects = [];
        function spawnSpiritLinkEffect(sourceAnt, linkedAnts) {
            const links = [];
            for (const ant of linkedAnts) {
                links.push({
                    targetAnt: ant,
                    pulsePhase: Math.random() * Math.PI * 2,
                    particles: []
                });
                // Add flowing particles along each link
                for (let i = 0; i < 5; i++) {
                    links[links.length - 1].particles.push({
                        progress: Math.random(),
                        speed: 0.02 + Math.random() * 0.02
                    });
                }
            }
            spiritLinkEffects.push({
                sourceAnt, links,
                life: 360, // 6 seconds
                maxLife: 360
            });
        }
        function updateSpiritLinkEffects() {
            for (let i = spiritLinkEffects.length - 1; i >= 0; i--) {
                const e = spiritLinkEffects[i];
                e.life--;
                for (const link of e.links) {
                    link.pulsePhase += 0.1;
                    for (const p of link.particles) {
                        p.progress += p.speed;
                        if (p.progress > 1) p.progress = 0;
                    }
                }
                // Remove links to dead ants
                e.links = e.links.filter(l => ants.includes(l.targetAnt));
                if (e.life <= 0 || !ants.includes(e.sourceAnt)) {
                    spiritLinkEffects.splice(i, 1);
                }
            }
        }
        function drawSpiritLinkEffects() {
            ctx.save();
            for (const e of spiritLinkEffects) {
                if (!ants.includes(e.sourceAnt)) continue;
                const alpha = Math.min(1, e.life / 30, (e.maxLife - e.life) / 30 + 0.5);
                const srcX = e.sourceAnt.x;
                const srcY = e.sourceAnt.y;
                for (const link of e.links) {
                    if (!ants.includes(link.targetAnt)) continue;
                    const tgtX = link.targetAnt.x;
                    const tgtY = link.targetAnt.y;
                    const pulse = Math.sin(link.pulsePhase) * 0.3 + 0.7;
                    // Link line
                    ctx.strokeStyle = `rgba(26, 188, 156, ${alpha * pulse * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(srcX, srcY);
                    ctx.lineTo(tgtX, tgtY);
                    ctx.stroke();
                    // Flowing particles
                    ctx.fillStyle = `rgba(26, 188, 156, ${alpha})`;
                    for (const p of link.particles) {
                        const px = srcX + (tgtX - srcX) * p.progress;
                        const py = srcY + (tgtY - srcY) * p.progress;
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                // Source glow
                ctx.fillStyle = `rgba(26, 188, 156, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc(srcX, srcY, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = alpha;
                ctx.fillText('', srcX, srcY - 15);
            }
            ctx.restore();
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];

                // If following a target, just track position (no drift)
                if (ft.followTarget) {
                    // Check if target is still alive (has isAlive method or exists in arrays)
                    const targetAlive = (ft.followTarget.isAlive && ft.followTarget.isAlive()) ||
                                       ants.includes(ft.followTarget);
                    if (targetAlive) {
                        ft.x = ft.followTarget.x;
                        ft.y = ft.followTarget.y - 25;  // Fixed position above target, no drift
                    }
                } else {
                    // Only non-following texts drift upward
                    ft.y += ft.vy;
                }

                ft.life--;
                ft.alpha = ft.life / (ft.maxLife || 120);
                if (ft.life <= 0) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function drawFloatingTexts() {
            ctx.save();
            for (const ft of floatingTexts) {
                ctx.globalAlpha = ft.alpha;
                ctx.font = `bold ${ft.size}px 'Orbitron', sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillStyle = ft.color;
                ctx.shadowColor = ft.color;
                ctx.shadowBlur = 8;
                // For following texts, y already includes the offset from update
                ctx.fillText(ft.text, ft.x, ft.y);
            }
            ctx.restore();
        }

        function updateCombatEffects() {
            for (let i = combatEffects.length - 1; i >= 0; i--) {
                const ce = combatEffects[i];
                ce.life--;
                ce.scale += (ce.targetScale - ce.scale) * 0.3;
                if (ce.life <= 0) {
                    combatEffects.splice(i, 1);
                }
            }
        }

        function drawCombatEffects() {
            ctx.save();
            for (const ce of combatEffects) {
                const alpha = ce.life / 40;
                ctx.globalAlpha = alpha;
                ctx.translate(ce.x, ce.y);
                ctx.scale(ce.scale, ce.scale);

                // Draw combat clash effect only (no flickering health bars - those are now persistent on units)
                const clashSize = 20;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 8;

                // Clash lines - impact effect
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + ce.life * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 3, Math.sin(angle) * 3);
                    ctx.lineTo(Math.cos(angle) * clashSize, Math.sin(angle) * clashSize);
                    ctx.stroke();
                }

                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            ctx.restore();
        }

        // ===========================================
        // SEEDED RANDOM NUMBER GENERATOR
        // ===========================================

        let currentSeed = Date.now();

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        class SeededRNG {
            constructor(seed) {
                this.seed = seed;
            }

            next() {
                this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
                return this.seed / 0x7fffffff;
            }

            nextRange(min, max) {
                return min + this.next() * (max - min);
            }

            nextInt(min, max) {
                return Math.floor(this.nextRange(min, max + 1));
            }
        }

        let rng = new SeededRNG(currentSeed);

        // ===========================================
        // MAP SPOTS (Food & Predator spawn points)
        // ===========================================

        let foodSpots = [];      // 5 spots for the 5 food types
        let predatorSpots = [];  // 2 spots where predators spawn (spider, beetle)

        function generateMapSpots() {
            foodSpots = [];
            predatorSpots = [];

            const margin = 100;
            const foodSpotSpacing = 200; // Minimum distance between food spots

            // Food types are assigned permanently at generation time (not based on distance)
            const ZONE_FOOD_TYPES = ['sugar', 'protein', 'fruit', 'feast', 'nectar'];

            // Generate 5 food spots - one for each food type, well spaced across the map
            for (let i = 0; i < 5; i++) {
                let spot;
                let attempts = 0;
                do {
                    spot = {
                        x: rng.nextRange(margin, width - margin),
                        y: rng.nextRange(margin, height - margin),
                        type: 'food',
                        radius: 55,
                        multiplier: 1,  // Default multiplier, will be set in placeHive()
                        assignedFoodType: ZONE_FOOD_TYPES[i]  // Fixed food type for this spot
                    };
                    attempts++;
                } while (
                    (foodSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < foodSpotSpacing)) &&
                    attempts < 50
                );
                foodSpots.push(spot);
            }

            // Generate 2 predator spots (spider and beetle)
            const predatorTypes = ['spider', 'beetle'];
            for (let i = 0; i < 2; i++) {
                let spot;
                let attempts = 0;
                do {
                    spot = {
                        x: rng.nextRange(margin, width - margin),
                        y: rng.nextRange(margin, height - margin),
                        type: predatorTypes[i],
                        radius: 40
                    };
                    attempts++;
                } while (
                    (foodSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < 100) ||
                    predatorSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < 150)) &&
                    attempts < 50
                );
                predatorSpots.push(spot);
            }
        }

        function drawSpots() {
            // Draw food spots with distance-based multipliers
            for (let i = 0; i < foodSpots.length; i++) {
                const spot = foodSpots[i];
                ctx.save();

                // Check if zone is occupied or on cooldown
                const isOccupied = zoneOccupied.has(i);
                const cooldownEnd = zoneCooldowns.get(i);
                const isOnCooldown = cooldownEnd && Date.now() < cooldownEnd;

                // Color varies based on multiplier (x1=green, x2=yellow, x3=gold)
                // Use getDisplayMultiplier to show preview during hive placement
                const multiplier = getDisplayMultiplier(spot);
                let baseColor, labelColor;
                if (multiplier === 3) {
                    baseColor = { r: 255, g: 180, b: 50 };  // Gold for x3
                    labelColor = 'rgba(255, 200, 80, 0.9)';
                } else if (multiplier === 2) {
                    baseColor = { r: 220, g: 200, b: 80 };  // Yellow for x2
                    labelColor = 'rgba(220, 200, 80, 0.9)';
                } else {
                    baseColor = { r: 184, g: 212, b: 104 }; // Green for x1
                    labelColor = 'rgba(184, 212, 104, 0.7)';
                }

                // Dim occupied zones
                const alphaMultiplier = isOccupied ? 0.3 : 1.0;

                // Glowing circle for food spot
                const gradient = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.radius);
                gradient.addColorStop(0, `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.15 * alphaMultiplier})`);
                gradient.addColorStop(0.7, `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.08 * alphaMultiplier})`);
                gradient.addColorStop(1, `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // Dashed border (solid when occupied)
                ctx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.4 * alphaMultiplier})`;
                ctx.lineWidth = 2;
                if (!isOccupied) {
                    ctx.setLineDash([6, 6]);
                }
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label - show the food type for this zone
                ctx.fillStyle = labelColor;
                ctx.font = 'bold 10px "DM Mono", monospace';
                ctx.textAlign = 'center';

                // Show food type for this zone (same before and after hive placement)
                const foodType = spot.assignedFoodType;
                const foodConfig = CONFIG.foodTypes[foodType];
                const emoji = foodConfig ? foodConfig.emoji : '';

                if (gameStarted) {
                    // After hive placement - show emoji + level
                    const level = foodLevels[foodType] || 1;
                    ctx.fillText(`${emoji} Lv.${level}`, spot.x, spot.y - spot.radius - 8);
                } else {
                    // Before hive placement - show larger emoji preview
                    ctx.font = '24px sans-serif';
                    ctx.fillText(emoji, spot.x, spot.y + 8);
                    ctx.font = 'bold 10px "DM Mono", monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillText('FOOD ZONE', spot.x, spot.y - spot.radius - 8);
                }

                // Multiplier badge - show "?" before hive placement, actual multiplier after
                const badgeX = spot.x + spot.radius * 0.7;
                const badgeY = spot.y - spot.radius * 0.5;
                ctx.fillStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.9 * alphaMultiplier})`;
                ctx.beginPath();
                ctx.arc(badgeX, badgeY, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.font = 'bold 11px "DM Mono", monospace';
                // Show multiplier preview during hive placement, "?" before, actual value after
                const badgeText = gameStarted ? `x${multiplier}` : (isPreviewingHivePlacement ? `x${multiplier}` : '?');
                ctx.fillText(badgeText, badgeX, badgeY + 4);

                // Draw cooldown timer when zone is on cooldown (WoW-style sweep)
                if (isOnCooldown && cooldownEnd) {
                    const now = Date.now();
                    const remaining = cooldownEnd - now;
                    const progress = remaining / ZONE_COOLDOWN_DURATION;  // 1 = full cooldown, 0 = ready
                    const seconds = Math.ceil(remaining / 1000);

                    // Darken the zone with radial gradient
                    const darkGrad = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.radius);
                    darkGrad.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
                    darkGrad.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                    ctx.fillStyle = darkGrad;
                    ctx.beginPath();
                    ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // WoW-style clockwise sweep overlay (dark pie that shrinks)
                    if (progress > 0) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.beginPath();
                        ctx.moveTo(spot.x, spot.y);
                        ctx.arc(spot.x, spot.y, spot.radius * 0.9, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Subtle countdown number in center
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.font = 'bold 16px "Orbitron", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${seconds}`, spot.x, spot.y);
                }

                ctx.restore();
            }

            // Draw predator spots
            for (const spot of predatorSpots) {
                ctx.save();

                const color = spot.type === 'spider'
                    ? { r: 120, g: 40, b: 40 }
                    : { r: 80, g: 100, b: 50 };

                // Danger glow
                const gradient = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.radius);
                gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.25)`);
                gradient.addColorStop(0.7, `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`);
                gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // Pulsing border
                const pulse = Math.sin(Date.now() / 500) * 0.2 + 0.8;
                ctx.strokeStyle = `rgba(${color.r * 2}, ${color.g * 2}, ${color.b * 2}, ${0.5 * pulse})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = `rgba(${color.r * 2}, ${color.g * 2}, ${color.b * 2}, 0.8)`;
                ctx.font = 'bold 10px "DM Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(spot.type.toUpperCase() + ' DEN', spot.x, spot.y - spot.radius - 8);

                // Icon
                ctx.font = '20px sans-serif';
                ctx.fillText(spot.type === 'spider' ? '' : '', spot.x, spot.y + 6);

                ctx.restore();
            }
        }

        // ===========================================
        // CONFIGURATION
        // ===========================================

        const CONFIG = {
            nestX: 0,
            nestY: 0,
            nestRadius: 40,
            initialAnts: 10,
            maxAnts: 300,

            antSpeed: 0.7,
            antSize: 6,
            carryCapacity: 8,
            turnRate: 0.15,
            wanderStrength: 0.25,

            pheromoneGridSize: 10,
            pheromoneDecay: 0.996,
            pheromoneDeposit: 1.2,
            pheromoneMax: 255,
            pheromoneFollowStrength: 0.35,

            // Food types - size is now based on food level (units = level)
            // No costs - food is free to place
            foodTypes: {
                sugar: {
                    baseRadius: 14, value: 0, cost: 0, name: 'sugar', emoji: '',
                    bonusStat: 'hp', bonusPerUnit: 1, effectColor: '#ff6b81',
                    effectDesc: '+HP', abilityName: 'Gold Hunter'
                },
                protein: {
                    baseRadius: 16, value: 0, cost: 0, name: 'protein', emoji: '',
                    bonusStat: 'atk', bonusPerUnit: 1, effectColor: '#ff6b6b',
                    effectDesc: '+ATK', abilityName: 'Lifesteal'
                },
                fruit: {
                    baseRadius: 18, value: 0, cost: 0, name: 'fruit', emoji: '',
                    bonusStat: 'speed', bonusPerUnit: 1, effectColor: '#7bed9f',
                    effectDesc: '+SPD', abilityName: 'Fresh Keeper'
                },
                feast: {
                    baseRadius: 20, value: 0, cost: 0, name: 'feast', emoji: '',
                    bonusStat: 'def', bonusPerUnit: 1, effectColor: '#ffa502',
                    effectDesc: '+DEF', abilityName: 'Thorns'
                },
                nectar: {
                    baseRadius: 22, value: 0, cost: 0, name: 'nectar', emoji: '',
                    bonusStat: 'hp5', bonusPerUnit: 1, effectColor: '#ff9ff3',
                    effectDesc: '+HP5', abilityName: 'Regeneration'
                },
                goldenApple: {
                    baseRadius: 24, value: 0, cost: 0, name: 'golden apple', emoji: '',
                    bonusStat: 'all', bonusPerUnit: 1, effectColor: '#ffd700',
                    effectDesc: '+ALL', abilityName: 'Champion', isRare: true,
                    glowColor: { r: 255, g: 215, b: 0 }
                }
            },

            // Ant types that can be spawned (costs scale up)
            antSpawnCosts: {
                worker:   { baseCost: 5, emoji: '', description: 'Balanced worker ant' }
            },

            // Ant types with Pokemon-style stats (HP, ATK, DEF) plus behavior stats
            antTypes: {
                worker: {
                    // Classic dark brown ant - balanced stats
                    color: { r: 45, g: 30, b: 20 },
                    accentColor: { r: 70, g: 50, b: 35 },
                    // Pokemon-style stats
                    hp: 10,                  // Health points
                    atk: 2,                  // Attack power
                    def: 2,                  // Defense (damage reduction)
                    // Behavior stats
                    speed: 0.5,
                    carryCapacity: 1,
                    carrySpeedBonus: 1.0,
                    pheromoneStrength: 0.8,
                    foodDetectRadius: 48,    // 4x detection radius
                    // Level bonuses per level (1-5)
                    levelBonuses: {
                        hp: 2,               // +2 HP per level
                        atk: 0.5,            // +0.5 ATK per level
                        def: 0.5,            // +0.5 DEF per level
                        speed: 0.06,
                        carryCapacity: 0.25,
                        carrySpeedBonus: 0.08,
                        foodDetectRadius: 3
                    },
                    skillLevel: 3,
                    skillName: 'Efficient Forager',
                    skillDesc: 'Follows pheromone trails with 95% accuracy instead of 70%'
                },
            },

            // Level thresholds (XP needed for each level) - no max level
            // Pattern: each level requires ~1.7x more total XP than previous
            levelThresholds: [0, 4, 10, 20, 38, 65, 110, 185, 315, 535, 910, 1545, 2625, 4460, 7580],  // Levels 1-15+

            // Colony state tracking
            recentDeaths: 0,
            deathDecayTimer: 0,

            // Predator territories and stats
            predators: {
                spider: {
                    x: 0, y: 0, radius: 120,
                    multiplier: 3,
                    color: { r: 80, g: 20, b: 20 },
                    label: 'SPIDER ZONE',
                    huntRadius: 500,  // Hunt ants from far away
                    killRadius: 12,
                    speed: 1.8,
                    // Pokemon-style stats (lowered for early game)
                    hp: 25,                  // Lower HP - glass cannon
                    atk: 2,                  // Lower attack for early waves
                    def: 0                   // No defense - easy to damage
                },
                beetle: {
                    x: 0, y: 0, radius: 90,
                    multiplier: 2,
                    color: { r: 50, g: 70, b: 35 },
                    label: 'BEETLE ZONE',
                    patrolSpeed: 0.7,
                    huntRadius: 300,  // Hunt ants from moderate distance
                    killRadius: 20,
                    blockRadius: 35,
                    // Pokemon-style stats (lowered for early game)
                    hp: 40,                  // Tanky but not too much
                    atk: 1,                  // Very low attack
                    def: 2                   // Moderate defense
                }
            }
        };

        // ===========================================
        // BIRTH PASSIVES SYSTEM
        // ===========================================

        const BIRTH_PASSIVES = {
            brawler: {
                name: 'Brawler',
                description: '+2 base ATK',
                icon: '',
                color: { r: 255, g: 100, b: 100 },  // Red tint
                apply: (ant) => { ant.birthAtkBonus = 2; }
            },
            lucky: {
                name: 'Lucky',
                description: '20% chance +1 gold on delivery',
                icon: '',
                color: { r: 255, g: 215, b: 0 },  // Gold sparkle
                apply: (ant) => { ant.luckyDelivery = true; }
            },
            thickSkinned: {
                name: 'Thick-Skinned',
                description: '+3 base HP',
                icon: '',
                color: { r: 100, g: 150, b: 255 },  // Blue tint (larger)
                apply: (ant) => { ant.birthHpBonus = 3; }
            }
        };

        const BIRTH_PASSIVE_CHANCE = 0.15;  // 15% chance to spawn with a passive

        // ===========================================
        // ANT SKILLS SYSTEM (Level 3)
        // ===========================================

        const ANT_SKILLS = {
            pounce: {
                name: 'Pounce',
                description: 'Leap to nearby enemy, deal 2x ATK damage. Range scales with DET.',
                icon: '',
                type: 'active',
                cooldown: 8000,  // 8 seconds
                color: '#ff6b6b'
            },
            ironShell: {
                name: 'Iron Shell',
                description: 'Block every other hit when below 30% HP',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#74b9ff'
            },
            vampireBite: {
                name: 'Vampire Bite',
                description: 'Attacks heal for 40% of damage dealt',
                icon: '',
                type: 'active',
                cooldown: 10000,  // 10 seconds
                color: '#9b59b6'
            },
            shockwave: {
                name: 'Shockwave',
                description: 'Stun all nearby enemies for 2 seconds. Radius scales with DET.',
                icon: '',
                type: 'active',
                cooldown: 15000,  // 15 seconds
                color: '#00d4ff'
            },
            berserker: {
                name: 'Berserker',
                description: '+100% ATK when below 40% HP',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#ff4757'
            },
            rallyCry: {
                name: 'Rally Cry',
                description: 'Boost nearby allies ATK +50% for 5s. Radius scales with DET.',
                icon: '',
                type: 'active',
                cooldown: 20000,  // 20 seconds
                color: '#f1c40f'
            },
            thorns: {
                name: 'Thorns',
                description: 'Reflect 30% of damage taken back to attacker (min 1)',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#27ae60'
            },
            swiftStrike: {
                name: 'Swift Strike',
                description: '30% chance to attack twice in a row',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#e74c3c'
            },
            secondWind: {
                name: 'Second Wind',
                description: 'Survive killing blow once per life with 50% HP',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#ff9f43'
            },
            scavenger: {
                name: 'Scavenger',
                description: '+1 bonus XP every time you gain any XP',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#a0d468'
            },
            heavyLifter: {
                name: 'Heavy Lifter',
                description: '+1 carrying capacity, no speed penalty when loaded',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#967adc'
            },
            pathfinder: {
                name: 'Pathfinder',
                description: '+100% detection range, lay 2x stronger pheromone trails',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#37bc9b'
            },
            momentum: {
                name: 'Momentum',
                description: '+5% SPD per delivery, stacks up to 20 times',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#4fc1e9'
            },
            bloodlust: {
                name: 'Bloodlust',
                description: '+2 ATK per kill, permanent stacking',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#da4453'
            },
            adrenaline: {
                name: 'Adrenaline',
                description: '+100% movement speed for 3 seconds',
                icon: '',
                type: 'active',
                cooldown: 12000,
                color: '#ffce54'
            },
            decoy: {
                name: 'Decoy',
                description: 'Create a fake ant that distracts predators for 5s',
                icon: '',
                type: 'active',
                cooldown: 20000,
                color: '#ac92ec'
            },
            lastStand: {
                name: 'Last Stand',
                description: '3x damage when below 50% HP',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#656d78'
            },
            lucky: {
                name: 'Lucky',
                description: '50% chance for double gold from kills',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#8cc152'
            },
            packHunter: {
                name: 'Pack Hunter',
                description: '+25% ATK per ally attacking same target',
                icon: '',
                type: 'passive',
                cooldown: 0,
                color: '#5d9cec'
            },
            dash: {
                name: 'Dash',
                description: 'Teleport a short distance in movement direction',
                icon: '',
                type: 'active',
                cooldown: 6000,
                color: '#ec87c0'
            },
            earthquake: {
                name: 'Earthquake',
                description: 'Slam the ground, dealing 5 damage to all enemies in range and slowing them 50% for 3s',
                icon: '',
                type: 'active',
                cooldown: 18000,
                color: '#8b4513'
            },
            chainLightning: {
                name: 'Chain Lightning',
                description: 'Lightning bounces between up to 4 enemies, dealing 50% ATK damage each',
                icon: '',
                type: 'active',
                cooldown: 12000,
                color: '#00bfff'
            },
            voidRift: {
                name: 'Void Rift',
                description: 'Open a portal that pulls enemies toward it and deals 2 damage/sec for 4s',
                icon: '',
                type: 'active',
                cooldown: 25000,
                color: '#4a0080'
            },
            fireBreath: {
                name: 'Fire Breath',
                description: 'Breathe a cone of fire dealing 4 damage and applying burn (2 dmg/sec for 3s)',
                icon: '',
                type: 'active',
                cooldown: 14000,
                color: '#ff4500'
            },
            iceNova: {
                name: 'Ice Nova',
                description: 'Freeze all nearby enemies solid for 3 seconds',
                icon: '',
                type: 'active',
                cooldown: 20000,
                color: '#87ceeb'
            },
            shadowStep: {
                name: 'Shadow Step',
                description: 'Become invisible for 4s, next attack deals 3x damage and breaks stealth',
                icon: '',
                type: 'active',
                cooldown: 16000,
                color: '#2c3e50'
            },
            warCry: {
                name: 'War Cry',
                description: 'Terrify enemies, making them flee for 3s. Radius scales with DET.',
                icon: '',
                type: 'active',
                cooldown: 22000,
                color: '#c0392b'
            },
            healingAura: {
                name: 'Healing Aura',
                description: 'Heal all nearby allies for 30% of their max HP',
                icon: '',
                type: 'active',
                cooldown: 25000,
                color: '#2ecc71'
            },
            meteorStrike: {
                name: 'Meteor Strike',
                description: 'Call down a meteor dealing 10 damage in a huge area after 1.5s delay',
                icon: '',
                type: 'active',
                cooldown: 30000,
                color: '#e74c3c'
            },
            mirrorImage: {
                name: 'Mirror Image',
                description: 'Blink back and create 2 decoy copies with 20% HP each that draw enemy attacks',
                icon: '',
                type: 'active',
                cooldown: 24000,
                color: '#9b59b6'
            },
            blink: {
                name: 'Blink',
                description: 'Instantly teleport to a random nearby enemy and stun it for 1.5s',
                icon: '',
                type: 'active',
                cooldown: 10000,
                color: '#f39c12'
            },
            spiritLink: {
                name: 'Spirit Link',
                description: 'Link with allies within DET2 range - damage split evenly for 6s. Triggers when any ally is in combat.',
                icon: '',
                type: 'active',
                cooldown: 20000,
                color: '#1abc9c'
            }
        };

        // Track ants with skills for the UI shortcuts
        let skilledAnts = [];

        // Skill choice modal state
        let skillChoiceModalOpen = false;
        let skillChoiceAnt = null;
        let pendingSkillChoices = [];  // Queue of ants waiting for skill selection

        // ===========================================
        // CURRENCY SYSTEM
        // ===========================================

        let coins = 10;  // Starting gold for first upgrade (gold mainly comes from enemy kills now)

        // ===========================================
        // SURVIVAL MODE STATE
        // ===========================================

        let gameOver = false;
        let gameStarted = false;  // Game starts paused until hive is placed
        let gameStartTime = null;  // Will be set when hive is placed
        let pausedTime = 0;  // Track total paused time for accurate timer
        let pauseStartTime = null;  // When the current pause started
        let totalAntsSpawned = 0;
        let totalCoinsEarned = 0;
        let lastUpdateTime = Date.now();

        // Arrays to hold multiple predators of each type
        let spiderPredators = [];
        let beetlePredators = [];

        function getElapsedSeconds() {
            if (!gameStartTime) return 0;
            // Account for paused time
            let currentPausedTime = pausedTime;
            if (pauseStartTime !== null) {
                currentPausedTime += Date.now() - pauseStartTime;
            }
            return (Date.now() - gameStartTime - currentPausedTime) / 1000;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function checkGameOver() {
            if (gameOver) return;

            // Game over when all ants are dead (after 2 second grace period)
            if (ants.length === 0 && getElapsedSeconds() > 2) {
                triggerGameOver();
            }
        }

        function triggerGameOver() {
            gameOver = true;

            // Update final stats
            document.getElementById('final-time').textContent = formatTime(getElapsedSeconds());
            document.getElementById('final-food').textContent = foodCollected;
            document.getElementById('final-coins').textContent = totalCoinsEarned;
            document.getElementById('final-ants').textContent = totalAntsSpawned;

            // Show modal
            document.getElementById('game-over-modal').classList.add('visible');
        }

        let lastPredatorSpawnTime = 0;  // Track spawn time in seconds

        // Predator wave tracking for progression
        let predatorWave = 0;

        // Calculate stat multiplier based on wave
        function getPredatorWaveMultiplier(wave) {
            // Base multiplier increases by 20% per wave (scales faster to compensate for lower base stats)
            return 1 + (wave * 0.20);
        }

        // Get predator skill at certain waves
        function getPredatorSkillForWave(wave, predatorType) {
            // Predators gain skills at wave 3, 5, and 7
            if (wave >= 7) {
                return predatorType === 'spider' ? 'venomous' : 'armored';
            } else if (wave >= 5) {
                return predatorType === 'spider' ? 'swift' : 'regenerate';
            } else if (wave >= 3) {
                return predatorType === 'spider' ? 'ambush' : 'stomp';
            }
            return null;
        }

        function checkPredatorSpawn() {
            if (gameOver) return;

            const elapsed = getElapsedSeconds();
            const spawnInterval = 60;  // Every 60 seconds

            // Check if enough time has passed since last spawn
            if (elapsed >= spawnInterval && elapsed - lastPredatorSpawnTime >= spawnInterval) {
                lastPredatorSpawnTime = elapsed;
                predatorWave++;
                spawnAdditionalPredators();
            }
        }

        function spawnAdditionalPredators() {
            const multiplier = getPredatorWaveMultiplier(predatorWave);
            const spiderSkill = getPredatorSkillForWave(predatorWave, 'spider');
            const beetleSkill = getPredatorSkillForWave(predatorWave, 'beetle');

            // Spawn predatorWave number of each type (wave 1 = 1, wave 2 = 2, etc.)
            const spawnCount = predatorWave;

            for (let i = 0; i < spawnCount; i++) {
                const newSpider = new Spider();
                // Offset position to spread them out
                newSpider.x += (Math.random() - 0.5) * 100;
                newSpider.y += (Math.random() - 0.5) * 100;
                // Apply wave scaling
                newSpider.maxHp = Math.floor(newSpider.maxHp * multiplier);
                newSpider.currentHp = newSpider.maxHp;
                newSpider.atk = Math.floor(newSpider.atk * multiplier);
                newSpider.def = Math.floor(newSpider.def * multiplier);
                newSpider.wave = predatorWave;
                newSpider.skill = spiderSkill;
                spiderPredators.push(newSpider);

                const newBeetle = new Beetle();
                newBeetle.x += (Math.random() - 0.5) * 100;
                newBeetle.y += (Math.random() - 0.5) * 100;
                // Apply wave scaling
                newBeetle.maxHp = Math.floor(newBeetle.maxHp * multiplier);
                newBeetle.currentHp = newBeetle.maxHp;
                newBeetle.atk = Math.floor(newBeetle.atk * multiplier);
                newBeetle.def = Math.floor(newBeetle.def * multiplier);
                newBeetle.wave = predatorWave;
                newBeetle.skill = beetleSkill;
                beetlePredators.push(newBeetle);
            }

            // Show wave notification
            if (predatorWave >= 1) {
                const waveColor = predatorWave >= 7 ? '#ff4757' : predatorWave >= 5 ? '#ffa502' : predatorWave >= 3 ? '#ffb464' : '#00ff88';
                spawnFloatingText(width / 2, 80, `WAVE ${predatorWave}`, waveColor, 24, 180);
                spawnFloatingText(width / 2, 110, `+${spawnCount * 2} enemies`, waveColor, 14, 180);

                // Show skill unlock notification
                if (spiderSkill && predatorWave === 3) {
                    spawnFloatingText(width / 2, 135, 'Predators gained skills!', '#ff6b6b', 14, 180);
                } else if (spiderSkill && predatorWave === 5) {
                    spawnFloatingText(width / 2, 135, 'Predators growing stronger!', '#ffa502', 14, 180);
                } else if (spiderSkill && predatorWave === 7) {
                    spawnFloatingText(width / 2, 135, 'ELITE PREDATORS!', '#ff4757', 16, 180);
                }
            }
        }

        // ===========================================
        // RARE FOOD SPAWN SYSTEM
        // ===========================================

        let lastRareFoodSpawnTime = 0;
        const RARE_FOOD_SPAWN_INTERVAL = 45;  // Check every 45 seconds
        const RARE_FOOD_SPAWN_CHANCE = 0.35;  // 35% chance per check

        function checkRareFoodSpawn() {
            if (gameOver) return;

            const elapsed = getElapsedSeconds();

            // Check if enough time has passed since last rare food check
            if (elapsed - lastRareFoodSpawnTime >= RARE_FOOD_SPAWN_INTERVAL) {
                lastRareFoodSpawnTime = elapsed;

                // Roll for spawn
                if (Math.random() < RARE_FOOD_SPAWN_CHANCE) {
                    spawnRareFood();
                }
            }
        }

        function spawnRareFood() {
            // Spawn a golden apple at a random location on the map
            // Prefer spawning away from the nest but not too far
            const margin = 100;
            const maxDist = Math.min(width, height) * 0.4;
            const minDist = 150;  // Not too close to nest

            let x, y, dist;
            let attempts = 0;

            // Find a valid spawn location
            do {
                x = margin + Math.random() * (width - margin * 2);
                y = margin + Math.random() * (height - margin * 2);
                dist = Math.hypot(x - CONFIG.nestX, y - CONFIG.nestY);
                attempts++;
            } while ((dist < minDist || dist > maxDist) && attempts < 50);

            // Create the rare food item
            const goldenApple = new FoodItem(x, y, 'goldenApple');
            foodItems.push(goldenApple);

            // Show a notification using rare food notification system
            addRareFoodNotification(`Golden Apple appeared!`, x, y);
        }

        // Rare food notification system (separate from ant spawn notifications)
        let rareFoodNotifications = [];

        function addRareFoodNotification(text, x, y) {
            rareFoodNotifications.push({
                text,
                x,
                y,
                startTime: Date.now(),
                duration: 3000
            });
        }

        function updateRareFoodNotifications() {
            const now = Date.now();
            rareFoodNotifications = rareFoodNotifications.filter(n => now - n.startTime < n.duration);
        }

        function drawRareFoodNotifications() {
            const now = Date.now();
            for (const notif of rareFoodNotifications) {
                const elapsed = now - notif.startTime;
                const progress = elapsed / notif.duration;
                const alpha = 1 - progress;
                const yOffset = -30 * progress;  // Float upward
                const scale = 1 + Math.sin(elapsed / 100) * 0.1;  // Subtle pulse

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(notif.x, notif.y + yOffset);
                ctx.scale(scale, scale);
                ctx.fillStyle = '#ffd700';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 3;
                ctx.font = 'bold 16px "DM Mono", monospace';
                ctx.textAlign = 'center';
                ctx.strokeText(notif.text, 0, 0);
                ctx.fillText(notif.text, 0, 0);
                ctx.restore();
            }
        }

        // ===========================================
        // UPGRADE SYSTEM (Vampire Survivors style)
        // ===========================================

        let upgradesPaused = false;
        let lastUpgradeTime = 0;
        const UPGRADE_INTERVAL = 300;  // Seconds between upgrade offers (5 minutes)

        // Auto-spawn system (separate from upgrades)
        const AUTO_SPAWN_INTERVAL = 20;  // Seconds between auto-spawning worker ants
        let lastAutoSpawnTime = 0;
        const UPGRADE_CHOICE_TIMEOUT = 60;  // Seconds before auto-choosing
        let upgradeChoiceStartTime = 0;  // When the current upgrade choice was shown
        let activeUpgrades = [];  // Track which upgrades player has chosen
        let upgradeMultipliers = {
            antSpeed: 1,
            carryCapacity: 0,          // Changed to flat bonus (was misleading multiplier)
            spawnCostReduction: 1,
            foodValue: 1,
            coinBonus: 0,
            maxAnts: 0,
            detectionRadius: 1,
            atkBonus: 0,               // Flat ATK bonus for all ants
            defBonus: 0,               // Flat DEF bonus for all ants
            hpBonus: 0,                // Flat HP bonus for all ants
            nestDefenseRadius: 80,     // Radius around nest for defense bonus
            nestDefenseBonus: 0,       // DEF bonus when near nest
            pheromoneStrength: 1,      // Multiplier for pheromone deposits
            predatorHpMultiplier: 1,   // Multiplier for predator max HP (lower = weaker predators)
            goldRushActive: false,     // Temporary gold bonus flag
            goldRushEndTime: 0,        // When gold rush expires
            goldRushMultiplier: 1      // Gold multiplier during rush
        };

        const UPGRADE_POOL = [
            // ============================================
            // LEFT COLUMN: ANT TYPES - Spawning & Colony
            // ============================================
            {
                id: 'free_worker',
                name: 'Worker Swarm',
                description: 'Instantly spawn 5 free workers',
                emoji: '',
                category: 'ants',
                apply: () => {
                    for (let i = 0; i < 5; i++) {
                        if (ants.length < CONFIG.maxAnts) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 30 + Math.random() * 20;
                            const ant = new Ant(
                                CONFIG.nestX + Math.cos(angle) * dist,
                                CONFIG.nestY + Math.sin(angle) * dist,
                                'worker'
                            );
                            ants.push(ant);
                            totalAntsSpawned++;
                        }
                    }
                },
                maxStacks: 99,
                premium: {
                    cost: 25,
                    description: 'Instantly spawn 12 free workers',
                    apply: () => {
                        for (let i = 0; i < 12; i++) {
                            if (ants.length < CONFIG.maxAnts) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 30 + Math.random() * 20;
                                const ant = new Ant(
                                    CONFIG.nestX + Math.cos(angle) * dist,
                                    CONFIG.nestY + Math.sin(angle) * dist,
                                    'worker'
                                );
                                ants.push(ant);
                                totalAntsSpawned++;
                            }
                        }
                    }
                }
            },
            {
                id: 'max_ants',
                name: 'Colony Expansion',
                description: 'Max colony size +30 ants',
                emoji: '',
                category: 'ants',
                apply: () => {
                    upgradeMultipliers.maxAnts += 30;
                    CONFIG.maxAnts += 30;
                },
                maxStacks: 5,
                premium: {
                    cost: 65,
                    description: 'Max colony size +100 ants',
                    apply: () => {
                        upgradeMultipliers.maxAnts += 100;
                        CONFIG.maxAnts += 100;
                    }
                }
            },
            // ============================================
            // MIDDLE COLUMN: ECONOMY - Gold & Resources
            // ============================================
            {
                id: 'food_value',
                name: 'Nutrient Rich',
                description: 'Food deliveries give +30% gold',
                emoji: '',
                category: 'economy',
                apply: () => { upgradeMultipliers.foodValue *= 1.30; },
                maxStacks: 4,
                premium: {
                    cost: 45,
                    description: 'Food deliveries give +75% gold',
                    apply: () => { upgradeMultipliers.foodValue *= 1.75; }
                }
            },
            {
                id: 'coin_bonus',
                name: 'Golden Harvest',
                description: '+3 bonus gold per delivery',
                emoji: '',
                category: 'economy',
                apply: () => { upgradeMultipliers.coinBonus += 3; },
                maxStacks: 5,
                premium: {
                    cost: 35,
                    description: '+8 bonus gold per delivery',
                    apply: () => { upgradeMultipliers.coinBonus += 8; }
                }
            },
            {
                id: 'cheap_spawns',
                name: 'Efficient Breeding',
                description: 'Ant spawn costs reduced by 20%',
                emoji: '',
                category: 'economy',
                apply: () => { upgradeMultipliers.spawnCostReduction *= 0.80; },
                maxStacks: 4,
                premium: {
                    cost: 50,
                    description: 'Ant spawn costs reduced by 45%',
                    apply: () => { upgradeMultipliers.spawnCostReduction *= 0.55; }
                }
            },
            {
                id: 'gold_rush',
                name: 'Gold Rush',
                description: 'Double gold income for 90 seconds',
                emoji: '',
                category: 'economy',
                apply: () => {
                    upgradeMultipliers.goldRushActive = true;
                    upgradeMultipliers.goldRushMultiplier = 2;
                    upgradeMultipliers.goldRushEndTime = Date.now() + 90000;
                },
                maxStacks: 99,
                premium: {
                    cost: 60,
                    description: 'Triple gold income for 120 seconds',
                    apply: () => {
                        upgradeMultipliers.goldRushActive = true;
                        upgradeMultipliers.goldRushMultiplier = 3;
                        upgradeMultipliers.goldRushEndTime = Date.now() + 120000;
                    }
                }
            },
            {
                id: 'coin_burst',
                name: 'Treasure Found',
                description: 'Instantly gain 75 gold',
                emoji: '',
                category: 'economy',
                apply: () => {
                    coins += 75;
                    totalCoinsEarned += 75;
                },
                maxStacks: 99,
                premium: {
                    cost: 40,
                    description: 'Instantly gain 200 gold',
                    apply: () => {
                        coins += 200;
                        totalCoinsEarned += 200;
                    }
                }
            },
            // ============================================
            // RIGHT COLUMN: OTHER - Combat & Foraging
            // ============================================
            {
                id: 'atk_boost',
                name: 'Combat Training',
                description: 'All ants gain +3 ATK',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.atkBonus += 3; },
                maxStacks: 5,
                premium: {
                    cost: 55,
                    description: 'All ants gain +8 ATK',
                    apply: () => { upgradeMultipliers.atkBonus += 8; }
                }
            },
            {
                id: 'def_boost',
                name: 'Hardened Carapace',
                description: 'All ants gain +3 DEF',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.defBonus += 3; },
                maxStacks: 5,
                premium: {
                    cost: 55,
                    description: 'All ants gain +8 DEF',
                    apply: () => { upgradeMultipliers.defBonus += 8; }
                }
            },
            {
                id: 'hp_boost',
                name: 'Vitality',
                description: 'All ants gain +8 max HP',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.hpBonus += 8; },
                maxStacks: 5,
                premium: {
                    cost: 50,
                    description: 'All ants gain +20 max HP',
                    apply: () => { upgradeMultipliers.hpBonus += 20; }
                }
            },
            {
                id: 'nest_defense',
                name: 'Fortified Nest',
                description: 'Ants near nest gain +5 DEF',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.nestDefenseBonus += 5; },
                maxStacks: 3,
                premium: {
                    cost: 70,
                    description: 'Ants near nest gain +12 DEF',
                    apply: () => { upgradeMultipliers.nestDefenseBonus += 12; }
                }
            },
            {
                id: 'predator_weakness',
                name: 'Predator Bane',
                description: 'Predators have -15% max HP',
                emoji: '',
                category: 'other',
                apply: () => {
                    upgradeMultipliers.predatorHpMultiplier *= 0.85;
                    // Apply to existing predators
                    if (typeof spider !== 'undefined' && spider) {
                        spider.hp = Math.max(1, Math.floor(spider.hp * 0.85));
                        spider.maxHp = Math.max(1, Math.floor(spider.maxHp * 0.85));
                    }
                    for (const beetle of beetlePredators) {
                        beetle.hp = Math.max(1, Math.floor(beetle.hp * 0.85));
                        beetle.maxHp = Math.max(1, Math.floor(beetle.maxHp * 0.85));
                    }
                },
                maxStacks: 3,
                premium: {
                    cost: 100,
                    description: 'Predators have -35% max HP',
                    apply: () => {
                        upgradeMultipliers.predatorHpMultiplier *= 0.65;
                        // Apply to existing predators
                        if (typeof spider !== 'undefined' && spider) {
                            spider.hp = Math.max(1, Math.floor(spider.hp * 0.65));
                            spider.maxHp = Math.max(1, Math.floor(spider.maxHp * 0.65));
                        }
                        for (const beetle of beetlePredators) {
                            beetle.hp = Math.max(1, Math.floor(beetle.hp * 0.65));
                            beetle.maxHp = Math.max(1, Math.floor(beetle.maxHp * 0.65));
                        }
                    }
                }
            },
            {
                id: 'detection',
                name: 'Keen Senses',
                description: 'Food detection radius +40%',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.detectionRadius *= 1.4; },
                maxStacks: 3,
                premium: {
                    cost: 40,
                    description: 'Food detection radius +100%',
                    apply: () => { upgradeMultipliers.detectionRadius *= 2.0; }
                }
            },
            {
                id: 'carry_boost',
                name: 'Strong Mandibles',
                description: 'Carry capacity +1 for all ants',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.carryCapacity += 1; },
                maxStacks: 4,
                premium: {
                    cost: 45,
                    description: 'Carry capacity +3 for all ants',
                    apply: () => { upgradeMultipliers.carryCapacity += 3; }
                }
            },
            {
                id: 'pheromone_boost',
                name: 'Scent Markers',
                description: 'Pheromone trails are 50% stronger',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.pheromoneStrength *= 1.5; },
                maxStacks: 3,
                premium: {
                    cost: 50,
                    description: 'Pheromone trails are 2x stronger',
                    apply: () => { upgradeMultipliers.pheromoneStrength *= 2.0; }
                }
            },
            {
                id: 'speed_boost',
                name: 'Swift Legs',
                description: 'All ants move 25% faster',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.antSpeed *= 1.25; },
                maxStacks: 4,
                premium: {
                    cost: 60,
                    description: 'All ants move 50% faster',
                    apply: () => { upgradeMultipliers.antSpeed *= 1.50; }
                }
            }
        ];

        function getUpgradeStacks(upgradeId) {
            return activeUpgrades.filter(u => u === upgradeId).length;
        }

        function getRandomUpgrades(count = 3) {
            // Filter out maxed upgrades
            const available = UPGRADE_POOL.filter(u => getUpgradeStacks(u.id) < u.maxStacks);

            // Organize by category: ants (left), economy (middle), other (right)
            const categories = {
                ants: available.filter(u => u.category === 'ants'),
                economy: available.filter(u => u.category === 'economy'),
                other: available.filter(u => u.category === 'other')
            };

            // Pick one random upgrade from each category
            const result = [];
            const order = ['ants', 'economy', 'other'];
            for (const cat of order) {
                if (categories[cat].length > 0) {
                    const shuffled = categories[cat].sort(() => Math.random() - 0.5);
                    result.push(shuffled[0]);
                }
            }

            // If we don't have 3, fill from any available
            if (result.length < 3) {
                const remaining = available.filter(u => !result.includes(u));
                const shuffled = remaining.sort(() => Math.random() - 0.5);
                while (result.length < 3 && shuffled.length > 0) {
                    result.push(shuffled.shift());
                }
            }

            return result;
        }

        let currentUpgradeChoices = [];  // Track current upgrade options for auto-select

        function showUpgradeSelection() {
            upgradesPaused = true;
            // Start pausing the survival timer
            if (pauseStartTime === null) {
                pauseStartTime = Date.now();
            }
            const upgrades = getRandomUpgrades(3);
            currentUpgradeChoices = upgrades;  // Store for auto-select
            upgradeChoiceStartTime = Date.now();  // Start countdown

            const container = document.getElementById('upgrade-options');
            container.innerHTML = '';

            // Category labels and colors
            const categoryInfo = {
                ants: { label: 'COLONY', color: '#7bed9f' },
                economy: { label: 'ECONOMY', color: '#ffd700' },
                other: { label: 'POWER', color: '#ff6b6b' }
            };

            upgrades.forEach(upgrade => {
                const stacks = getUpgradeStacks(upgrade.id);
                const hasPremium = upgrade.premium && upgrade.premium.cost;
                const canAffordPremium = hasPremium && coins >= upgrade.premium.cost;
                const catInfo = categoryInfo[upgrade.category] || { label: 'OTHER', color: '#888' };

                const card = document.createElement('div');
                card.className = 'upgrade-card-wrapper';
                card.innerHTML = `
                    <div class="upgrade-category" style="color: ${catInfo.color}; border-color: ${catInfo.color}">${catInfo.label}</div>
                    <div class="upgrade-card" data-upgrade-id="${upgrade.id}">
                        <div class="upgrade-emoji">${upgrade.emoji}</div>
                        <div class="upgrade-info">
                            <div class="upgrade-name">${upgrade.name}</div>
                            <div class="upgrade-desc">${upgrade.description}</div>
                        </div>
                        ${stacks > 0 ? `<div class="upgrade-stacks">x${stacks + 1}</div>` : ''}
                    </div>
                    ${hasPremium ? `
                        <div class="upgrade-premium ${canAffordPremium ? '' : 'disabled'}" data-upgrade-id="${upgrade.id}">
                            <span class="premium-cost">${upgrade.premium.cost}G</span>
                            <span class="premium-desc">${upgrade.premium.description}</span>
                        </div>
                    ` : ''}
                `;

                // Add click handlers
                const normalCard = card.querySelector('.upgrade-card');
                normalCard.onclick = () => selectUpgrade(upgrade);

                if (hasPremium) {
                    const premiumCard = card.querySelector('.upgrade-premium');
                    premiumCard.onclick = () => selectPremiumUpgrade(upgrade);
                }

                container.appendChild(card);
            });

            // Reset countdown display
            document.getElementById('upgrade-countdown').textContent = UPGRADE_CHOICE_TIMEOUT;
            document.getElementById('upgrade-timer-fill').style.width = '100%';

            const modal = document.getElementById('upgrade-modal');
            modal.classList.remove('minimized');
            modal.classList.add('visible');
        }

        function selectUpgrade(upgrade) {
            upgrade.apply();
            activeUpgrades.push(upgrade.id);

            // Recalculate stats for all existing ants so upgrade bonuses apply immediately
            for (const ant of ants) {
                ant.recalculateStats();
            }

            document.getElementById('upgrade-modal').classList.remove('visible');
            document.getElementById('upgrade-modal').classList.remove('minimized');
            upgradesPaused = false;
            // End the survival timer pause
            if (pauseStartTime !== null) {
                pausedTime += Date.now() - pauseStartTime;
                pauseStartTime = null;
            }
            lastUpgradeTime = getElapsedSeconds();
            currentUpgradeChoices = [];  // Clear choices

            // Check for pending skill choices
            setTimeout(() => {
                if (!skillChoiceModalOpen && pendingSkillChoices.length > 0) {
                    showNextSkillChoice();
                }
            }, 300);
        }

        function selectPremiumUpgrade(upgrade) {
            if (!upgrade.premium || coins < upgrade.premium.cost) {
                return;  // Can't afford
            }

            // Deduct cost
            coins -= upgrade.premium.cost;

            // Apply premium effect
            upgrade.premium.apply();
            activeUpgrades.push(upgrade.id);

            // Recalculate stats for all existing ants so upgrade bonuses apply immediately
            for (const ant of ants) {
                ant.recalculateStats();
            }

            document.getElementById('upgrade-modal').classList.remove('visible');
            document.getElementById('upgrade-modal').classList.remove('minimized');
            upgradesPaused = false;
            // End the survival timer pause
            if (pauseStartTime !== null) {
                pausedTime += Date.now() - pauseStartTime;
                pauseStartTime = null;
            }
            lastUpgradeTime = getElapsedSeconds();
            currentUpgradeChoices = [];  // Clear choices

            // Check for pending skill choices (premium upgrade path)
            setTimeout(() => {
                if (!skillChoiceModalOpen && pendingSkillChoices.length > 0) {
                    showNextSkillChoice();
                }
            }, 300);
        }

        function updateUpgradeCountdown() {
            if (!upgradesPaused || currentUpgradeChoices.length === 0) return;

            const elapsed = (Date.now() - upgradeChoiceStartTime) / 1000;
            const remaining = Math.max(0, UPGRADE_CHOICE_TIMEOUT - elapsed);

            // Update countdown display
            document.getElementById('upgrade-countdown').textContent = Math.ceil(remaining);
            document.getElementById('upgrade-timer-fill').style.width = (remaining / UPGRADE_CHOICE_TIMEOUT * 100) + '%';

            // Auto-select if time runs out
            if (remaining <= 0 && currentUpgradeChoices.length > 0) {
                const randomIndex = Math.floor(Math.random() * currentUpgradeChoices.length);
                selectUpgrade(currentUpgradeChoices[randomIndex]);
            }
        }

        function toggleUpgradePanel() {
            const modal = document.getElementById('upgrade-modal');
            const btn = document.getElementById('upgrade-hide-btn');
            if (modal.classList.contains('minimized')) {
                modal.classList.remove('minimized');
                btn.textContent = '\u25C0';  // Left arrow
                btn.title = 'Hide (still counting down)';
            } else {
                modal.classList.add('minimized');
                btn.textContent = '\u25B6';  // Right arrow
                btn.title = 'Show upgrade choices';
            }
        }

        // Set up hide button event listener
        document.getElementById('upgrade-hide-btn').addEventListener('click', toggleUpgradePanel);
        document.getElementById('upgrade-expand-btn').addEventListener('click', toggleUpgradePanel);

        function checkUpgradeTime() {
            if (gameOver || upgradesPaused || harvestModalOpen) return;

            const elapsed = getElapsedSeconds();
            const timeSinceLastUpgrade = elapsed - lastUpgradeTime;

            if (timeSinceLastUpgrade >= UPGRADE_INTERVAL) {
                // Show upgrade selection directly (no harvest modal)
                showUpgradeSelection();
            }
        }

        // Auto-spawn worker ant every 30 seconds
        function checkAutoSpawn() {
            if (gameOver) return;

            const elapsed = getElapsedSeconds();
            const timeSinceLastSpawn = elapsed - lastAutoSpawnTime;

            if (timeSinceLastSpawn >= AUTO_SPAWN_INTERVAL) {
                autoSpawnWorker();
                lastAutoSpawnTime = elapsed;
            }
        }

        // Spawn a worker ant automatically
        function autoSpawnWorker() {
            if (ants.length >= CONFIG.maxAnts) return;

            const angle = Math.random() * Math.PI * 2;
            const spawnDist = getColonySize() * 0.3;
            const newAnt = new Ant(
                CONFIG.nestX + Math.cos(angle) * spawnDist,
                CONFIG.nestY + Math.sin(angle) * spawnDist,
                'worker'
            );

            ants.push(newAnt);
            totalAntsSpawned++;

            // Visual feedback
            spawnFloatingText(newAnt.x, newAnt.y - 20, '+1 Worker', '#7bed9f', 12);
        }

        function resetUpgrades() {
            activeUpgrades = [];
            upgradeMultipliers = {
                antSpeed: 1,
                carryCapacity: 0,          // Reset to 0 (flat bonus)
                spawnCostReduction: 1,
                foodValue: 1,
                coinBonus: 0,
                maxAnts: 0,
                detectionRadius: 1,
                atkBonus: 0,
                defBonus: 0,
                hpBonus: 0,
                nestDefenseRadius: 80,
                nestDefenseBonus: 0,
                pheromoneStrength: 1,
                predatorHpMultiplier: 1,
                goldRushActive: false,
                goldRushEndTime: 0,
                goldRushMultiplier: 1
            };
            lastUpgradeTime = 0;
            CONFIG.maxAnts = 300;  // Reset to default
        }

        function restartGame() {
            // Hide modals
            document.getElementById('game-over-modal').classList.remove('visible');
            document.getElementById('upgrade-modal').classList.remove('visible');

            // Reset upgrades
            resetUpgrades();
            upgradesPaused = false;

            // Reset game state - go back to hive placement mode
            gameOver = false;
            gameStarted = false;  // Require hive placement again
            gameStartTime = null;
            pausedTime = 0;
            pauseStartTime = null;
            lastUpdateTime = Date.now();
            lastPredatorSpawnTime = 0;
            lastAutoSpawnTime = 0;
            coins = 50;
            totalAntsSpawned = 0;
            totalCoinsEarned = 0;

            // Clear entities - ants will spawn when hive is placed
            ants.length = 0;
            foodItems.length = 0;
            foodCollected = 0;
            antIdCounter = 0;
            antSpawnCounts = { worker: 0 };

            // Clear skilled ants panel
            skilledAnts.length = 0;
            skilledAntButtonsMap.clear();
            document.getElementById('skilled-ants-panel').innerHTML = '';

            // Reset seed and regenerate spots
            currentSeed = Date.now();
            rng = new SeededRNG(currentSeed);
            generateMapSpots();

            // Update predator positions from spots
            for (const spot of predatorSpots) {
                if (spot.type === 'spider') {
                    CONFIG.predators.spider.x = spot.x;
                    CONFIG.predators.spider.y = spot.y;
                } else if (spot.type === 'beetle') {
                    CONFIG.predators.beetle.x = spot.x;
                    CONFIG.predators.beetle.y = spot.y;
                }
            }

            // Reset predator arrays - don't spawn at start, they come from dens
            spiderPredators = [];
            beetlePredators = [];

            // Don't spawn ants yet - wait for hive placement
            // Show the hive placement overlay again
            document.getElementById('hive-placement-overlay').classList.remove('hidden');

            // Reset preview state for hive placement
            isPreviewingHivePlacement = false;
            previewMultipliers.clear();

            resize();
            updateUI();
        }

        function canAfford(cost) {
            return coins >= cost;
        }

        function spendCoins(amount) {
            if (coins >= amount) {
                coins -= amount;
                updateUI();
                return true;
            }
            return false;
        }

        function earnCoins(amount) {
            coins += amount;
            totalCoinsEarned += amount;
            updateUI();
        }

        function isInDangerZone(x, y) {
            // Check if position is near a predator spawn spot
            for (const spot of predatorSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius * 2) {
                    return true;
                }
            }
            return false;
        }

        function getDangerZoneMultiplier(x, y) {
            // Removed hidden danger zone multiplier - zone multiplier (x1, x2, x3)
            // already accounts for distance/risk and is visible to the player
            return 1;
        }

        function isNearBeetle(x, y) {
            // Check all beetles in the array
            for (const beetle of beetlePredators) {
                if (Math.hypot(x - beetle.x, y - beetle.y) < CONFIG.predators.beetle.blockRadius) {
                    return true;
                }
            }
            return false;
        }

        // ===========================================
        // SPAWN NOTIFICATIONS
        // ===========================================

        let spawnNotifications = [];

        function addSpawnNotification(antType) {
            const typeNames = {
                worker: 'Worker'
            };
            const typeColors = {
                worker: 'rgba(139, 90, 43, 0.9)'
            };
            spawnNotifications.push({
                text: `${typeNames[antType]} spawned!`,
                color: typeColors[antType],
                x: CONFIG.nestX,
                y: CONFIG.nestY - getColonySize() - 20,
                alpha: 1,
                life: 90
            });
        }

        function updateSpawnNotifications() {
            for (let i = spawnNotifications.length - 1; i >= 0; i--) {
                const notif = spawnNotifications[i];
                notif.y -= 0.5;
                notif.life--;
                notif.alpha = notif.life / 90;
                if (notif.life <= 0) {
                    spawnNotifications.splice(i, 1);
                }
            }
        }

        function drawSpawnNotifications() {
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px "DM Mono", monospace';
            for (const notif of spawnNotifications) {
                ctx.fillStyle = notif.color.replace('0.9', notif.alpha.toFixed(2));
                ctx.fillText(notif.text, notif.x, notif.y);
            }
        }

        // ===========================================
        // AMBIENT PARTICLES
        // ===========================================

        let dustMotes = [];

        function initAmbientParticles() {
            dustMotes = [];
            const numDust = Math.floor((width * height) / 25000);
            for (let i = 0; i < numDust; i++) {
                dustMotes.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: 0.5 + Math.random() * 1.5,
                    alpha: 0.08 + Math.random() * 0.15,
                    speed: 0.08 + Math.random() * 0.15,
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.008 + Math.random() * 0.015
                });
            }
        }

        function updateAmbientParticles() {
            for (const dust of dustMotes) {
                dust.wobble += dust.wobbleSpeed;
                dust.y -= dust.speed * 0.3;
                dust.x += Math.sin(dust.wobble) * 0.25;
                if (dust.y < -10) {
                    dust.y = height + 10;
                    dust.x = Math.random() * width;
                }
            }
        }

        function drawAmbientParticles() {
            for (const dust of dustMotes) {
                const gradient = ctx.createRadialGradient(dust.x, dust.y, 0, dust.x, dust.y, dust.size * 2);
                gradient.addColorStop(0, `rgba(255, 250, 220, ${dust.alpha})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ===========================================
        // GRASS SYSTEM - Reduced density
        // ===========================================

        let grassClusters = [];

        function generateGrass() {
            grassClusters = [];
            const numClusters = Math.floor((width * height) / 50000); // Reduced from 25000

            for (let i = 0; i < numClusters; i++) {
                const clusterX = Math.random() * width;
                const clusterY = Math.random() * height;

                const distToNest = Math.hypot(clusterX - CONFIG.nestX, clusterY - CONFIG.nestY);
                if (distToNest < CONFIG.nestRadius * 3) continue;

                const cluster = {
                    x: clusterX,
                    y: clusterY,
                    blades: []
                };

                const numBlades = 4 + Math.floor(Math.random() * 5); // Reduced blades per cluster
                for (let j = 0; j < numBlades; j++) {
                    cluster.blades.push({
                        offsetX: (Math.random() - 0.5) * 15,
                        offsetY: (Math.random() - 0.5) * 6,
                        height: 12 + Math.random() * 20,
                        width: 1.5 + Math.random() * 1,
                        curve: (Math.random() - 0.5) * 0.5,
                        phase: Math.random() * Math.PI * 2,
                        swaySpeed: 0.012 + Math.random() * 0.008,
                        swayAmount: 0.015 + Math.random() * 0.02,
                        color: `hsl(${95 + Math.random() * 25}, ${35 + Math.random() * 20}%, ${28 + Math.random() * 15}%)`
                    });
                }

                grassClusters.push(cluster);
            }
        }

        function drawGrass() {
            for (const cluster of grassClusters) {
                for (const blade of cluster.blades) {
                    const x = cluster.x + blade.offsetX;
                    const y = cluster.y + blade.offsetY;
                    const sway = Math.sin(time * blade.swaySpeed + blade.phase) * blade.swayAmount * blade.height;

                    ctx.save();
                    ctx.strokeStyle = blade.color;
                    ctx.lineWidth = blade.width;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    const cp1x = x + blade.curve * blade.height * 0.5 + sway * 0.3;
                    const cp1y = y - blade.height * 0.5;
                    const cp2x = x + blade.curve * blade.height + sway;
                    const cp2y = y - blade.height * 0.85;
                    const endX = x + blade.curve * blade.height * 1.2 + sway * 1.2;
                    const endY = y - blade.height;

                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        // ===========================================
        // FOREST FLOOR - Reduced clutter
        // ===========================================

        let forestElements = [];

        function generateForestElements() {
            forestElements = [];
            const numElements = Math.floor((width * height) / 30000); // Reduced from 12000

            for (let i = 0; i < numElements; i++) {
                const type = Math.random();
                let element;

                if (type < 0.4) {
                    // Fallen leaf
                    element = {
                        type: 'leaf',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 8 + Math.random() * 12,
                        rotation: Math.random() * Math.PI * 2,
                        color: ['#5a6040', '#6b7050', '#4a5535', '#7a8560'][Math.floor(Math.random() * 4)],
                        alpha: 0.3 + Math.random() * 0.25
                    };
                } else if (type < 0.7) {
                    // Pebble
                    element = {
                        type: 'pebble',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 2 + Math.random() * 4,
                        color: ['#4a4840', '#5a5850', '#3a3835', '#6a6860'][Math.floor(Math.random() * 4)],
                        alpha: 0.4 + Math.random() * 0.25
                    };
                } else {
                    // Twig
                    element = {
                        type: 'twig',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        length: 15 + Math.random() * 25,
                        rotation: Math.random() * Math.PI,
                        thickness: 1 + Math.random() * 1.5,
                        color: '#4d3a2a',
                        alpha: 0.35 + Math.random() * 0.2
                    };
                }

                const distToNest = Math.hypot(element.x - CONFIG.nestX, element.y - CONFIG.nestY);
                if (distToNest > CONFIG.nestRadius * 2.5) {
                    forestElements.push(element);
                }
            }
        }

        function drawForestElement(el) {
            ctx.save();
            ctx.globalAlpha = el.alpha;

            switch (el.type) {
                case 'leaf':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, el.size * 0.35, el.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -el.size * 0.4);
                    ctx.lineTo(0, el.size * 0.4);
                    ctx.stroke();
                    break;

                case 'pebble':
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(el.x, el.y, el.size, el.size * 0.65, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'twig':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.strokeStyle = el.color;
                    ctx.lineWidth = el.thickness;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-el.length / 2, 0);
                    ctx.lineTo(el.length / 2, 0);
                    ctx.stroke();
                    break;
            }

            ctx.restore();
        }

        // ===========================================
        // PHEROMONE GRID
        // ===========================================

        let pheromoneGrid = { food: null, home: null, cols: 0, rows: 0 };

        function initPheromoneGrid() {
            const cellSize = CONFIG.pheromoneGridSize;
            pheromoneGrid.cols = Math.ceil(width / cellSize);
            pheromoneGrid.rows = Math.ceil(height / cellSize);
            const size = pheromoneGrid.cols * pheromoneGrid.rows;
            pheromoneGrid.food = new Float32Array(size);
            pheromoneGrid.home = new Float32Array(size);
        }

        function getPheromoneIndex(x, y) {
            const col = Math.floor(x / CONFIG.pheromoneGridSize);
            const row = Math.floor(y / CONFIG.pheromoneGridSize);
            if (col < 0 || col >= pheromoneGrid.cols || row < 0 || row >= pheromoneGrid.rows) return -1;
            return row * pheromoneGrid.cols + col;
        }

        function depositPheromone(x, y, type, amount) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return;
            const grid = type === 'food' ? pheromoneGrid.food : pheromoneGrid.home;
            // Apply pheromone strength upgrade multiplier
            const effectiveAmount = amount * upgradeMultipliers.pheromoneStrength;
            grid[idx] = Math.min(grid[idx] + effectiveAmount, CONFIG.pheromoneMax);
        }

        function getPheromone(x, y, type) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return 0;
            return (type === 'food' ? pheromoneGrid.food : pheromoneGrid.home)[idx];
        }

        function samplePheromoneDirection(x, y, currentAngle, type) {
            const sampleDist = 15;
            const sampleAngle = 0.5;
            const left = getPheromone(x + Math.cos(currentAngle - sampleAngle) * sampleDist, y + Math.sin(currentAngle - sampleAngle) * sampleDist, type);
            const center = getPheromone(x + Math.cos(currentAngle) * sampleDist, y + Math.sin(currentAngle) * sampleDist, type);
            const right = getPheromone(x + Math.cos(currentAngle + sampleAngle) * sampleDist, y + Math.sin(currentAngle + sampleAngle) * sampleDist, type);

            if (center >= left && center >= right) return 0;
            return (left > right ? -1 : 1) * sampleAngle * CONFIG.pheromoneFollowStrength;
        }

        function decayPheromones() {
            const decay = CONFIG.pheromoneDecay;
            for (let i = 0; i < pheromoneGrid.food.length; i++) {
                pheromoneGrid.food[i] *= decay;
                pheromoneGrid.home[i] *= decay;
                if (pheromoneGrid.food[i] < 0.01) pheromoneGrid.food[i] = 0;
                if (pheromoneGrid.home[i] < 0.01) pheromoneGrid.home[i] = 0;
            }
        }

        // ===========================================
        // PREDATORS (Spider, Beetle)
        // ===========================================

        // Helper to get all predators as a flat array
        function getAllPredators() {
            return [...spiderPredators, ...beetlePredators];
        }

        // Helper to get predators with their type key (for card display)
        function getAllPredatorsWithKeys() {
            const result = [];
            for (const p of spiderPredators) result.push({ predator: p, key: 'spider' });
            for (const p of beetlePredators) result.push({ predator: p, key: 'beetle' });
            return result;
        }

        // Attack an ant - uses Pokemon-style damage calculation
        function attackAnt(ant, predator) {
            // Get predator's attack power
            const attackPower = predator.atk || 10;

            // Calculate actual damage (before ant's defense reduces it)
            const actualDamage = Math.floor(Math.max(1, attackPower - ant.getEffectiveDef()));

            // Show damage dealt BY predator (red number above predator)
            spawnFloatingText(predator.x, predator.y - 25, `${actualDamage}`, '#ff4444', 14, 90);

            // Ant takes damage and automatically retaliates (fights back)
            const survived = ant.takeDamage(attackPower, predator);

            if (!survived) {
                // Ant is killed - spawn death effect
                spawnDeathEffect(ant.x, ant.y, 'ant', ant.color);

                // Drop any carried food back to source
                dropCarriedFood(ant);

                const idx = ants.indexOf(ant);
                if (idx !== -1) {
                    ants.splice(idx, 1);

                    // Track death for Berserker skill (decays over time)
                    CONFIG.recentDeaths++;
                    CONFIG.deathDecayTimer = 600;  // 10 seconds of rage
                }
                return true;  // Ant died
            }

            // Ant survived the hit - give it a panic response
            ant.panicTimer = 60;
            return false;  // Ant survived
        }

        // Legacy function name for compatibility
        function killAnt(ant, predator) {
            return attackAnt(ant, predator);
        }

        // Decay recent deaths counter over time
        function updateDeathCounter() {
            if (CONFIG.deathDecayTimer > 0) {
                CONFIG.deathDecayTimer--;
                if (CONFIG.deathDecayTimer <= 0) {
                    CONFIG.recentDeaths = Math.max(0, CONFIG.recentDeaths - 1);
                    if (CONFIG.recentDeaths > 0) {
                        CONFIG.deathDecayTimer = 300;  // Decay one at a time
                    }
                }
            }
        }

        // Active combat: All ants attack nearby predators (1 attack per second)
        function checkAntPredatorCombat() {
            const COMBAT_RANGE = 20;  // How close an ant needs to be to attack
            const ATTACK_COOLDOWN = 60;  // 60 frames = 1 second at 60fps
            const FIGHTING_DURATION = 60;  // 1 second - refreshes on each hit so they stay still while fighting

            // Combine all predators into one array
            const allPredators = [...spiderPredators, ...beetlePredators];

            for (const ant of ants) {
                // Skip ants that are in the hive resting
                if (ant.hiveRestTimer > 0) continue;

                // Skip ants that are busy or panicking
                if (ant.panicTimer > 0) continue;

                // Check attack cooldown (1 attack per second)
                if (time - ant.lastAttackTime < ATTACK_COOLDOWN) continue;

                for (const predator of allPredators) {
                    // Skip stunned or dead predators
                    if (predator.state === 'stunned' || predator.state === 'dead') continue;

                    const dist = Math.hypot(ant.x - predator.x, ant.y - predator.y);

                    if (dist < COMBAT_RANGE) {
                        // Both ant and predator stop to fight
                        ant.fightingTimer = FIGHTING_DURATION;
                        predator.fightingTimer = FIGHTING_DURATION;

                        // Face each other
                        ant.angle = Math.atan2(predator.y - ant.y, predator.x - ant.x);
                        predator.angle = Math.atan2(ant.y - predator.y, ant.x - predator.x);

                        // Ant is in combat range - deal damage!
                        const antAtk = ant.getEffectiveAtk();

                        if (antAtk > 0 && predator.currentHp !== undefined) {
                            const damageDealt = Math.max(1, antAtk - (predator.def || 0));
                            predator.currentHp -= damageDealt;

                            // Record attack time for cooldown
                            ant.lastAttackTime = time;

                            // Predator counter-attacks! (if not on its own cooldown)
                            let predatorDamage = 0;
                            if (time - (predator.lastAttackTime || 0) >= 60) {
                                predator.lastAttackTime = time;
                                const predatorAtk = predator.atk || 10;
                                const antDef = ant.getEffectiveDef();
                                predatorDamage = Math.max(1, predatorAtk - antDef);
                                ant.currentHp -= predatorDamage;

                                // Check if ant died from counter-attack
                                if (ant.currentHp <= 0) {
                                    spawnDeathEffect(ant.x, ant.y, 'ant', ant.color);
                                    dropCarriedFood(ant);
                                    const idx = ants.indexOf(ant);
                                    if (idx !== -1) {
                                        ants.splice(idx, 1);
                                        CONFIG.recentDeaths++;
                                        CONFIG.deathDecayTimer = 600;
                                    }
                                }
                            }

                            // Spawn combat effect
                            const midX = (ant.x + predator.x) / 2;
                            const midY = (ant.y + predator.y) / 2;
                            spawnCombatEffect(midX, midY, Math.max(0, ant.currentHp), ant.maxHp, Math.max(0, predator.currentHp), predator.maxHp);
                            spawnFloatingText(predator.x, predator.y - 15, `${Math.floor(damageDealt)}`, '#ff4444', 11);
                            if (predatorDamage > 0) {
                                spawnFloatingText(ant.x, ant.y - 15, `${Math.floor(predatorDamage)}`, '#ff4444', 11);
                            }

                            // Check if predator is killed - remove from game permanently
                            if (predator.currentHp <= 0) {
                                removePredator(predator, ant);  // Pass killer ant for XP
                            }

                            // Only attack one predator per cooldown
                            break;
                        }
                    }
                }
            }
        }

        // Remove a predator from the game permanently
        // killerAnt: optional - the ant that dealt the killing blow (gets XP bonus)
        function removePredator(predator, killerAnt = null) {
            // Spawn death effect before removing
            const predatorColor = predator.color || { r: 100, g: 80, b: 60 };
            spawnDeathEffect(predator.x, predator.y, 'predator', predatorColor);

            predator.state = 'dead';

            // GOLD FROM ENEMY KILLS - determine gold drop based on predator type
            let goldDrop = 0;
            let xpReward = 1;  // Base XP for kill
            const spiderIdx = spiderPredators.indexOf(predator);
            if (spiderIdx !== -1) {
                // Spider drops 3-5 gold, XP scales with wave
                goldDrop = 3 + Math.floor(Math.random() * 3);
                xpReward = 1 + Math.floor((predator.wave || 0) * 0.5);  // Higher waves = more XP
                spiderPredators.splice(spiderIdx, 1);
            } else {
                const beetleIdx = beetlePredators.indexOf(predator);
                if (beetleIdx !== -1) {
                    // Beetle drops 5-8 gold, more XP since they're tougher
                    goldDrop = 5 + Math.floor(Math.random() * 4);
                    xpReward = 2 + Math.floor((predator.wave || 0) * 0.5);  // Higher base + wave bonus
                    beetlePredators.splice(beetleIdx, 1);
                }
            }

            // Award XP to the killer ant
            if (killerAnt && killerAnt.isAlive && killerAnt.isAlive()) {
                killerAnt.experience.predatorKills += xpReward;
                // SCAVENGER: +1 bonus XP for predator kill
                if (killerAnt.hasSkill('scavenger')) killerAnt.experience.scavengerBonus++;
                killerAnt.checkLevelUp();
                spawnFloatingText(killerAnt.x, killerAnt.y - 20, `+${xpReward * 5} XP`, '#00d4ff', 12, 90, killerAnt);

                // BLOODLUST SKILL: +2 ATK per kill (permanent stacking)
                if (killerAnt.hasSkill('bloodlust')) {
                    killerAnt.bloodlustStacks += 2;
                    spawnBloodlustEffect(killerAnt.x, killerAnt.y, killerAnt.bloodlustStacks);
                    spawnFloatingText(killerAnt.x, killerAnt.y - 40, ` +2 ATK!`, '#da4453', 11, 90, killerAnt);
                }

                // SCAVENGER SKILL: Show XP bonus visual
                if (killerAnt.chosenSkill && killerAnt.skillKey === 'scavenger') {
                    spawnScavengerEffect(killerAnt.x, killerAnt.y);
                }
            }

            // Award gold and show floating text
            if (goldDrop > 0) {
                // Check for Gold Hunter ability on any ant
                const hasGoldHunter = ants.some(ant => ant.harvestAbilities && ant.harvestAbilities.includes('goldHunter'));
                if (hasGoldHunter) {
                    goldDrop += 2;  // Gold Hunter bonus
                }

                // LUCKY SKILL: 50% chance for double gold (per lucky ant)
                const luckyAnts = ants.filter(ant => ant.hasSkill('lucky'));
                for (const luckyAnt of luckyAnts) {
                    if (Math.random() < 0.50) {
                        goldDrop *= 2;
                        spawnLuckyEffect(predator.x, predator.y);
                        spawnFloatingText(predator.x, predator.y - 55, ` LUCKY! 2x GOLD!`, '#8cc152', 14);
                        break;  // Only double once per kill
                    }
                }

                earnCoins(goldDrop);
                spawnFloatingText(predator.x, predator.y - 20, `+${goldDrop}g`, '#ffd700', 14);
            }
        }

        // Trailblazer beacons for Trailblazer skill
        let trailblazerBeacons = [];

        function addTrailblazerBeacon(x, y, food) {
            trailblazerBeacons.push({
                x: x,
                y: y,
                food: food,
                timer: 300,  // 5 seconds
                pulsePhase: 0
            });
        }

        function updateTrailblazerBeacons() {
            for (let i = trailblazerBeacons.length - 1; i >= 0; i--) {
                const beacon = trailblazerBeacons[i];
                beacon.timer--;
                beacon.pulsePhase += 0.15;

                if (beacon.timer <= 0) {
                    trailblazerBeacons.splice(i, 1);
                    continue;
                }

                // Attract nearby ants toward the beacon
                for (const ant of ants) {
                    if (ant.state !== 'exploring') continue;

                    const dist = Math.hypot(ant.x - beacon.x, ant.y - beacon.y);
                    if (dist < 150 && dist > 20) {
                        // Gently guide ants toward beacon
                        const angleToBeacon = Math.atan2(beacon.y - ant.y, beacon.x - ant.x);
                        const influence = 0.02 * (1 - dist / 150);
                        ant.angle += ant.angleDiff(angleToBeacon, ant.angle) * influence;
                    }
                }
            }
        }

        function drawTrailblazerBeacons() {
            for (const beacon of trailblazerBeacons) {
                const alpha = Math.min(1, beacon.timer / 60);
                const pulse = Math.sin(beacon.pulsePhase) * 0.3 + 0.7;

                ctx.save();

                // Outer glow rings
                for (let r = 3; r >= 1; r--) {
                    const radius = 20 + r * 15 + Math.sin(beacon.pulsePhase - r * 0.5) * 5;
                    ctx.beginPath();
                    ctx.arc(beacon.x, beacon.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * 0.15 * pulse / r})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Inner beacon
                ctx.beginPath();
                ctx.arc(beacon.x, beacon.y, 8 + pulse * 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha * 0.6 * pulse})`;
                ctx.fill();

                // Center bright spot
                ctx.beginPath();
                ctx.arc(beacon.x, beacon.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * pulse})`;
                ctx.fill();

                ctx.restore();
            }
        }

        class Spider {
            constructor() {
                const cfg = CONFIG.predators.spider;
                this.x = cfg.x;
                this.y = cfg.y;
                this.targetX = this.x;
                this.targetY = this.y;
                this.angle = Math.random() * Math.PI * 2;
                this.size = 18;
                this.speed = cfg.speed;
                this.legPhase = 0;
                this.state = 'hunting';
                this.eatTimer = 0;
                this.stunTimer = 0;
                this.lastAttackTime = 0;  // For 1 attack per second cooldown
                this.fightingTimer = 0;   // Timer for standing still during combat

                // New status effects
                this.slowTimer = 0;       // Movement slow
                this.burnTimer = 0;       // Burn damage over time
                this.burnSource = null;   // Who applied the burn
                this.frozenTimer = 0;     // Frozen solid
                this.fearTimer = 0;       // Fleeing in fear
                this.fearSourceX = 0;
                this.fearSourceY = 0;

                // Pokemon-style stats
                this.maxHp = cfg.hp;
                this.currentHp = cfg.hp;
                this.atk = cfg.atk;
                this.def = cfg.def;

                // Progression properties
                this.wave = 0;
                this.skill = null;
                this.skillCooldown = 0;
                this.ambushReady = true;
            }

            stun(duration) {
                // Swift skill: 50% shorter stun duration
                if (this.skill === 'swift') {
                    duration = Math.floor(duration * 0.5);
                }
                this.stunTimer = duration;
                this.state = 'stunned';
                // Note: No more respawn on death - predators are removed permanently
            }

            update() {
                // If fighting, decrement timer and skip movement
                if (this.fightingTimer > 0) {
                    this.fightingTimer--;
                    this.legPhase += 0.3;  // Still animate legs

                    // Venomous skill: Apply poison DoT while fighting
                    if (this.skill === 'venomous' && this.fightingTimer % 30 === 0) {
                        // Poison nearby ants
                        for (const ant of ants) {
                            const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                            if (dist < 30) {
                                const poisonDmg = 1;
                                ant.currentHp -= poisonDmg;
                                spawnFloatingText(ant.x, ant.y - 20, ' 1', '#ff4444', 10, 60);
                            }
                        }
                    }
                    return;
                }

                // Swift skill: Increased movement speed
                const speedBonus = this.skill === 'swift' ? 1.4 : 1;

                const cfg = CONFIG.predators.spider;
                this.legPhase += 0.2 * speedBonus;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.frozenTimer > 0) this.frozenTimer--;
                    if (this.stunTimer <= 0) this.state = 'hunting';
                    return;
                }

                // Process burn damage
                if (this.burnTimer > 0) {
                    this.burnTimer--;
                    if (this.burnTimer % 60 === 0) {  // 2 damage per second
                        this.currentHp -= 2;
                        spawnFloatingText(this.x, this.y - 15, ' 2', '#ff4500', 10, 60);
                        if (this.currentHp <= 0) {
                            removePredator(this, this.burnSource);
                            return;
                        }
                    }
                }

                // Process slow
                let slowMultiplier = 1;
                if (this.slowTimer > 0) {
                    this.slowTimer--;
                    slowMultiplier = 0.5;
                }

                // Process fear - flee from source
                if (this.fearTimer > 0) {
                    this.fearTimer--;
                    const fleeAngle = Math.atan2(this.y - this.fearSourceY, this.x - this.fearSourceX);
                    this.x += Math.cos(fleeAngle) * this.speed * 1.5;
                    this.y += Math.sin(fleeAngle) * this.speed * 1.5;
                    this.angle = fleeAngle;
                    this.legPhase += 0.4;
                    return;
                }

                if (this.state === 'eating') {
                    this.eatTimer--;
                    if (this.eatTimer <= 0) this.state = 'hunting';
                    return;
                }

                // Find nearest ant anywhere on the map (decoys take priority!)
                let nearestAnt = null;
                let nearestDist = cfg.huntRadius;
                let targetingDecoy = false;

                // Check decoys first - predators are attracted to them
                for (const decoy of decoyAnts) {
                    const dist = Math.hypot(decoy.x - this.x, decoy.y - this.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        this.targetX = decoy.x;
                        this.targetY = decoy.y;
                        targetingDecoy = true;
                    }
                }

                // If no decoy, find real ant
                if (!targetingDecoy) {
                    for (const ant of ants) {
                        const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestAnt = ant;
                        }
                    }
                }

                if (nearestAnt || targetingDecoy) {
                    if (nearestAnt && !targetingDecoy) {
                        this.targetX = nearestAnt.x;
                        this.targetY = nearestAnt.y;
                    }

                    // Check attack cooldown (1 attack per second = 60 frames)
                    if (nearestDist < cfg.killRadius && time - this.lastAttackTime >= 60) {
                        this.lastAttackTime = time;

                        // If targeting decoy, don't try to kill real ant
                        if (targetingDecoy) {
                            // Decoy combat is handled by checkMirrorDecoyCombat()
                            // Just show attack animation
                            spawnFloatingText(this.x, this.y - 20, '', '#9b59b6', 12, 60);
                        } else if (nearestAnt) {
                            // Ambush skill: First attack deals double damage
                            let tempAtk = this.atk;
                            if (this.skill === 'ambush' && this.ambushReady) {
                                this.atk = this.atk * 2;
                                this.ambushReady = false;
                                spawnFloatingText(this.x, this.y - 30, ' AMBUSH!', '#ff4757', 14, 90, this);
                            }

                            if (killAnt(nearestAnt, this)) {
                                this.state = 'eating';
                                this.eatTimer = 60;
                            }

                            // Restore original atk after ambush
                            this.atk = tempAtk;
                        }
                    }
                } else {
                    // Wander freely across the entire map - pick new target frequently
                    const distToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                    if (Math.random() < 0.02 || distToTarget < 30) {
                        const margin = 50;
                        this.targetX = margin + Math.random() * (width - margin * 2);
                        this.targetY = margin + Math.random() * (height - margin * 2);
                    }
                }

                // Move toward target freely
                const angleToTarget = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                this.angle = angleToTarget;

                const actualSpeed = this.speed * speedBonus * slowMultiplier;
                let newX = this.x + Math.cos(this.angle) * actualSpeed;
                let newY = this.y + Math.sin(this.angle) * actualSpeed;

                // Keep within screen bounds
                const margin = 20;
                newX = Math.max(margin, Math.min(width - margin, newX));
                newY = Math.max(margin, Math.min(height - margin, newY));

                this.x = newX;
                this.y = newY;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw skill aura before rotating (so it stays centered)
                if (this.skill) {
                    const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
                    let auraColor;
                    switch (this.skill) {
                        case 'ambush': auraColor = 'rgba(100, 0, 100, 0.3)'; break;
                        case 'swift': auraColor = 'rgba(0, 200, 255, 0.3)'; break;
                        case 'venomous': auraColor = 'rgba(0, 255, 100, 0.4)'; break;
                        default: auraColor = 'rgba(255, 100, 100, 0.3)';
                    }
                    ctx.fillStyle = auraColor;
                    ctx.globalAlpha = pulse * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.3;

                // Stun/Frozen effect
                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                    // Frozen visual - icy blue overlay
                    if (this.frozenTimer > 0) {
                        ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Burn visual - fiery glow
                if (this.burnTimer > 0) {
                    const burnPulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 100, 0, ${burnPulse * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(3, 3, s * 0.8, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.strokeStyle = '#1a1008';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 4; i++) {
                        const attachY = -s * 0.3 + i * s * 0.2;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.2, attachY);
                        ctx.lineTo(side * s * 0.7, attachY - s * 0.2 + phase * s * 0.15);
                        ctx.lineTo(side * s * 0.9, attachY + s * 0.3 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Abdomen
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.3, s * 0.45, s * 0.55, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#3a2a18';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.2, s * 0.2, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.25, s * 0.3, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#400808';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 80, 80, 0.5)';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.fill();

                if (this.state === 'eating') {
                    ctx.fillStyle = 'rgba(200, 50, 50, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, -s * 0.55, s * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.6;
                        const y = Math.sin(angle) * s * 0.6 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // PERSISTENT HEALTH BAR - Show during combat (when fightingTimer > 0)
                if (this.fightingTimer > 0 && this.currentHp < this.maxHp) {
                    ctx.rotate(-this.angle - Math.PI / 2);  // Unrotate so bar is horizontal

                    const barWidth = s * 2;
                    const barHeight = 5;
                    const barY = -s * 1.2;
                    const hpPercent = this.currentHp / this.maxHp;

                    // Background bar
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);

                    // HP fill - red for predators
                    let hpColor = '#ff4444';
                    if (hpPercent <= 0.2) hpColor = '#aa0000';  // Darker red when low

                    ctx.fillStyle = hpColor;
                    ctx.fillRect(-barWidth / 2, barY, barWidth * hpPercent, barHeight);

                    // Border
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-barWidth / 2, barY, barWidth, barHeight);
                }

                ctx.restore();
            }

            reset() {
                const cfg = CONFIG.predators.spider;
                this.x = cfg.x;
                this.y = cfg.y;
                this.targetX = this.x;
                this.targetY = this.y;
                this.angle = Math.random() * Math.PI * 2;
                this.state = 'hunting';
                this.eatTimer = 0;
                this.stunTimer = 0;
            }
        }

        class Beetle {
            constructor() {
                const cfg = CONFIG.predators.beetle;
                this.x = cfg.x;
                this.y = cfg.y;
                this.angle = Math.random() * Math.PI * 2;
                this.targetX = cfg.x;
                this.targetY = cfg.y;
                this.size = 22;
                this.legPhase = 0;
                this.state = 'patrolling';
                this.stunTimer = 0;
                this.wanderTimer = 0;
                this.lastAttackTime = 0;  // For 1 attack per second cooldown
                this.fightingTimer = 0;   // Timer for standing still during combat

                // New status effects
                this.slowTimer = 0;       // Movement slow
                this.burnTimer = 0;       // Burn damage over time
                this.burnSource = null;   // Who applied the burn
                this.frozenTimer = 0;     // Frozen solid
                this.fearTimer = 0;       // Fleeing in fear
                this.fearSourceX = 0;
                this.fearSourceY = 0;

                // Pokemon-style stats
                this.maxHp = cfg.hp;
                this.currentHp = cfg.hp;
                this.atk = cfg.atk;
                this.def = cfg.def;

                // Progression properties
                this.wave = 0;
                this.skill = null;
                this.regenTimer = 0;
                this.stompCooldown = 0;
            }

            stun(duration) {
                // Armored skill: 60% shorter stun duration
                if (this.skill === 'armored') {
                    duration = Math.floor(duration * 0.4);
                }
                this.stunTimer = duration;
                this.state = 'stunned';
                // Note: No more respawn on death - predators are removed permanently
            }

            update() {
                // If fighting, decrement timer and skip movement
                if (this.fightingTimer > 0) {
                    this.fightingTimer--;
                    this.legPhase += 0.15;  // Still animate legs
                    return;
                }

                // Regenerate skill: Heal 2 HP every 2 seconds if not in combat
                if (this.skill === 'regenerate' && this.fightingTimer <= 0) {
                    this.regenTimer++;
                    if (this.regenTimer >= 120) {  // 2 seconds
                        this.regenTimer = 0;
                        if (this.currentHp < this.maxHp) {
                            this.currentHp = Math.min(this.maxHp, this.currentHp + 2);
                            spawnFloatingText(this.x, this.y - 20, '2', '#7bed9f', 10, 60);
                        }
                    }
                }

                // Stomp skill cooldown
                if (this.stompCooldown > 0) this.stompCooldown--;

                const cfg = CONFIG.predators.beetle;
                this.legPhase += 0.12;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.frozenTimer > 0) this.frozenTimer--;
                    if (this.stunTimer <= 0) this.state = 'patrolling';
                    return;
                }

                // Process burn damage
                if (this.burnTimer > 0) {
                    this.burnTimer--;
                    if (this.burnTimer % 60 === 0) {  // 2 damage per second
                        this.currentHp -= 2;
                        spawnFloatingText(this.x, this.y - 15, ' 2', '#ff4500', 10, 60);
                        if (this.currentHp <= 0) {
                            removePredator(this, this.burnSource);
                            return;
                        }
                    }
                }

                // Process slow
                let slowMultiplier = 1;
                if (this.slowTimer > 0) {
                    this.slowTimer--;
                    slowMultiplier = 0.5;
                }

                // Process fear - flee from source
                if (this.fearTimer > 0) {
                    this.fearTimer--;
                    const fleeAngle = Math.atan2(this.y - this.fearSourceY, this.x - this.fearSourceX);
                    this.x += Math.cos(fleeAngle) * cfg.speed * 1.5;
                    this.y += Math.sin(fleeAngle) * cfg.speed * 1.5;
                    this.angle = fleeAngle;
                    this.legPhase += 0.25;
                    return;
                }

                // Find nearest ant to chase (decoys take priority!)
                let nearestAnt = null;
                let nearestDist = cfg.huntRadius || 300;
                let targetingDecoy = false;

                // Check decoys first - beetles are attracted to them
                for (const decoy of decoyAnts) {
                    const dist = Math.hypot(decoy.x - this.x, decoy.y - this.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        this.targetX = decoy.x;
                        this.targetY = decoy.y;
                        targetingDecoy = true;
                    }
                }

                // If no decoy, find real ant
                if (!targetingDecoy) {
                    for (const ant of ants) {
                        const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestAnt = ant;
                        }
                    }
                }

                // Stomp skill: AoE damage when multiple ants nearby
                if (this.skill === 'stomp' && this.stompCooldown <= 0) {
                    let antsInRange = 0;
                    for (const ant of ants) {
                        const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                        if (dist < 50) antsInRange++;
                    }
                    if (antsInRange >= 2) {
                        // Perform stomp!
                        this.stompCooldown = 300;  // 5 second cooldown
                        spawnFloatingText(this.x, this.y - 35, ' STOMP!', '#8b4513', 16, 90, this);
                        spawnShockwaveEffect(this.x, this.y);
                        for (const ant of ants) {
                            const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                            if (dist < 50) {
                                ant.currentHp -= 3;
                                spawnFloatingText(ant.x, ant.y - 15, '3', '#ff4444', 12, 60);
                                if (ant.currentHp <= 0) {
                                    spawnDeathEffect(ant.x, ant.y, 'ant', ant.color);
                                    dropCarriedFood(ant);
                                    const idx = ants.indexOf(ant);
                                    if (idx !== -1) ants.splice(idx, 1);
                                }
                            }
                        }
                    }
                }

                if (nearestAnt || targetingDecoy) {
                    // Chase the ant (or decoy)
                    if (nearestAnt && !targetingDecoy) {
                        this.targetX = nearestAnt.x;
                        this.targetY = nearestAnt.y;
                    }
                } else {
                    // Random wandering patrol across the entire map
                    this.wanderTimer--;
                    const distToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                    if (this.wanderTimer <= 0 || distToTarget < 30) {
                        // Pick a new random target anywhere on the map
                        const margin = 50;
                        this.targetX = margin + Math.random() * (width - margin * 2);
                        this.targetY = margin + Math.random() * (height - margin * 2);
                        this.wanderTimer = 60 + Math.random() * 120;  // New target every 1-3 seconds
                    }
                }

                // Move toward target
                const angleToTarget = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                this.angle = angleToTarget;

                const actualSpeed = cfg.patrolSpeed * slowMultiplier;
                let newX = this.x + Math.cos(this.angle) * actualSpeed;
                let newY = this.y + Math.sin(this.angle) * actualSpeed;

                // Keep within screen bounds
                const margin = 20;
                this.x = Math.max(margin, Math.min(width - margin, newX));
                this.y = Math.max(margin, Math.min(height - margin, newY));

                // Kill ants in radius (1 attack per second)
                if (time - this.lastAttackTime >= 60) {
                    for (let i = ants.length - 1; i >= 0; i--) {
                        const ant = ants[i];
                        if (Math.hypot(ant.x - this.x, ant.y - this.y) < cfg.killRadius) {
                            this.lastAttackTime = time;
                            killAnt(ant, this);
                            break;  // Only attack one ant per cooldown
                        }
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw skill aura before rotating (so it stays centered)
                if (this.skill) {
                    const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
                    let auraColor;
                    switch (this.skill) {
                        case 'stomp': auraColor = 'rgba(139, 69, 19, 0.4)'; break;
                        case 'regenerate': auraColor = 'rgba(50, 205, 50, 0.3)'; break;
                        case 'armored': auraColor = 'rgba(100, 100, 150, 0.4)'; break;
                        default: auraColor = 'rgba(100, 100, 100, 0.3)';
                    }
                    ctx.fillStyle = auraColor;
                    ctx.globalAlpha = pulse * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.2;

                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                    // Frozen visual - icy blue overlay
                    if (this.frozenTimer > 0) {
                        ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Burn visual - fiery glow
                if (this.burnTimer > 0) {
                    const burnPulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 100, 0, ${burnPulse * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(4, 4, s * 0.7, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs (6 legs, 3 per side)
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 3; i++) {
                        const attachY = -s * 0.2 + i * s * 0.25;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.3, attachY);
                        ctx.lineTo(side * s * 0.6, attachY - s * 0.1 + phase * s * 0.1);
                        ctx.lineTo(side * s * 0.75, attachY + s * 0.15 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Shell (elytra)
                ctx.fillStyle = '#2a3520';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.1, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Shell line
                ctx.strokeStyle = '#1a2510';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.4);
                ctx.lineTo(0, s * 0.6);
                ctx.stroke();

                // Shell highlights
                ctx.fillStyle = '#3a4530';
                ctx.beginPath();
                ctx.ellipse(-s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#1a2010';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.55, s * 0.3, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mandibles
                ctx.strokeStyle = '#2a1010';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s * 0.15, -s * 0.7);
                ctx.lineTo(-s * 0.25, -s * 0.85);
                ctx.moveTo(s * 0.15, -s * 0.7);
                ctx.lineTo(s * 0.25, -s * 0.85);
                ctx.stroke();

                // Antennae
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-s * 0.1, -s * 0.65);
                ctx.lineTo(-s * 0.2, -s * 0.9);
                ctx.lineTo(-s * 0.15, -s * 1.0);
                ctx.moveTo(s * 0.1, -s * 0.65);
                ctx.lineTo(s * 0.2, -s * 0.9);
                ctx.lineTo(s * 0.15, -s * 1.0);
                ctx.stroke();

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.5;
                        const y = Math.sin(angle) * s * 0.5 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // PERSISTENT HEALTH BAR - Show during combat (when fightingTimer > 0)
                if (this.fightingTimer > 0 && this.currentHp < this.maxHp) {
                    ctx.rotate(-this.angle - Math.PI / 2);  // Unrotate so bar is horizontal

                    const barWidth = s * 2;
                    const barHeight = 5;
                    const barY = -s * 1.3;
                    const hpPercent = this.currentHp / this.maxHp;

                    // Background bar
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);

                    // HP fill - red for predators
                    let hpColor = '#ff4444';
                    if (hpPercent <= 0.2) hpColor = '#aa0000';  // Darker red when low

                    ctx.fillStyle = hpColor;
                    ctx.fillRect(-barWidth / 2, barY, barWidth * hpPercent, barHeight);

                    // Border
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-barWidth / 2, barY, barWidth, barHeight);
                }

                ctx.restore();
            }

            reset() {
                const cfg = CONFIG.predators.beetle;
                this.x = cfg.x;
                this.y = cfg.y;
                this.angle = Math.random() * Math.PI * 2;
                this.targetX = cfg.x;
                this.targetY = cfg.y;
                this.state = 'patrolling';
                this.stunTimer = 0;
                this.wanderTimer = 0;
            }
        }

        // ===========================================
        // FOOD ITEMS
        // ===========================================

        let foodItems = [];
        let foodCollected = 0;

        // ===========================================
        // FOOD REWORK - LEVELING & CYCLE SYSTEM
        // ===========================================

        // Food levels persist between placements (Lv.1 to Lv.10)
        const foodLevels = {
            sugar: 1,
            protein: 1,
            fruit: 1,
            feast: 1,
            nectar: 1,
            goldenApple: 1
        };

        // Accumulated bonuses during current cycle (reset each minute)
        const accumulatedBonuses = {
            hp: 0,
            atk: 0,
            def: 0,
            carry: 0,
            abilities: []  // Lv.10 abilities earned this cycle
        };

        // Food types and their bonuses
        const FOOD_BONUSES = {
            sugar: { stat: 'hp', perUnit: 1, ability: 'goldHunter', abilityName: 'Gold Hunter', abilityDesc: '+2g per kill' },
            protein: { stat: 'atk', perUnit: 1, ability: 'lifesteal', abilityName: 'Lifesteal', abilityDesc: 'Heal on hit' },
            fruit: { stat: 'speed', perUnit: 1, ability: 'freshKeeper', abilityName: 'Fresh Keeper', abilityDesc: 'Food timer pauses while carrying' },
            feast: { stat: 'def', perUnit: 1, ability: 'thorns', abilityName: 'Thorns', abilityDesc: 'Reflect damage' },
            nectar: { stat: 'hp5', perUnit: 1, ability: 'regeneration', abilityName: 'Regeneration', abilityDesc: '+1 HP every 5 seconds' },
            goldenApple: { stat: 'all', perUnit: 1, ability: 'champion', abilityName: 'Champion', abilityDesc: 'All abilities' }
        };

        // Track food delivered this cycle for harvest summary
        let cycleDeliveries = [];  // { foodType, units, zoneMultiplier }

        // Cycle timer (20 seconds = spawn new ant)
        const CYCLE_DURATION = 20000;  // 20 seconds in ms
        let cycleStartTime = null;
        let lastCycleTime = null;

        // Track which zone is occupied by food
        const zoneOccupied = new Map();  // Map<spotIndex, foodItem>

        // Track zone cooldowns - stores end timestamp for each zone on cooldown
        const zoneCooldowns = new Map();  // Map<spotIndex, endTimestamp>
        const ZONE_COOLDOWN_DURATION = 10000;  // 10 seconds cooldown after level up

        // Track ant spawn counts for scaling costs
        let antSpawnCounts = { worker: 0 };

        function getAntSpawnCost(antType) {
            const base = CONFIG.antSpawnCosts[antType].baseCost;
            const count = antSpawnCounts[antType];
            // Cost increases by 20% for each ant of that type spawned, reduced by upgrades
            return Math.floor(base * Math.pow(1.2, count) * upgradeMultipliers.spawnCostReduction);
        }

        function spawnAnt(antType) {
            const cost = getAntSpawnCost(antType);
            if (!canAfford(cost)) return false;
            if (ants.length >= CONFIG.maxAnts) return false;
            if (gameOver) return false;

            spendCoins(cost);
            antSpawnCounts[antType]++;
            totalAntsSpawned++;

            const angle = Math.random() * Math.PI * 2;
            const spawnDist = getColonySize() * 0.3;
            const newAnt = new Ant(
                CONFIG.nestX + Math.cos(angle) * spawnDist,
                CONFIG.nestY + Math.sin(angle) * spawnDist,
                antType
            );
            ants.push(newAnt);
            addSpawnNotification(antType);
            updateAntCosts();
            return true;
        }

        function updateAntCosts() {
            for (const antType in CONFIG.antSpawnCosts) {
                const costEl = document.getElementById(`${antType}-cost`);
                if (costEl) {
                    costEl.textContent = getAntSpawnCost(antType);
                }
            }
        }

        const FOOD_LIFETIME_SECONDS = 60;  // 60 seconds until food spoils

        class FoodItem {
            constructor(x, y, type, zoneSpot = null) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = Math.random().toString(36).substr(2, 9);  // Unique ID for tracking
                const config = CONFIG.foodTypes[type];

                // Size is based on the food's current level (units = level)
                const foodLevel = foodLevels[type] || 1;
                this.size = foodLevel;  // Current size (units of food remaining)
                this.maxSize = foodLevel;  // Original size = level
                this.level = foodLevel;  // Store the level for reference
                this.baseRadius = config.baseRadius;
                this.valuePerUnit = 0;  // No gold value - gold comes from kills
                this.name = config.name;
                this.emoji = config.emoji;
                this.carriers = [];
                this.inDangerZone = isInDangerZone(x, y);
                this.zoneMultiplier = getFoodZoneMultiplier(x, y);  // Distance-based multiplier (x1, x2, x3)
                this.zoneSpot = zoneSpot;  // Reference to the zone spot this food is in
                this.spawnTime = Date.now();
                this.unitsDelivered = 0;  // Track how many units have been successfully delivered
                this.unitsDropped = 0;    // Track how many units were dropped (ant died carrying)
                this.isDepleted = false;  // True when all units have been picked up
            }

            update() {
                // Food no longer spoils - it stays until fully delivered
            }

            getTimeRemaining() {
                // Food doesn't expire anymore
                return 999;
            }

            getRadius() {
                // Radius scales with sqrt of remaining size, with min size
                const ratio = Math.max(0.3, this.size / this.maxSize);
                return this.baseRadius * Math.sqrt(ratio);
            }

            getValue() {
                // No gold value in new system - gold comes from kills only
                return 0;
            }

            // Single ant can always carry 1 unit
            canTakeUnit() {
                return this.size >= 1;
            }

            takeUnit() {
                if (this.size < 1) return 0;
                this.size -= 1;
                return 1;
            }

            isEmpty() {
                return this.size < 1;
            }

            // Check if all units have been accounted for (delivered + dropped = maxSize)
            allUnitsAccountedFor() {
                return (this.unitsDelivered + this.unitsDropped) >= this.maxSize;
            }

            // Called when units are dropped (ant died) - may trigger respawn
            onUnitsDropped(units) {
                this.unitsDropped += units;
                if (this.isDepleted && this.allUnitsAccountedFor()) {
                    this.triggerRespawn();
                }
            }

            // Called when units are delivered - may trigger respawn
            onUnitsDelivered(units) {
                this.unitsDelivered += units;
                if (this.isDepleted && this.allUnitsAccountedFor()) {
                    this.triggerRespawn();
                }
            }

            // Trigger respawn for this food
            triggerRespawn() {
                // Level up only if all units were delivered (not just dropped)
                const levelGain = this.unitsDelivered >= this.maxSize ? 1 : 0;
                const oldLevel = foodLevels[this.type];
                if (levelGain > 0) {
                    foodLevels[this.type] = Math.min(10, foodLevels[this.type] + 1);
                }
                const newLevel = foodLevels[this.type];

                if (newLevel > oldLevel) {
                    spawnFloatingText(this.x, this.y - 20, `${this.emoji} Lv.${newLevel}!`, '#00ff88', 14, 180, this);
                }

                // Check for Lv.10 ability unlock
                if (newLevel >= 10 && oldLevel < 10) {
                    const bonus = FOOD_BONUSES[this.type];
                    if (bonus && bonus.ability) {
                        spawnFloatingText(this.x, this.y - 40, `${bonus.abilityName}!`, '#ffd700', 16);
                    }
                }

                // Schedule respawn
                const respawnX = this.x;
                const respawnY = this.y;
                const respawnType = this.type;
                const respawnSpot = this.zoneSpot;

                // Clear zone occupation
                if (respawnSpot !== null) {
                    zoneOccupied.delete(respawnSpot);
                }

                // Respawn after cooldown if leveled up, else quick respawn
                const needsCooldown = levelGain > 0 || newLevel >= 10;
                const respawnDelay = needsCooldown ? ZONE_COOLDOWN_DURATION : 1000;

                if (needsCooldown && respawnSpot !== null) {
                    zoneCooldowns.set(respawnSpot, Date.now() + ZONE_COOLDOWN_DURATION);
                }

                setTimeout(() => {
                    if (respawnSpot !== null) {
                        zoneCooldowns.delete(respawnSpot);
                    }
                    respawnFoodAtZone(respawnSpot, respawnType, respawnX, respawnY);
                }, respawnDelay);
            }

            addCarrier(ant) {
                if (!this.carriers.includes(ant)) this.carriers.push(ant);
            }

            removeCarrier(ant) {
                const idx = this.carriers.indexOf(ant);
                if (idx !== -1) this.carriers.splice(idx, 1);
            }

            draw() {
                const r = this.getRadius();
                if (r < 3) return;  // Too small to draw

                const foodConfig = CONFIG.foodTypes[this.type];
                const isRare = foodConfig.isRare || false;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow (offset more so it doesn't darken the emoji)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(3, 5, r * 0.9, r * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Zone-based glow behind emoji (or special glow for rare food)
                const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.2);
                if (isRare) {
                    // Golden sparkle glow for rare food
                    const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
                    const gc = foodConfig.glowColor;
                    glowGrad.addColorStop(0, `rgba(${gc.r}, ${gc.g}, ${gc.b}, ${0.8 * pulse})`);
                    glowGrad.addColorStop(0.5, `rgba(${gc.r}, ${gc.g}, ${gc.b}, ${0.4 * pulse})`);
                    glowGrad.addColorStop(1, 'transparent');
                } else if (this.inDangerZone) {
                    // Golden/amber glow for danger zone food
                    glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.5)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 180, 50, 0.2)');
                    glowGrad.addColorStop(1, 'transparent');
                } else {
                    // Green glow for safe zone food
                    glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.4)');
                    glowGrad.addColorStop(0.5, 'rgba(100, 230, 130, 0.15)');
                    glowGrad.addColorStop(1, 'transparent');
                }
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2);
                ctx.fill();

                // Sparkle effect for rare food
                if (isRare) {
                    const sparkleCount = 4;
                    for (let i = 0; i < sparkleCount; i++) {
                        const angle = (Date.now() / 500 + i * Math.PI * 2 / sparkleCount) % (Math.PI * 2);
                        const sparkleR = r * 1.3;
                        const sx = Math.cos(angle) * sparkleR;
                        const sy = Math.sin(angle) * sparkleR;
                        const sparkleSize = 3 + Math.sin(Date.now() / 150 + i) * 1.5;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(sx, sy, sparkleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw emoji scaled to size
                const fontSize = Math.max(14, r * 2);
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);

                // Size indicator (units remaining)
                if (this.size > 1) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(r * 0.8, -r * 0.6, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px "DM Mono", monospace';
                    ctx.fillText(Math.floor(this.size), r * 0.8, -r * 0.6);
                }

                // "RARE!" indicator for rare food
                if (isRare) {
                    const bounce = Math.sin(Date.now() / 300) * 3;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 10px "DM Mono", monospace';
                    ctx.fillText('RARE!', 0, -r - 8 + bounce);
                }

                ctx.restore();
            }
        }

        // Food piece that an ant carries - tracks source food for spoilage and zone
        class CarriedFoodPiece {
            constructor(type, sourceFoodId, fromDangerZone, zoneMultiplier = 1, sourceFood = null) {
                this.type = type;
                this.emoji = CONFIG.foodTypes[type].emoji;
                this.sourceFoodId = sourceFoodId;  // Track which food this came from
                this.fromDangerZone = fromDangerZone;  // Track zone for glow color
                this.zoneMultiplier = zoneMultiplier;  // Zone multiplier (x1, x2, x3)
                this.sourceFood = sourceFood;  // Reference to source FoodItem for delivery tracking
            }
        }

        function addFood(x, y, type) {
            // Find the nearest food zone
            let nearestSpot = null;
            let nearestDist = Infinity;
            let spotIndex = -1;

            for (let i = 0; i < foodSpots.length; i++) {
                const spot = foodSpots[i];
                const dist = Math.hypot(x - spot.x, y - spot.y);
                if (dist < spot.radius && dist < nearestDist) {
                    nearestDist = dist;
                    nearestSpot = spot;
                    spotIndex = i;
                }
            }

            // Must be in a food zone
            if (!nearestSpot) return false;

            // Check if zone is already occupied
            if (zoneOccupied.has(spotIndex)) {
                spawnFloatingText(x, y, 'Zone occupied!', '#ff6b6b', 10);
                return false;
            }

            // Snap food to zone center (FREE - no cost!)
            const food = new FoodItem(nearestSpot.x, nearestSpot.y, type, spotIndex);
            foodItems.push(food);

            // Mark zone as occupied
            zoneOccupied.set(spotIndex, food);

            // Show level indicator
            const level = foodLevels[type] || 1;
            spawnFloatingText(nearestSpot.x, nearestSpot.y - 30, `Lv.${level}`, '#00ff88', 12);

            return true;
        }

        // Respawn food at a specific zone
        function respawnFoodAtZone(zoneIndex, foodType, x, y) {
            if (zoneOccupied.has(zoneIndex)) return;  // Already occupied

            const food = new FoodItem(x, y, foodType, zoneIndex);
            foodItems.push(food);
            zoneOccupied.set(zoneIndex, food);
        }

        // Drop carried food when an ant dies - restores units to source or marks as dropped
        function dropCarriedFood(ant) {
            if (!ant.carriedFoodPiece) return;

            const carried = ant.carriedFoodPiece;
            const unitsCarried = carried.units || 1;

            // Try to restore units to the source food if it still exists in the world
            if (carried.sourceFood && foodItems.includes(carried.sourceFood)) {
                carried.sourceFood.size += unitsCarried;
                // Make sure size doesn't exceed maxSize
                carried.sourceFood.size = Math.min(carried.sourceFood.size, carried.sourceFood.maxSize);
            } else if (carried.sourceFood) {
                // Source food was depleted - track dropped units for respawn logic
                carried.sourceFood.onUnitsDropped(unitsCarried);
            }

            // Clear the ant's carried food
            ant.carriedFoodPiece = null;
            ant.carriedFoodValue = 0;
        }

        // Initialize food in all zones at game start
        function initFoodInZones() {
            // Clear any existing food
            foodItems.length = 0;
            zoneOccupied.clear();

            // Spawn food in each zone using its pre-assigned food type
            for (let i = 0; i < foodSpots.length; i++) {
                const spot = foodSpots[i];
                const foodType = spot.assignedFoodType;

                const food = new FoodItem(spot.x, spot.y, foodType, i);
                foodItems.push(food);
                zoneOccupied.set(i, food);
            }
        }

        // ===========================================
        // ANTS
        // ===========================================

        let ants = [];
        let antIdCounter = 0;
        let selectedAnt = null;  // Currently selected ant for character card
        let selectedPredator = null;  // Currently selected predator for character card
        let selectedPredatorKey = null;  // Key for the selected predator (spider/beetle)

        // Ant name generator - normal human names
        const ANT_NAMES = [
            'Gustav', 'Anja', 'Erik', 'Marta', 'Felix', 'Lena', 'Otto', 'Hilda',
            'Bruno', 'Ingrid', 'Karl', 'Freya', 'Hans', 'Greta', 'Fritz', 'Elsa',
            'Max', 'Anna', 'Klaus', 'Liesel', 'Hugo', 'Heidi', 'Emil', 'Rosa',
            'Theo', 'Klara', 'Oscar', 'Maja', 'Lars', 'Petra', 'Nils', 'Vera',
            'Axel', 'Ida', 'Sven', 'Tilda', 'Rolf', 'Britta', 'Lukas', 'Sonja',
            'Kasper', 'Astrid', 'Johan', 'Sigrid', 'Anders', 'Helga', 'Olaf', 'Inga',
            'Finn', 'Linnea', 'Magnus', 'Ylva', 'Bjorn', 'Saga', 'Leif', 'Freja',
            'Henrik', 'Ebba', 'Stefan', 'Alma', 'Viktor', 'Nova', 'Anton', 'Wilma'
        ];
        let usedNames = new Set();

        function generateAntName() {
            // Try to get an unused name
            const availableNames = ANT_NAMES.filter(n => !usedNames.has(n));
            if (availableNames.length > 0) {
                const name = availableNames[Math.floor(Math.random() * availableNames.length)];
                usedNames.add(name);
                return name;
            }
            // All names used, add a number suffix
            const baseName = ANT_NAMES[Math.floor(Math.random() * ANT_NAMES.length)];
            let suffix = 2;
            while (usedNames.has(`${baseName} ${suffix}`)) suffix++;
            const fullName = `${baseName} ${suffix}`;
            usedNames.add(fullName);
            return fullName;
        }

        // Trait quality levels based on roll
        function getTraitQuality(roll) {
            if (roll >= 0.95) return { label: 'Legendary', class: 'legendary', multiplier: 1.4 };
            if (roll >= 0.85) return { label: 'Exceptional', class: 'exceptional', multiplier: 1.25 };
            if (roll >= 0.65) return { label: 'Good', class: 'good', multiplier: 1.1 };
            if (roll >= 0.35) return { label: 'Average', class: '', multiplier: 1.0 };
            if (roll >= 0.15) return { label: 'Below Avg', class: 'weak', multiplier: 0.9 };
            return { label: 'Poor', class: 'poor', multiplier: 0.8 };
        }

        // Rank titles based on experience
        function getAntRank(experience) {
            if (experience >= 100) return { title: 'Legendary', class: 'legendary' };
            if (experience >= 50) return { title: 'Veteran', class: 'exceptional' };
            if (experience >= 25) return { title: 'Experienced', class: 'good' };
            if (experience >= 10) return { title: 'Skilled', class: '' };
            if (experience >= 5) return { title: 'Novice', class: 'weak' };
            return { title: 'Rookie', class: 'poor' };
        }

        class Ant {
            constructor(x, y, type = 'worker') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = ++antIdCounter;
                this.name = generateAntName();

                // Individual trait rolls (0-1, higher is better)
                this.traitRolls = {
                    speed: Math.random(),
                    efficiency: Math.random(),
                    detection: Math.random(),
                    resilience: Math.random(),
                    goldBonus: Math.random()  // 0-100% extra gold per delivery
                };

                // Experience tracking
                this.experience = {
                    totalDeliveries: 0,
                    dangerDeliveries: 0,
                    totalValue: 0,
                    predatorEncounters: 0,
                    predatorEscapes: 0,
                    foodDiscovered: 0,      // New: times this ant found food first
                    distanceTraveled: 0,    // New: total distance moved
                    predatorKills: 0,       // Kills give significant XP
                    scavengerBonus: 0       // Scavenger skill bonus XP
                };

                // Current level (starts at 1, no max)
                this.level = 1;

                // Birth passive system (15% chance)
                this.birthPassive = null;
                this.birthAtkBonus = 0;
                this.birthHpBonus = 0;
                this.luckyDelivery = false;

                if (Math.random() < BIRTH_PASSIVE_CHANCE) {
                    const passiveKeys = Object.keys(BIRTH_PASSIVES);
                    const randomPassive = passiveKeys[Math.floor(Math.random() * passiveKeys.length)];
                    this.birthPassive = BIRTH_PASSIVES[randomPassive];
                    this.birthPassive.apply(this);
                }

                // Skill system (chosen at level 3, second at level 7)
                this.chosenSkill = null;
                this.skillKey = null;
                this.skillCooldown = 0;
                this.lastSkillUse = 0;

                // Second skill (chosen at level 7)
                this.chosenSkill2 = null;
                this.skillKey2 = null;
                this.lastSkillUse2 = 0;

                // New skill properties
                this.secondWindUsed = false;  // Second Wind can only trigger once
                this.momentumStacks = 0;  // Momentum stacks (max 20)
                this.bloodlustStacks = 0;  // Bloodlust ATK stacks (permanent)
                this.adrenalineActive = false;  // Adrenaline speed boost active
                this.adrenalineEndTime = 0;  // When adrenaline wears off
                this.lastStandTriggered = false;  // Last Stand visual shown this combat
                this.ironShellCounter = 0;  // Iron Shell block counter (blocks every other hit)

                // New skill state
                this.voidRiftX = 0;
                this.voidRiftY = 0;
                this.voidRiftEndTime = 0;
                this.shadowStepActive = false;
                this.shadowStepEndTime = 0;
                this.shadowStepBonusDamage = false;
                this.meteorTarget = null;
                this.meteorImpactTime = 0;
                // Mirror Image now uses global mirrorDecoys array
                this.spiritLinkActive = false;
                this.spiritLinkEndTime = 0;
                this.spiritLinkedAnts = [];
                this.spiritLinkedTo = null;

                // Pounce animation state
                this.isPouncing = false;
                this.pounceStartX = 0;
                this.pounceStartY = 0;
                this.pounceTargetX = 0;
                this.pounceTargetY = 0;
                this.pounceProgress = 0;
                this.pounceTarget = null;

                // Store type config reference
                this.typeConfig = CONFIG.antTypes[type] || CONFIG.antTypes.worker;

                // Initialize stats (will be recalculated)
                this.recalculateStats();

                // Store starting stats for progress visualization
                this.startingStats = {
                    speed: this.speed,
                    carryCapacity: this.carryCapacity,
                    foodDetectRadius: this.foodDetectRadius,
                    carrySpeedBonus: this.carrySpeedBonus,
                    fightChance: this.fightChance || 0,
                    trailStrength: this.trailStrength || 1,
                    spawnInterval: this.spawnInterval || 900
                };

                this.angle = Math.random() * Math.PI * 2;
                this.state = 'exploring';
                this.targetFood = null;
                this.carriedFoodPiece = null;
                this.carriedFoodValue = 0;
                this.wanderBias = (Math.random() - 0.5) * 0.1;
                this.wanderStrength = this.typeConfig.wanderStrength || CONFIG.wanderStrength;
                this.depositTimer = 0;
                this.foundFoodRecently = false;
                this.legPhase = Math.random() * Math.PI * 2;
                this.colorOffset = Math.floor(Math.random() * 15) - 7;
                this.panicTimer = 0;
                this.lastAttackTime = 0;  // Frame counter for 1 attack per second
                this.fightingTimer = 0;   // Timer for standing still during combat
                this.hiveRestTimer = 0;   // Timer for resting in hive after delivery

                // Combat properties
                this.targetPredator = null;
                this.escortTarget = null;

                // Visual properties
                this.colorConfig = this.typeConfig.color;
                this.accentColor = this.typeConfig.accentColor || this.typeConfig.color;
                this.sizeMultiplier = this.typeConfig.size || 1;

                // Position history for glowing trail (level 3+)
                this.positionHistory = [];

                // Active buffs from food delivery effects
                // Each buff: { type, value, endTime, color }
                this.activeBuffs = [];

                // HP5 stat (heal 1 HP per 5 seconds per stack)
                // Small chance (10%) to spawn with 1 natural HP5
                this.hp5Stacks = Math.random() < 0.10 ? 1 : 0;
                this.hp5LastTick = Date.now();  // Use timestamp for accurate 5-second intervals
            }

            // Apply a food delivery buff to this ant
            applyFoodBuff(foodType) {
                const foodConfig = CONFIG.foodTypes[foodType];
                if (!foodConfig || !foodConfig.effect) return { xpBonus: 0, goldMultiplier: 1, rewardText: null };

                const effect = foodConfig.effect;
                let xpBonus = 0;
                let goldMultiplier = 1;
                let rewardText = null;

                switch (effect.type) {
                    case 'permAtkBoost':
                        // Permanent ATK boost
                        this.permAtkBonus = (this.permAtkBonus || 0) + effect.value;
                        rewardText = { text: `+${effect.value} ATK`, color: foodConfig.effectColor };
                        break;

                    case 'permDefBoost':
                        // Permanent DEF boost
                        this.permDefBonus = (this.permDefBonus || 0) + effect.value;
                        rewardText = { text: `+${effect.value} DEF`, color: foodConfig.effectColor };
                        break;

                    case 'permHpBoost':
                        // Permanent max HP boost
                        this.permHpBonus = (this.permHpBonus || 0) + effect.value;
                        this.maxHp += effect.value;
                        this.currentHp += effect.value; // Also heal the added HP
                        rewardText = { text: `+${effect.value} HP`, color: foodConfig.effectColor };
                        break;

                    case 'heal':
                        // Heal 1 HP if not at max
                        if (this.currentHp < this.maxHp) {
                            this.currentHp = Math.min(this.maxHp, this.currentHp + effect.value);
                            rewardText = { text: `+${effect.value} HEAL`, color: foodConfig.effectColor };
                        }
                        break;

                    case 'xpBoost':
                        // Return XP multiplier for this delivery
                        xpBonus = effect.value;
                        rewardText = { text: `+${Math.round(effect.value * 100)}% XP`, color: foodConfig.effectColor };
                        break;

                    case 'goldenBonus':
                        // Return gold multiplier for this delivery
                        goldMultiplier = effect.goldMultiplier;
                        rewardText = { text: `${goldMultiplier}x GOLD`, color: foodConfig.effectColor };
                        break;
                }

                return { xpBonus, goldMultiplier, rewardText };
            }

            // Update and clean up expired buffs
            updateBuffs() {
                const now = Date.now();
                this.activeBuffs = this.activeBuffs.filter(buff => buff.endTime > now);
            }

            // Check if ant has any active buffs
            hasActiveBuffs() {
                return this.activeBuffs.length > 0;
            }

            // Calculate current level from XP
            getLevel() {
                const xp = this.getTotalExp();
                const thresholds = CONFIG.levelThresholds;
                for (let i = thresholds.length - 1; i >= 0; i--) {
                    if (xp >= thresholds[i]) return i + 1;
                }
                return 1;
            }

            // Get XP needed for next level (no max level)
            getXpToNextLevel() {
                const currentLevel = this.getLevel();
                const thresholds = CONFIG.levelThresholds;
                // If beyond defined thresholds, extrapolate (each level needs ~1.7x more)
                if (currentLevel >= thresholds.length) {
                    const lastThreshold = thresholds[thresholds.length - 1];
                    const extraLevels = currentLevel - thresholds.length + 1;
                    const nextThreshold = Math.floor(lastThreshold * Math.pow(1.7, extraLevels));
                    return nextThreshold - this.getTotalExp();
                }
                const nextThreshold = thresholds[currentLevel];
                return nextThreshold - this.getTotalExp();
            }

            // Get XP progress percentage to next level (no max level)
            getLevelProgress() {
                const currentLevel = this.getLevel();
                const thresholds = CONFIG.levelThresholds;
                let currentThreshold, nextThreshold;

                if (currentLevel >= thresholds.length) {
                    // Beyond defined thresholds - extrapolate
                    const lastThreshold = thresholds[thresholds.length - 1];
                    const extraLevels = currentLevel - thresholds.length;
                    currentThreshold = Math.floor(lastThreshold * Math.pow(1.7, extraLevels));
                    nextThreshold = Math.floor(lastThreshold * Math.pow(1.7, extraLevels + 1));
                } else {
                    currentThreshold = thresholds[currentLevel - 1];
                    nextThreshold = thresholds[currentLevel];
                }

                const xp = this.getTotalExp();
                return ((xp - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
            }

            // Recalculate all stats based on level and traits
            recalculateStats() {
                const typeConfig = this.typeConfig;
                const level = this.getLevel();
                const levelBonus = level - 1;  // 0 at level 1, 4 at level 5

                // NEW: +1 to ALL stats per level (simple flat bonus)
                const flatLevelBonus = levelBonus;  // +0 at L1, +1 at L2, +2 at L3, etc.

                // Get trait quality multipliers
                const speedQuality = getTraitQuality(this.traitRolls.speed);
                const detectionQuality = getTraitQuality(this.traitRolls.detection);
                const efficiencyQuality = getTraitQuality(this.traitRolls.efficiency);
                const resilienceQuality = getTraitQuality(this.traitRolls.resilience);

                // Calculate base stats with level bonuses
                const levelBonuses = typeConfig.levelBonuses || {};

                // Speed
                const baseSpeed = typeConfig.speed + (levelBonuses.speed || 0) * levelBonus;
                this.baseSpeed = baseSpeed * speedQuality.multiplier;
                this.speed = this.baseSpeed;

                // Detection
                const baseDetection = typeConfig.foodDetectRadius + (levelBonuses.foodDetectRadius || 0) * levelBonus;
                this.foodDetectRadius = baseDetection * detectionQuality.multiplier;

                // PATHFINDER SKILL: +100% detection range
                if (this.hasSkill('pathfinder')) {
                    this.foodDetectRadius *= 2;
                }

                // Carry efficiency
                const baseEfficiency = typeConfig.carrySpeedBonus + (levelBonuses.carrySpeedBonus || 0) * levelBonus;
                this.carrySpeedBonus = baseEfficiency * efficiencyQuality.multiplier;

                // HEAVY LIFTER SKILL: No speed penalty when loaded (100% carry speed bonus)
                if (this.hasSkill('heavyLifter')) {
                    this.carrySpeedBonus = 1.0;  // Full speed when carrying
                }

                // Carry capacity
                this.carryCapacity = typeConfig.carryCapacity + (levelBonuses.carryCapacity || 0) * levelBonus;

                // HEAVY LIFTER SKILL: +1 carrying capacity
                if (this.hasSkill('heavyLifter')) {
                    this.carryCapacity += 1;
                }

                // Pokemon-style combat stats (with upgrade bonuses + birth bonuses + flat level bonus)
                const birthHp = this.birthHpBonus || 0;
                const baseHp = typeConfig.hp + (levelBonuses.hp || 0) * levelBonus + upgradeMultipliers.hpBonus + birthHp + flatLevelBonus;
                const newMaxHp = Math.floor(baseHp * resilienceQuality.multiplier);
                if (this.currentHp === undefined) {
                    this.maxHp = newMaxHp;
                    this.currentHp = this.maxHp;  // Initialize HP on first calc
                } else {
                    // On stat change, heal proportionally
                    const oldMaxHp = this.maxHp || newMaxHp;
                    this.maxHp = newMaxHp;
                    this.currentHp = Math.min(this.maxHp, Math.ceil(this.currentHp * (this.maxHp / oldMaxHp)));
                }

                const birthAtk = this.birthAtkBonus || 0;
                const baseAtk = typeConfig.atk + (levelBonuses.atk || 0) * levelBonus + upgradeMultipliers.atkBonus + birthAtk + flatLevelBonus;
                this.atk = baseAtk;

                const baseDef = typeConfig.def + (levelBonuses.def || 0) * levelBonus + upgradeMultipliers.defBonus + flatLevelBonus;
                this.def = baseDef * resilienceQuality.multiplier;

                // Pheromone strength
                const basePheromone = typeConfig.pheromoneStrength + (levelBonuses.pheromoneStrength || 0) * levelBonus;
                this.pheromoneStrength = basePheromone;

                // PATHFINDER SKILL: 2x stronger pheromone trails
                if (this.hasSkill('pathfinder')) {
                    this.pheromoneStrength *= 2;
                }

                // Update level
                this.level = level;
            }

            // Get total experience points
            getTotalExp() {
                let baseXP = this.experience.totalDeliveries +
                       this.experience.dangerDeliveries * 2 +  // Danger zone worth double
                       this.experience.predatorEscapes * 3 +   // Escapes worth triple
                       Math.floor(this.experience.foodDiscovered * 0.5) +  // Bonus for discovery
                       this.experience.predatorKills * 5 +      // Kills worth 5 XP each (scales with wave)
                       (this.experience.scavengerBonus || 0);   // Scavenger bonus XP

                return baseXP;
            }

            // Check if ant just leveled up and handle it
            checkLevelUp() {
                const oldLevel = this.level;
                const newLevel = this.getLevel();
                if (newLevel > oldLevel) {
                    this.recalculateStats();

                    // Level up text follows the ant (2 seconds = 120 frames at 60fps)
                    const levelColors = { 2: '#00ffd5', 3: '#ffb464', 4: '#a855f7', 5: '#ffd700' };
                    const levelColor = levelColors[newLevel] || '#00ff88';
                    spawnFloatingText(this.x, this.y - 20, `LEVEL ${newLevel}!`, levelColor, 14, 420, this);  // 7 seconds

                    // At level 3, trigger skill choice (if no skill yet)
                    if (newLevel >= 3 && !this.chosenSkill) {
                        queueSkillChoice(this, 1);  // First skill
                    }

                    // At level 7, trigger second skill choice (if no second skill yet)
                    if (newLevel >= 7 && !this.chosenSkill2) {
                        queueSkillChoice(this, 2);  // Second skill
                    }

                    return true;
                }
                return false;
            }

            // Record a successful delivery
            recordDelivery(value, fromDangerZone) {
                this.experience.totalDeliveries++;
                this.experience.totalValue += value;
                if (fromDangerZone) {
                    this.experience.dangerDeliveries++;
                    // SCAVENGER: +1 bonus XP for danger delivery
                    if (this.hasSkill('scavenger')) this.experience.scavengerBonus++;
                }
                // SCAVENGER: +1 bonus XP for delivery
                if (this.hasSkill('scavenger')) this.experience.scavengerBonus++;

                // MOMENTUM SKILL: +5% SPD per delivery, stacks up to 20 times
                if (this.hasSkill('momentum')) {
                    if (this.momentumStacks < 20) {
                        this.momentumStacks++;
                        spawnMomentumEffect(this.x, this.y, this.momentumStacks);
                        spawnFloatingText(this.x, this.y - 35, ` x${this.momentumStacks}`, '#4fc1e9', 11, 90, this);
                    }
                }

                // HEAVY LIFTER SKILL: Show visual on delivery
                if (this.hasSkill('heavyLifter')) {
                    spawnHeavyLifterEffect(this.x, this.y);
                }

                // PATHFINDER SKILL: Show visual on delivery
                if (this.hasSkill('pathfinder')) {
                    spawnPathfinderEffect(this.x, this.y);
                }

                // Check for level up
                this.checkLevelUp();
            }

            // Record food discovery (when ant first finds a food source)
            recordFoodDiscovery() {
                this.experience.foodDiscovered++;
                // SCAVENGER: +1 bonus XP for food discovery
                if (this.hasSkill('scavenger')) this.experience.scavengerBonus++;
                this.checkLevelUp();
            }

            // Record predator encounter
            recordPredatorEncounter(escaped) {
                this.experience.predatorEncounters++;
                if (escaped) {
                    this.experience.predatorEscapes++;
                    // SCAVENGER: +1 bonus XP for predator escape
                    if (this.hasSkill('scavenger')) this.experience.scavengerBonus++;
                    this.checkLevelUp();
                }
            }

            // Check if ant has a harvest ability
            hasHarvestAbility(ability) {
                if (!this.harvestAbilities) return false;
                if (this.harvestAbilities.includes('champion')) return true;  // Champion has all abilities
                return this.harvestAbilities.includes(ability);
            }

            // Check if ant has a specific skill (in either slot)
            hasSkill(skillKey) {
                return this.skillKey === skillKey || this.skillKey2 === skillKey;
            }

            // Get the skill object for a given skill key (if the ant has it)
            getSkill(skillKey) {
                if (this.skillKey === skillKey) return this.chosenSkill;
                if (this.skillKey2 === skillKey) return this.chosenSkill2;
                return null;
            }

            // Get the last use time for a skill
            getLastSkillUse(skillKey) {
                if (this.skillKey === skillKey) return this.lastSkillUse;
                if (this.skillKey2 === skillKey) return this.lastSkillUse2;
                return 0;
            }

            // Set the last use time for a skill
            setLastSkillUse(skillKey, time) {
                if (this.skillKey === skillKey) this.lastSkillUse = time;
                else if (this.skillKey2 === skillKey) this.lastSkillUse2 = time;
            }

            // Take damage from a predator attack
            takeDamage(attackPower, predator = null) {
                // Calculate effective defense including permanent bonuses and nest defense bonus
                let effectiveDef = this.getEffectiveDef();

                // Apply Fortified Nest bonus if near the nest
                if (upgradeMultipliers.nestDefenseBonus > 0) {
                    const distToNest = Math.hypot(this.x - CONFIG.nestX, this.y - CONFIG.nestY);
                    if (distToNest <= upgradeMultipliers.nestDefenseRadius) {
                        effectiveDef += upgradeMultipliers.nestDefenseBonus;
                    }
                }

                // IRON SHELL SKILL: Block every other hit when below 30% HP
                let blockDamage = false;
                if (this.hasSkill('ironShell')) {
                    if (this.currentHp / this.maxHp < 0.3) {
                        this.ironShellCounter++;
                        if (this.ironShellCounter % 2 === 0) {
                            blockDamage = true;
                            spawnFloatingText(this.x, this.y - 35, ' BLOCKED!', '#74b9ff', 12, 90, this);
                        }
                    }
                }

                // Calculate damage: attacker's ATK minus defender's DEF (min 1 damage)
                const damage = blockDamage ? 0 : Math.max(1, Math.floor(attackPower - effectiveDef));
                this.currentHp -= damage;

                // SECOND WIND SKILL: Survive killing blow once with 50% HP
                if (this.currentHp <= 0 && this.hasSkill('secondWind') && !this.secondWindUsed) {
                    this.secondWindUsed = true;
                    this.currentHp = Math.floor(this.maxHp * 0.5);
                    spawnSecondWindEffect(this.x, this.y);
                    spawnFloatingText(this.x, this.y - 40, ' SECOND WIND!', '#ff9f43', 16, 150, this);
                }

                // THORNS ABILITY: Reflect damage when hit (harvest ability)
                if (predator && predator.currentHp !== undefined && this.hasHarvestAbility('thorns')) {
                    const thornsDamage = Math.max(1, Math.ceil(damage * 0.3));  // Reflect 30% of damage taken (min 1)
                    predator.currentHp -= thornsDamage;
                    spawnFloatingText(predator.x, predator.y - 25, ` ${thornsDamage}`, '#27ae60', 10);
                    if (predator.currentHp <= 0) {
                        removePredator(predator, this);  // Pass this ant for XP
                    }
                }

                // THORNS SKILL: Reflect 30% of damage taken back to attacker (min 1)
                if (predator && predator.currentHp !== undefined && this.hasSkill('thorns')) {
                    const thornsDamage = Math.max(1, Math.ceil(damage * 0.3));
                    predator.currentHp -= thornsDamage;
                    spawnFloatingText(predator.x, predator.y - 25, ` ${thornsDamage}`, '#27ae60', 11);
                    if (predator.currentHp <= 0) {
                        removePredator(predator, this);
                    }
                }

                // Both ant and predator stand still during combat - refresh timer on each hit
                if (predator) {
                    this.fightingTimer = 60;  // 1 second
                    predator.fightingTimer = 60;

                    // Face each other
                    this.angle = Math.atan2(predator.y - this.y, predator.x - this.x);
                    predator.angle = Math.atan2(this.y - predator.y, this.x - predator.x);
                }

                // Retaliation attack - ants always fight back when attacked (bypasses cooldown)
                if (predator && predator.currentHp !== undefined && this.currentHp > 0) {
                    const antAtk = this.getEffectiveAtk();
                    if (antAtk > 0) {
                        let retaliateDamage = Math.max(1, antAtk - (predator.def || 0));
                        predator.currentHp -= retaliateDamage;

                        // SWIFT STRIKE SKILL: 30% chance to attack twice
                        let doubleStrike = false;
                        if (this.hasSkill('swiftStrike') && Math.random() < 0.3) {
                            const bonusDamage = Math.max(1, antAtk - (predator.def || 0));
                            predator.currentHp -= bonusDamage;
                            retaliateDamage += bonusDamage;
                            doubleStrike = true;
                            spawnFloatingText(this.x, this.y - 35, ' DOUBLE!', '#e74c3c', 12, 90, this);
                        }

                        // LIFESTEAL ABILITY: Heal when dealing damage
                        if (this.hasHarvestAbility('lifesteal')) {
                            const healAmount = Math.ceil(retaliateDamage * 0.25);  // Heal 25% of damage dealt
                            this.currentHp = Math.min(this.maxHp, this.currentHp + healAmount);
                            spawnFloatingText(this.x, this.y - 25, `${healAmount}`, '#7bed9f', 10);
                        }

                        // VAMPIRE BITE skill: Heal 40% of damage dealt (active with cooldown)
                        if (this.hasSkill('vampireBite')) {
                            const vampireSkill = this.getSkill('vampireBite');
                            const now = Date.now();
                            const cooldownDone = (now - this.getLastSkillUse('vampireBite')) >= vampireSkill.cooldown;
                            if (cooldownDone) {
                                const vampHeal = Math.ceil(retaliateDamage * 0.4);
                                this.currentHp = Math.min(this.maxHp, this.currentHp + vampHeal);
                                this.setLastSkillUse('vampireBite', now);
                                spawnVampireBiteEffect(this.x, this.y, predator.x, predator.y);
                                spawnFloatingText(this.x, this.y - 35, ` ${vampHeal}`, '#7bed9f', 14, 90, this);
                            }
                        }

                        // Spawn combat effect with health indicators
                        const midX = (this.x + predator.x) / 2;
                        const midY = (this.y + predator.y) / 2;
                        spawnCombatEffect(midX, midY, this.currentHp, this.maxHp, Math.max(0, predator.currentHp), predator.maxHp);

                        // Spawn damage numbers (red for damage taken, damage dealt to predator)
                        spawnFloatingText(this.x, this.y - 15, `${Math.floor(damage)}`, '#ff4444', 11);
                        spawnFloatingText(predator.x, predator.y - 15, `${Math.floor(retaliateDamage)}`, '#ff4444', 11);

                        // Check if predator is killed by retaliation
                        if (predator.currentHp <= 0) {
                            removePredator(predator, this);  // Pass this ant for XP
                        }
                    }
                }

                // Return true if ant survives
                return this.currentHp > 0;
            }

            // Check if ant is alive
            isAlive() {
                return this.currentHp > 0;
            }

            // Get HP percentage for UI
            getHpPercent() {
                return (this.currentHp / this.maxHp) * 100;
            }

            // Get effective ATK (including Berserker skill and permanent food bonuses)
            getEffectiveAtk() {
                let atk = this.atk + (this.permAtkBonus || 0);

                // BLOODLUST SKILL: Add permanent ATK from kills
                if (this.hasSkill('bloodlust')) {
                    atk += this.bloodlustStacks;
                }

                // Berserker skill (level 3 choice): +100% ATK when below 40% HP
                if (this.hasSkill('berserker')) {
                    if (this.currentHp / this.maxHp < 0.4) {
                        atk *= 2;
                        // Visual indicator handled in draw function
                    }
                }

                // LAST STAND SKILL: 3x damage when below 50% HP
                if (this.hasSkill('lastStand')) {
                    if (this.currentHp / this.maxHp < 0.5) {
                        atk *= 3;
                        // Show visual once per combat
                        if (!this.lastStandTriggered) {
                            this.lastStandTriggered = true;
                            spawnLastStandEffect(this.x, this.y);
                            spawnFloatingText(this.x, this.y - 35, ' LAST STAND!', '#656d78', 14, 120, this);
                        }
                    } else {
                        this.lastStandTriggered = false;  // Reset when HP goes back up
                    }
                }

                // PACK HUNTER SKILL: +25% ATK per ally attacking same target
                if (this.hasSkill('packHunter') && this.targetPredator) {
                    let allyCount = 0;
                    for (const ant of ants) {
                        if (ant !== this && ant.targetPredator === this.targetPredator) {
                            allyCount++;
                        }
                    }
                    if (allyCount > 0) {
                        atk *= (1 + allyCount * 0.25);
                    }
                }

                // RALLY CRY boost: +50% ATK when affected
                if (this.rallyBoostTimer > 0) {
                    atk *= 1.5;
                }

                // SHADOW STEP bonus: 3x damage on first attack from stealth
                if (this.shadowStepActive && this.shadowStepBonusDamage) {
                    atk *= 3;
                    this.shadowStepBonusDamage = false;  // Only first attack
                    this.shadowStepActive = false;  // Break stealth
                    spawnShadowStrikeEffect(this.x, this.y);
                    spawnFloatingText(this.x, this.y - 35, ' SHADOWSTRIKE!', '#2c3e50', 14, 90, this);
                }

                // Apply temporary ATK buffs (if any still exist)
                for (const buff of this.activeBuffs) {
                    if (buff.type === 'atkBoost') {
                        atk *= (1 + buff.value);
                    }
                }

                return atk;
            }

            // Get effective DEF (including permanent food bonuses)
            getEffectiveDef() {
                return this.def + (this.permDefBonus || 0);
            }

            // Combat with predator - uses Pokemon-style stats (1 attack per second)
            attemptFight(predator) {
                // Check attack cooldown (1 attack per second = 60 frames)
                if (time - this.lastAttackTime < 60) return 'cooldown';

                // All ants can fight back based on their ATK stat
                const antAtk = this.getEffectiveAtk();

                // Deal damage to predator if we have attack power
                if (antAtk > 0 && predator.currentHp !== undefined) {
                    const damageDealt = Math.max(1, antAtk - (predator.def || 0));
                    predator.currentHp -= damageDealt;

                    // PACK HUNTER SKILL: Show visual when attacking with allies
                    if (this.hasSkill('packHunter') && this.targetPredator) {
                        let allyCount = 0;
                        for (const ant of ants) {
                            if (ant !== this && ant.targetPredator === this.targetPredator) allyCount++;
                        }
                        if (allyCount > 0 && Math.random() < 0.3) {  // 30% chance to show effect
                            spawnPackHunterEffect(this.x, this.y, allyCount);
                        }
                    }

                    // Record attack time for cooldown
                    this.lastAttackTime = time;

                    // Check if predator is killed - remove permanently
                    if (predator.currentHp <= 0) {
                        removePredator(predator, this);  // Pass this ant for XP
                        return 'win';
                    }
                }

                return 'fought';  // Combat happened but no decisive result
            }

            // Check if this ant should follow pheromones (Efficient Forager skill affects this)
            shouldFollowPheromone() {
                // Efficient Forager skill: 95% accuracy instead of 70%
                if (this.hasSkill('efficientForager')) {
                    return Math.random() < 0.95;
                }
                return Math.random() < 0.7;
            }

            // Get carry speed
            getCarrySpeed() {
                return this.speed * 0.6 * this.carrySpeedBonus;
            }

            // Get effective speed (including upgrades and skills)
            getEffectiveSpeed() {
                let speed = this.speed * upgradeMultipliers.antSpeed;

                // MOMENTUM SKILL: +5% SPD per stack (max 20 stacks = +100%)
                if (this.hasSkill('momentum')) {
                    speed *= (1 + this.momentumStacks * 0.05);
                }

                // ADRENALINE SKILL: +100% SPD while active
                if (this.adrenalineActive && Date.now() < this.adrenalineEndTime) {
                    speed *= 2;
                } else if (this.adrenalineActive) {
                    this.adrenalineActive = false;  // Deactivate when time expires
                }

                return speed;
            }

            update() {
                this.legPhase += 0.25;

                // Record position for trail effect (every frame)
                this.positionHistory.push({ x: this.x, y: this.y });
                if (this.positionHistory.length > 20) {
                    this.positionHistory.shift();
                }

                // REGENERATION ABILITY: Heal 1 HP every 5 seconds (300 frames)
                if (this.hasHarvestAbility && this.hasHarvestAbility('regeneration')) {
                    this.regenTimer = (this.regenTimer || 0) + 1;
                    if (this.regenTimer >= 300 && this.currentHp < this.maxHp) {
                        this.currentHp = Math.min(this.maxHp, this.currentHp + 1);
                        this.regenTimer = 0;
                        spawnFloatingText(this.x, this.y - 15, '1', '#7bed9f', 9);
                    }
                }

                // HP5 STAT: Heal based on hp5Stacks from nectar deliveries (1 HP per 5 sec per stack)
                // Uses real time (Date.now) and respects pause states
                if (this.hp5Stacks > 0 && !upgradesPaused && !skillChoiceModalOpen && !harvestModalOpen) {
                    const now = Date.now();
                    if (!this.hp5LastTick) this.hp5LastTick = now;

                    if (now - this.hp5LastTick >= 5000 && this.currentHp < this.maxHp) {  // Exactly 5 seconds
                        const healAmount = Math.min(this.hp5Stacks, this.maxHp - this.currentHp);
                        this.currentHp += healAmount;
                        this.hp5LastTick = now;
                        if (healAmount > 0) {
                            spawnFloatingText(this.x, this.y - 15, `+${healAmount}`, '#ff9ff3', 9);
                        }
                    }
                }

                // RALLY CRY boost timer countdown
                if (this.rallyBoostTimer > 0) {
                    this.rallyBoostTimer--;
                }

                // =====================
                // ONGOING SKILL EFFECTS
                // =====================
                const now = Date.now();

                // VOID RIFT: Pull enemies and deal damage
                if (this.voidRiftEndTime > 0 && now < this.voidRiftEndTime) {
                    for (const p of getAllPredators()) {
                        if (p.currentHp <= 0 || p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.voidRiftX, p.y - this.voidRiftY);
                        if (dist < 70 && dist > 10) {
                            // Pull toward rift
                            const pullAngle = Math.atan2(this.voidRiftY - p.y, this.voidRiftX - p.x);
                            p.x += Math.cos(pullAngle) * 1.5;
                            p.y += Math.sin(pullAngle) * 1.5;
                        }
                        // Damage every second (60 frames)
                        if (dist < 60 && time % 60 === 0) {
                            p.currentHp -= 2;
                            spawnFloatingText(p.x, p.y - 15, '2', '#4a0080', 10);
                            if (p.currentHp <= 0) removePredator(p, this);
                        }
                    }
                } else if (this.voidRiftEndTime > 0) {
                    this.voidRiftEndTime = 0;
                }

                // METEOR STRIKE: Impact when delay ends
                if (this.meteorTarget && now >= this.meteorImpactTime) {
                    const mx = this.meteorTarget.x;
                    const my = this.meteorTarget.y;
                    for (const p of getAllPredators()) {
                        if (p.currentHp <= 0) continue;
                        const dist = Math.hypot(p.x - mx, p.y - my);
                        if (dist < 60) {
                            p.currentHp -= 10;
                            spawnFloatingText(p.x, p.y - 20, '10', '#e74c3c', 16);
                            if (p.currentHp <= 0) removePredator(p, this);
                        }
                    }
                    this.meteorTarget = null;
                }

                // SHADOW STEP: Track stealth duration
                if (this.shadowStepActive && now >= this.shadowStepEndTime) {
                    this.shadowStepActive = false;
                    this.shadowStepBonusDamage = false;
                }

                // SPIRIT LINK: Track duration and cleanup
                if (this.spiritLinkActive && now >= this.spiritLinkEndTime) {
                    this.spiritLinkActive = false;
                    for (const ant of this.spiritLinkedAnts) {
                        if (ant.spiritLinkedTo === this) ant.spiritLinkedTo = null;
                    }
                    this.spiritLinkedAnts = [];
                }
                if (this.spiritLinkedTo && now >= this.spiritLinkEndTime) {
                    this.spiritLinkedTo = null;
                }

                // =====================
                // POUNCE SKILL EXECUTION
                // =====================
                if (this.isPouncing) {
                    this.pounceProgress += 0.08;

                    // Calculate arc position (parabolic jump)
                    const t = this.pounceProgress;
                    const arcHeight = 50;  // Peak height of jump
                    const arcY = -4 * arcHeight * t * (1 - t);  // Parabola

                    this.x = this.pounceStartX + (this.pounceTargetX - this.pounceStartX) * t;
                    this.y = this.pounceStartY + (this.pounceTargetY - this.pounceStartY) * t + arcY;

                    // Face target
                    this.angle = Math.atan2(this.pounceTargetY - this.pounceStartY, this.pounceTargetX - this.pounceStartX);

                    // Landing
                    if (this.pounceProgress >= 1) {
                        this.isPouncing = false;
                        this.x = this.pounceTargetX;
                        this.y = this.pounceTargetY;

                        // Deal 2x ATK damage on landing
                        if (this.pounceTarget && this.pounceTarget.currentHp > 0) {
                            const damage = Math.max(1, (this.atk * 2) - (this.pounceTarget.def || 0));
                            this.pounceTarget.currentHp -= damage;
                            spawnFloatingText(this.pounceTarget.x, this.pounceTarget.y - 20,
                                `${Math.floor(damage)}`, '#ff4444', 16);

                            // Check if killed
                            if (this.pounceTarget.currentHp <= 0) {
                                removePredator(this.pounceTarget, this);  // Pass this ant for XP
                            }
                        }
                        this.pounceTarget = null;
                    }
                    return;  // Don't do normal movement while pouncing
                }

                // Try to use POUNCE skill if available and off cooldown
                if (this.hasSkill('pounce')) {
                    const pounceSkill = this.getSkill('pounce');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('pounce')) >= pounceSkill.cooldown;

                    if (cooldownDone && !this.isPouncing) {
                        // Use ant's detection radius for pounce range (min 100, scales with DET)
                        const pounceRadius = Math.max(100, this.foodDetectRadius * 2.5);

                        // Find nearby predator to pounce
                        for (const p of getAllPredators()) {
                            if (p.state === 'stunned' || p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < pounceRadius && dist > 30) {  // Within range, not too close
                                // Start pounce!
                                this.isPouncing = true;
                                this.pounceStartX = this.x;
                                this.pounceStartY = this.y;
                                this.pounceTargetX = p.x;
                                this.pounceTargetY = p.y;
                                this.pounceProgress = 0;
                                this.pounceTarget = p;
                                this.setLastSkillUse('pounce', now);

                                spawnPounceEffect(this.x, this.y, p.x, p.y, this);
                                spawnFloatingText(this.x, this.y - 30, ' POUNCE!', '#ff6b6b', 12, 90, this);
                                break;
                            }
                        }
                    }
                }

                // Try to use SHOCKWAVE skill if available, off cooldown, and enemies nearby
                if (this.hasSkill('shockwave')) {
                    const shockwaveSkill = this.getSkill('shockwave');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('shockwave')) >= shockwaveSkill.cooldown;

                    if (cooldownDone) {
                        // Use ant's detection radius for shockwave range (min 60, scales with DET)
                        const shockwaveRadius = Math.max(60, this.foodDetectRadius * 1.5);

                        // Check if any predator is within shockwave radius
                        let nearbyPredators = [];
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < shockwaveRadius) {
                                nearbyPredators.push(p);
                            }
                        }

                        if (nearbyPredators.length > 0) {
                            // Activate shockwave!
                            this.setLastSkillUse('shockwave', now);
                            spawnShockwaveEffect(this.x, this.y, shockwaveRadius);
                            spawnFloatingText(this.x, this.y - 35, ' SHOCKWAVE!', '#00d4ff', 16, 120, this);

                            // Stun all nearby predators for 2 seconds (120 frames)
                            for (const p of nearbyPredators) {
                                p.stunTimer = 120;
                                p.state = 'stunned';
                                spawnFloatingText(p.x, p.y - 20, 'STUNNED!', '#00d4ff', 12);
                            }
                        }
                    }
                }

                // Try to use RALLY CRY skill if available, off cooldown, and allies nearby in combat
                if (this.hasSkill('rallyCry')) {
                    const rallyCrySkill = this.getSkill('rallyCry');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('rallyCry')) >= rallyCrySkill.cooldown;

                    if (cooldownDone) {
                        // Use ant's detection radius for rally range (min 80, scales with DET)
                        const rallyRadius = Math.max(80, this.foodDetectRadius * 2);

                        // Check if any friendly ant is in combat nearby
                        let nearbyAllies = [];
                        let anyInCombat = false;
                        for (const ant of ants) {
                            if (ant === this) continue;
                            const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                            if (dist < rallyRadius) {
                                nearbyAllies.push(ant);
                                if (ant.state === 'hunting' || ant.fightingTimer > 0) {
                                    anyInCombat = true;
                                }
                            }
                        }

                        // Activate if allies nearby and at least one is fighting
                        if (nearbyAllies.length >= 1 && anyInCombat) {
                            this.setLastSkillUse('rallyCry', now);
                            spawnRallyCryEffect(this.x, this.y, rallyRadius);
                            spawnFloatingText(this.x, this.y - 35, ' RALLY CRY!', '#f1c40f', 16, 120, this);

                            // Boost all nearby allies ATK for 5 seconds (300 frames)
                            for (const ant of nearbyAllies) {
                                ant.rallyBoostTimer = 300;  // 5 seconds at 60fps
                                spawnFloatingText(ant.x, ant.y - 20, '+50% ATK!', '#f1c40f', 11, 90, ant);
                            }
                            // Also boost self
                            this.rallyBoostTimer = 300;
                        }
                    }
                }

                // Try to use ADRENALINE skill if available, off cooldown, and predator nearby
                if (this.hasSkill('adrenaline')) {
                    const adrenalineSkill = this.getSkill('adrenaline');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('adrenaline')) >= adrenalineSkill.cooldown;

                    if (cooldownDone && !this.adrenalineActive) {
                        // Check if any predator is within range
                        let nearbyThreat = false;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < 100) {
                                nearbyThreat = true;
                                break;
                            }
                        }

                        if (nearbyThreat) {
                            this.setLastSkillUse('adrenaline', now);
                            this.adrenalineActive = true;
                            this.adrenalineEndTime = now + 3000;  // 3 seconds
                            spawnAdrenalineEffect(this.x, this.y);
                            spawnFloatingText(this.x, this.y - 35, ' ADRENALINE!', '#ffce54', 14, 120, this);
                        }
                    }
                }

                // Try to use DECOY skill if available, off cooldown, and being chased
                if (this.hasSkill('decoy')) {
                    const decoySkill = this.getSkill('decoy');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('decoy')) >= decoySkill.cooldown;

                    if (cooldownDone) {
                        // Check if any predator is targeting or close to this ant
                        let beingChased = false;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < 80 || p.targetAnt === this) {
                                beingChased = true;
                                break;
                            }
                        }

                        if (beingChased) {
                            this.setLastSkillUse('decoy', now);
                            spawnDecoyEffect(this.x, this.y);
                            spawnDecoyAnt(this.x, this.y, this.angle);
                            spawnFloatingText(this.x, this.y - 35, ' DECOY!', '#ac92ec', 14, 90, this);
                        }
                    }
                }

                // Try to use DASH skill if available, off cooldown, and in danger
                if (this.hasSkill('dash')) {
                    const dashSkill = this.getSkill('dash');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('dash')) >= dashSkill.cooldown;

                    if (cooldownDone) {
                        // Check if any predator is very close (fleeing scenario)
                        let nearDanger = null;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0 || p.state === 'stunned') continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < 60) {
                                nearDanger = p;
                                break;
                            }
                        }

                        if (nearDanger) {
                            this.setLastSkillUse('dash', now);
                            const dashDist = 80;
                            const dashAngle = Math.atan2(this.y - nearDanger.y, this.x - nearDanger.x);  // Dash away
                            const startX = this.x;
                            const startY = this.y;
                            this.x += Math.cos(dashAngle) * dashDist;
                            this.y += Math.sin(dashAngle) * dashDist;
                            this.bounceOffWalls();
                            spawnDashEffect(startX, startY, this.x, this.y);
                            spawnFloatingText(this.x, this.y - 35, ' DASH!', '#ec87c0', 14, 90, this);
                        }
                    }
                }

                // EARTHQUAKE SKILL: Ground slam dealing damage and slowing enemies
                if (this.hasSkill('earthquake')) {
                    const skill = this.getSkill('earthquake');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('earthquake')) >= skill.cooldown;

                    if (cooldownDone) {
                        const radius = Math.max(80, this.foodDetectRadius * 2);
                        let nearbyPredators = [];
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < radius) nearbyPredators.push(p);
                        }

                        if (nearbyPredators.length >= 1) {
                            this.setLastSkillUse('earthquake', now);
                            spawnEarthquakeEffect(this.x, this.y, radius);
                            spawnFloatingText(this.x, this.y - 35, ' EARTHQUAKE!', '#8b4513', 16, 120, this);

                            for (const p of nearbyPredators) {
                                p.currentHp -= 5;
                                p.slowTimer = 180;  // 3 seconds of 50% slow
                                spawnFloatingText(p.x, p.y - 20, '5', '#8b4513', 14);
                                if (p.currentHp <= 0) removePredator(p, this);
                            }
                        }
                    }
                }

                // CHAIN LIGHTNING SKILL: Lightning bouncing between enemies
                if (this.hasSkill('chainLightning')) {
                    const skill = this.getSkill('chainLightning');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('chainLightning')) >= skill.cooldown;

                    if (cooldownDone) {
                        // Find first target within range
                        let firstTarget = null;
                        let firstDist = 100;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0 || p.state === 'stunned') continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < firstDist) {
                                firstDist = dist;
                                firstTarget = p;
                            }
                        }

                        if (firstTarget) {
                            this.setLastSkillUse('chainLightning', now);
                            const targets = [{ x: this.x, y: this.y }, firstTarget];
                            const hit = [firstTarget];

                            // Chain to up to 3 more enemies
                            let current = firstTarget;
                            for (let i = 0; i < 3; i++) {
                                let nextTarget = null;
                                let nextDist = 120;
                                for (const p of getAllPredators()) {
                                    if (hit.includes(p) || p.currentHp <= 0) continue;
                                    const dist = Math.hypot(p.x - current.x, p.y - current.y);
                                    if (dist < nextDist) {
                                        nextDist = dist;
                                        nextTarget = p;
                                    }
                                }
                                if (nextTarget) {
                                    targets.push(nextTarget);
                                    hit.push(nextTarget);
                                    current = nextTarget;
                                } else break;
                            }

                            spawnChainLightningEffect(targets);
                            spawnFloatingText(this.x, this.y - 35, ' CHAIN LIGHTNING!', '#00bfff', 14, 120, this);

                            // Damage scales with ATK (50% of effective ATK, minimum 3)
                            const lightningDamage = Math.max(3, Math.round(this.getEffectiveAtk() * 0.5));
                            for (const p of hit) {
                                p.currentHp -= lightningDamage;
                                spawnFloatingText(p.x, p.y - 15, `${lightningDamage}`, '#00bfff', 12);
                                if (p.currentHp <= 0) removePredator(p, this);
                            }
                        }
                    }
                }

                // VOID RIFT SKILL: Create portal that pulls enemies and damages them
                if (this.hasSkill('voidRift')) {
                    const skill = this.getSkill('voidRift');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('voidRift')) >= skill.cooldown;

                    if (cooldownDone) {
                        let nearbyPredators = [];
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < 100) nearbyPredators.push(p);
                        }

                        if (nearbyPredators.length >= 1) {
                            this.setLastSkillUse('voidRift', now);
                            this.voidRiftX = this.x;
                            this.voidRiftY = this.y;
                            this.voidRiftEndTime = now + 4000;
                            spawnVoidRiftEffect(this.x, this.y, 240);
                            spawnFloatingText(this.x, this.y - 35, ' VOID RIFT!', '#4a0080', 16, 120, this);
                        }
                    }
                }

                // FIRE BREATH SKILL: Cone of fire with burn damage
                if (this.hasSkill('fireBreath')) {
                    const skill = this.getSkill('fireBreath');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('fireBreath')) >= skill.cooldown;

                    if (cooldownDone) {
                        const range = 80;
                        const coneAngle = 0.5;  // ~57 degrees cone
                        let hitPredators = [];

                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < range) {
                                const angleToP = Math.atan2(p.y - this.y, p.x - this.x);
                                const angleDiff = Math.abs(this.angleDiff(angleToP, this.angle));
                                if (angleDiff < coneAngle) hitPredators.push(p);
                            }
                        }

                        if (hitPredators.length >= 1) {
                            this.setLastSkillUse('fireBreath', now);
                            spawnFireBreathEffect(this.x, this.y, this.angle, range);
                            spawnFloatingText(this.x, this.y - 35, ' FIRE BREATH!', '#ff4500', 14, 120, this);

                            for (const p of hitPredators) {
                                p.currentHp -= 4;
                                p.burnTimer = 180;  // 3 seconds burn (2 dmg/sec)
                                p.burnSource = this;
                                spawnFloatingText(p.x, p.y - 20, '4 ', '#ff4500', 12);
                                if (p.currentHp <= 0) removePredator(p, this);
                            }
                        }
                    }
                }

                // ICE NOVA SKILL: Freeze all nearby enemies solid
                if (this.hasSkill('iceNova')) {
                    const skill = this.getSkill('iceNova');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('iceNova')) >= skill.cooldown;

                    if (cooldownDone) {
                        const radius = Math.max(100, this.foodDetectRadius * 2);
                        let nearbyPredators = [];
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0 || p.state === 'stunned') continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < radius) nearbyPredators.push(p);
                        }

                        if (nearbyPredators.length >= 1) {
                            this.setLastSkillUse('iceNova', now);
                            spawnIceNovaEffect(this.x, this.y, radius);
                            spawnFloatingText(this.x, this.y - 35, ' ICE NOVA!', '#87ceeb', 16, 120, this);

                            for (const p of nearbyPredators) {
                                p.frozenTimer = 180;  // 3 seconds frozen solid
                                p.stunTimer = 180;    // Must set stunTimer too for stun to persist
                                p.state = 'stunned';
                                spawnFloatingText(p.x, p.y - 20, 'FROZEN!', '#87ceeb', 12);
                            }
                        }
                    }
                }

                // SHADOW STEP SKILL: Become invisible, next attack is 3x damage
                if (this.hasSkill('shadowStep')) {
                    const skill = this.getSkill('shadowStep');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('shadowStep')) >= skill.cooldown;

                    if (cooldownDone && !this.shadowStepActive) {
                        // Activate when predator is nearby but not too close
                        let nearbyThreat = false;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < 120 && dist > 40) {
                                nearbyThreat = true;
                                break;
                            }
                        }

                        if (nearbyThreat) {
                            this.setLastSkillUse('shadowStep', now);
                            this.shadowStepActive = true;
                            this.shadowStepEndTime = now + 4000;
                            this.shadowStepBonusDamage = true;
                            spawnShadowStepEffect(this.x, this.y);
                            spawnFloatingText(this.x, this.y - 35, ' SHADOW STEP!', '#2c3e50', 14, 120, this);
                        }
                    }
                }

                // WAR CRY SKILL: Terrify enemies making them flee
                if (this.hasSkill('warCry')) {
                    const skill = this.getSkill('warCry');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('warCry')) >= skill.cooldown;

                    if (cooldownDone) {
                        const radius = Math.max(100, this.foodDetectRadius * 2);
                        let nearbyPredators = [];
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0 || p.state === 'stunned') continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < radius) nearbyPredators.push(p);
                        }

                        if (nearbyPredators.length >= 1) {
                            this.setLastSkillUse('warCry', now);
                            spawnWarCryEffect(this.x, this.y, radius);
                            spawnFloatingText(this.x, this.y - 35, ' WAR CRY!', '#c0392b', 16, 120, this);

                            for (const p of nearbyPredators) {
                                p.fearTimer = 180;  // 3 seconds of fear
                                p.fearSourceX = this.x;
                                p.fearSourceY = this.y;
                                spawnFloatingText(p.x, p.y - 20, 'TERRIFIED!', '#c0392b', 12);
                            }
                        }
                    }
                }

                // HEALING AURA SKILL: Heal all nearby allies
                if (this.hasSkill('healingAura')) {
                    const skill = this.getSkill('healingAura');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('healingAura')) >= skill.cooldown;

                    if (cooldownDone) {
                        const radius = 80;
                        let nearbyAllies = [];
                        let anyWounded = false;

                        for (const ant of ants) {
                            const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                            if (dist < radius) {
                                nearbyAllies.push(ant);
                                if (ant.currentHp < ant.maxHp * 0.8) anyWounded = true;
                            }
                        }

                        if (nearbyAllies.length >= 2 && anyWounded) {
                            this.setLastSkillUse('healingAura', now);
                            spawnHealingAuraEffect(this.x, this.y, radius, nearbyAllies);
                            spawnFloatingText(this.x, this.y - 35, ' HEALING AURA!', '#2ecc71', 14, 120, this);

                            for (const ant of nearbyAllies) {
                                const healAmount = Math.floor(ant.maxHp * 0.3);
                                ant.currentHp = Math.min(ant.maxHp, ant.currentHp + healAmount);
                                spawnFloatingText(ant.x, ant.y - 20, `+${healAmount}`, '#2ecc71', 11, 90, ant);
                            }
                        }
                    }
                }

                // METEOR STRIKE SKILL: Delayed massive damage in area
                if (this.hasSkill('meteorStrike')) {
                    const skill = this.getSkill('meteorStrike');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('meteorStrike')) >= skill.cooldown;

                    if (cooldownDone) {
                        // Find cluster of enemies within range of ant (150px)
                        const meteorRange = 150;
                        let bestSpot = null;
                        let bestCount = 0;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            // Only consider enemies within range of the ant
                            const distToAnt = Math.hypot(p.x - this.x, p.y - this.y);
                            if (distToAnt > meteorRange) continue;

                            let count = 0;
                            for (const p2 of getAllPredators()) {
                                if (p2.currentHp <= 0) continue;
                                const dist = Math.hypot(p2.x - p.x, p2.y - p.y);
                                if (dist < 60) count++;
                            }
                            if (count > bestCount) {
                                bestCount = count;
                                bestSpot = { x: p.x, y: p.y };
                            }
                        }

                        if (bestSpot && bestCount >= 1) {
                            this.setLastSkillUse('meteorStrike', now);
                            this.meteorTarget = bestSpot;
                            this.meteorImpactTime = now + 1500;  // 1.5s delay
                            spawnMeteorStrikeEffect(bestSpot.x, bestSpot.y, 90);
                            spawnFloatingText(this.x, this.y - 35, ' METEOR STRIKE!', '#e74c3c', 16, 120, this);
                        }
                    }
                }

                // MIRROR IMAGE SKILL: Blink back and create decoy clones
                if (this.hasSkill('mirrorImage')) {
                    const skill = this.getSkill('mirrorImage');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('mirrorImage')) >= skill.cooldown;

                    if (cooldownDone) {
                        let nearbyThreat = false;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0) continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < 100) {
                                nearbyThreat = true;
                                break;
                            }
                        }

                        if (nearbyThreat) {
                            this.setLastSkillUse('mirrorImage', now);

                            // Store original position for decoys
                            const originalX = this.x;
                            const originalY = this.y;

                            // Blink the ant backward (away from the threat)
                            // Find average threat direction and move opposite
                            let avgThreatX = 0, avgThreatY = 0, threatCount = 0;
                            for (const p of getAllPredators()) {
                                if (p.currentHp <= 0) continue;
                                const dist = Math.hypot(p.x - this.x, p.y - this.y);
                                if (dist < 100) {
                                    avgThreatX += p.x;
                                    avgThreatY += p.y;
                                    threatCount++;
                                }
                            }
                            if (threatCount > 0) {
                                avgThreatX /= threatCount;
                                avgThreatY /= threatCount;
                            }

                            // Calculate escape direction (away from threats)
                            const escapeAngle = Math.atan2(this.y - avgThreatY, this.x - avgThreatX);
                            const blinkDistance = 60;
                            const newX = this.x + Math.cos(escapeAngle) * blinkDistance;
                            const newY = this.y + Math.sin(escapeAngle) * blinkDistance;

                            // Spawn blink effect for the escape
                            spawnBlinkEffect(originalX, originalY, newX, newY);

                            // Move ant to new position
                            this.x = newX;
                            this.y = newY;

                            // Spawn 2 decoys at the original position
                            spawnMirrorDecoy(originalX + 15, originalY - 10, this);
                            spawnMirrorDecoy(originalX - 15, originalY + 10, this);

                            // Visual effect at spawn location
                            spawnMirrorImageEffect(originalX, originalY, this);
                            spawnFloatingText(originalX, originalY - 35, ' MIRROR IMAGE!', '#9b59b6', 14, 120);
                        }
                    }
                }

                // BLINK SKILL: Teleport to enemy and stun
                if (this.hasSkill('blink')) {
                    const skill = this.getSkill('blink');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('blink')) >= skill.cooldown;

                    if (cooldownDone) {
                        // Find a nearby enemy to blink to
                        let blinkTarget = null;
                        let blinkDist = 150;
                        for (const p of getAllPredators()) {
                            if (p.currentHp <= 0 || p.state === 'stunned') continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < blinkDist && dist > 40) {
                                blinkDist = dist;
                                blinkTarget = p;
                            }
                        }

                        if (blinkTarget) {
                            this.setLastSkillUse('blink', now);
                            const startX = this.x;
                            const startY = this.y;
                            // Teleport next to target
                            const angle = Math.atan2(this.y - blinkTarget.y, this.x - blinkTarget.x);
                            this.x = blinkTarget.x + Math.cos(angle) * 20;
                            this.y = blinkTarget.y + Math.sin(angle) * 20;
                            this.angle = angle + Math.PI;  // Face the target

                            spawnBlinkEffect(startX, startY, this.x, this.y);
                            spawnFloatingText(this.x, this.y - 35, ' BLINK!', '#f39c12', 14, 90, this);

                            // Stun the target
                            blinkTarget.stunTimer = 90;  // 1.5 seconds
                            blinkTarget.state = 'stunned';
                            spawnFloatingText(blinkTarget.x, blinkTarget.y - 20, 'STUNNED!', '#f39c12', 12);
                        }
                    }
                }

                // SPIRIT LINK SKILL: Link with allies to share damage (DET2 range, triggers when any ally is in combat)
                if (this.hasSkill('spiritLink')) {
                    const skill = this.getSkill('spiritLink');
                    const now = Date.now();
                    const cooldownDone = (now - this.getLastSkillUse('spiritLink')) >= skill.cooldown;

                    if (cooldownDone && !this.spiritLinkActive) {
                        const radius = this.foodDetectRadius * 2;  // Use DET2 range
                        let nearbyAllies = [];
                        let anyInCombat = false;

                        for (const ant of ants) {
                            if (ant === this) continue;
                            const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                            if (dist < radius) {
                                nearbyAllies.push(ant);
                            }
                            // Check if ANY ant is in combat (not just nearby ones)
                            if (ant.fightingTimer > 0 || ant.state === 'hunting') anyInCombat = true;
                        }

                        // Trigger when any ally on the map is in combat and we have nearby allies to link with
                        if (nearbyAllies.length >= 1 && anyInCombat) {
                            this.setLastSkillUse('spiritLink', now);
                            this.spiritLinkActive = true;
                            this.spiritLinkEndTime = now + 6000;
                            this.spiritLinkedAnts = nearbyAllies;

                            // Mark linked ants
                            for (const ant of nearbyAllies) {
                                ant.spiritLinkedTo = this;
                                ant.spiritLinkEndTime = now + 6000;
                            }

                            spawnSpiritLinkEffect(this, nearbyAllies);
                            spawnFloatingText(this.x, this.y - 35, ' SPIRIT LINK!', '#1abc9c', 14, 120, this);
                        }
                    }
                }

                // If resting in hive, decrement timer and stay put
                if (this.hiveRestTimer > 0) {
                    this.hiveRestTimer--;
                    return;
                }

                // If fighting, stand still and decrement timer
                // But allow hunting behavior so ants continue to attack!
                if (this.fightingTimer > 0) {
                    this.fightingTimer--;
                    // If we have a target predator, continue hunting (attacking) instead of just standing
                    if (this.state === 'hunting' && this.targetPredator) {
                        this.huntPredator();
                        return;
                    }
                    return;
                }

                // =====================
                // AGGRESSION SYSTEM - All ants can fight!
                // =====================
                // Priority 1: Help friendly ants being attacked
                // Priority 2: Engage enemies if strong enough
                // Priority 3: Flee if weak

                // Check for nearby predators and friendlies in danger
                let nearestPredator = null;
                let nearestPredatorDist = 80;  // Detection range for combat
                let friendlyInDanger = null;
                let friendlyInDangerDist = 100;  // Range to notice a friend in danger

                for (const p of getAllPredators()) {
                    if (p.state === 'stunned' || p.currentHp <= 0) continue;
                    const dist = Math.hypot(p.x - this.x, p.y - this.y);
                    if (dist < nearestPredatorDist) {
                        nearestPredatorDist = dist;
                        nearestPredator = p;
                    }
                }

                // Check if friendly ant is fighting a predator nearby
                for (const ant of ants) {
                    if (ant === this) continue;
                    if (ant.state === 'hunting' && ant.targetPredator) {
                        const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                        if (dist < friendlyInDangerDist) {
                            friendlyInDangerDist = dist;
                            friendlyInDanger = ant;
                        }
                    }
                }

                // Determine if this ant will fight or flee based on ATK stat
                // Ants with 3+ ATK will stand and fight, weaker ants flee
                const willFight = this.getEffectiveAtk() >= 3;

                // Priority 1: Help a friendly in danger (rush to assist)
                if (friendlyInDanger && friendlyInDanger.targetPredator && this.state !== 'hunting') {
                    const predator = friendlyInDanger.targetPredator;
                    if (predator.currentHp > 0 && predator.state !== 'stunned') {
                        // Rush to help!
                        this.targetPredator = predator;
                        this.state = 'hunting';
                        return;
                    }
                }

                // Priority 2: Engage predator if close and willing to fight
                if (nearestPredator && nearestPredatorDist < 50 && willFight && this.state !== 'hunting' && this.state !== 'carrying') {
                    this.targetPredator = nearestPredator;
                    this.state = 'hunting';
                    return;
                }

                // Priority 3: Flee if predator is close and ant is weak (or carrying food)
                // But limit flee time to 3 seconds (180 frames) so ants don't run forever
                if (nearestPredator && nearestPredatorDist < 60 && (!willFight || this.state === 'carrying')) {
                    this.fleeTimer = (this.fleeTimer || 0) + 1;

                    // Only flee if we haven't been fleeing too long (max 3 seconds)
                    if (this.fleeTimer < 180) {
                        this.panicTimer = 30;
                        const fleeAngle = Math.atan2(this.y - nearestPredator.y, this.x - nearestPredator.x);
                        this.angle = fleeAngle + (Math.random() - 0.5) * 0.5;
                        this.x += Math.cos(this.angle) * this.speed * 2.5;
                        this.y += Math.sin(this.angle) * this.speed * 2.5;
                        this.bounceOffWalls();
                        return;
                    }
                    // After max flee time, continue normal behavior (will explore/return to nest)
                } else {
                    // Reset flee timer when not actively fleeing
                    this.fleeTimer = 0;
                }

                if (this.panicTimer > 0) this.panicTimer--;

                switch (this.state) {
                    case 'exploring': this.explore(); break;
                    case 'returning': this.returnToNest(); break;
                    case 'carrying': this.carryFood(); break;
                    case 'hunting': this.huntPredator(); break;
                    case 'escorting': this.escortAnt(); break;
                }

                this.bounceOffWalls();
            }

            // Combat behavior: Hunt predators (works for all ants with aggression)
            huntPredator() {
                const predator = this.targetPredator;

                // Check if predator is still valid target
                if (!predator || predator.state === 'stunned' || predator.currentHp <= 0) {
                    this.targetPredator = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(predator.x - this.x, predator.y - this.y);

                // If close enough, attack! (matches COMBAT_RANGE = 20)
                if (dist < 20) {
                    const result = this.attemptFight(predator);
                    if (result === 'win') {
                        // Killed or stunned predator
                        this.targetPredator = null;
                        this.state = 'exploring';
                        return;
                    }

                    // Disengage if HP gets low (below 40%)
                    if (this.currentHp < this.maxHp * 0.4) {
                        this.targetPredator = null;
                        this.state = 'exploring';
                        this.panicTimer = 60;  // Flee for a bit
                        const fleeAngle = Math.atan2(this.y - predator.y, this.x - predator.x);
                        this.angle = fleeAngle;
                        return;
                    }

                    // Otherwise keep fighting (attack cooldown will handle timing)
                    return;
                }

                // Move toward predator
                const angleToTarget = Math.atan2(predator.y - this.y, predator.x - this.x);
                this.angle = angleToTarget + (Math.random() - 0.5) * 0.2;
                this.move();

                // Give up if too far
                if (dist > 150) {
                    this.targetPredator = null;
                    this.state = 'exploring';
                }
            }

            // Escort behavior for ants protecting others
            escortAnt() {
                const target = this.escortTarget;

                // Check if target is still valid
                if (!target || !ants.includes(target) || target.state !== 'carrying') {
                    this.escortTarget = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(target.x - this.x, target.y - this.y);

                // Stay close to the target
                if (dist > 25) {
                    const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                    this.angle = angleToTarget + (Math.random() - 0.5) * 0.3;
                    this.move();
                } else {
                    // Circle around the target protectively
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x) + Math.PI / 2;
                    this.x += Math.cos(this.angle) * this.speed * 0.5;
                    this.y += Math.sin(this.angle) * this.speed * 0.5;
                }

                // If predator gets close, intercept it
                for (const p of getAllPredators()) {
                    if (p.state === 'stunned') continue;
                    const predatorDist = Math.hypot(p.x - target.x, p.y - target.y);
                    if (predatorDist < 50) {
                        this.targetPredator = p;
                        this.escortTarget = null;
                        this.state = 'hunting';
                        return;
                    }
                }

                // Stop escorting if target leaves danger zone
                if (!isInDangerZone(target.x, target.y)) {
                    this.escortTarget = null;
                    this.state = 'exploring';
                }
            }

            explore() {
                // If ant has spotted food, head toward it
                if (this.targetFood && !this.targetFood.isEmpty()) {
                    const dist = Math.hypot(this.targetFood.x - this.x, this.targetFood.y - this.y);
                    // Keep heading toward food with slight wobble
                    this.angle = Math.atan2(this.targetFood.y - this.y, this.targetFood.x - this.x);
                    this.angle += (Math.random() - 0.5) * 0.2;  // Small wobble
                } else {
                    // Clear invalid target
                    this.targetFood = null;

                    if (!this.shouldFollowPheromone()) {
                        // Wander if not following pheromone (unless they have Efficient Forager)
                        this.angle += (Math.random() - 0.5) * this.wanderStrength + this.wanderBias;
                    } else {
                        // Follow pheromone trails
                        const turn = samplePheromoneDirection(this.x, this.y, this.angle, 'food');
                        this.angle += turn + (Math.random() - 0.5) * CONFIG.wanderStrength * 0.4;
                    }
                }

                this.depositTimer++;
                if (this.depositTimer > 6) {
                    const distToNest = this.distanceToNest();
                    depositPheromone(this.x, this.y, 'home', CONFIG.pheromoneDeposit * this.pheromoneStrength * Math.max(0.15, 1 - distToNest / 350));
                    this.depositTimer = 0;
                }

                this.move();
                this.checkForFood();

                if (Math.random() < 0.0004) {
                    this.state = 'returning';
                    this.foundFoodRecently = false;
                }
            }

            checkForFood() {
                // Detection radius is how far the ant can SEE food
                // Detection trait gives up to 20% bonus, plus upgrade bonus
                const detectionBonus = 1 + (this.traitRolls.detection - 0.5) * 0.4;  // 0.8x to 1.2x
                const baseDetectionRange = this.foodDetectRadius * detectionBonus * upgradeMultipliers.detectionRadius;

                // Pickup radius is small - ant must actually reach the food
                const pickupRadius = 8;

                for (const food of foodItems) {
                    const dist = Math.hypot(this.x - food.x, this.y - food.y);
                    const foodRadius = food.getRadius();

                    // Check for food attraction effect (feast food has 2x detection range)
                    const foodConfig = CONFIG.foodTypes[food.type];
                    const attractMultiplier = (foodConfig.effect && foodConfig.effect.type === 'attract')
                        ? foodConfig.effect.detectMultiplier : 1;
                    const effectiveDetectionRange = baseDetectionRange * attractMultiplier;

                    // Close enough to pick up?
                    if (dist < pickupRadius + foodRadius) {
                        if (food.canTakeUnit()) {
                            this.pickUpFoodUnit(food);
                        } else {
                            // Food is depleted, leave pheromone and mark as found
                            depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 6);
                            this.state = 'returning';
                            this.foundFoodRecently = true;
                        }
                        break;
                    }
                    // Can detect food from far away? Move toward it!
                    else if (dist < effectiveDetectionRange + foodRadius && !this.targetFood) {
                        // Spotted food - head toward it
                        this.targetFood = food;
                        this.angle = Math.atan2(food.y - this.y, food.x - this.x);
                        // Leave a food pheromone to help others
                        depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 2);
                        break;
                    }
                }
            }

            pickUpFoodUnit(food) {
                // Capacity determines how many units ant can carry at once (1 = 1 unit, 2 = 2 units, etc)
                // Include upgrade bonus for carry capacity
                const capacity = Math.max(1, Math.floor(this.carryCapacity + upgradeMultipliers.carryCapacity));
                const unitsToTake = Math.min(capacity, Math.floor(food.size));

                // Take units from the food
                let unitsTaken = 0;
                for (let i = 0; i < unitsToTake; i++) {
                    if (food.takeUnit() > 0) {
                        unitsTaken++;
                    } else {
                        break;
                    }
                }

                if (unitsTaken > 0) {
                    // Record food discovery for XP
                    this.recordFoodDiscovery();

                    // Trailblazer skill: create beacon when finding food
                    if (this.hasSkill('trailblazer')) {
                        addTrailblazerBeacon(food.x, food.y, food);
                    }

                    this.carriedFoodPiece = new CarriedFoodPiece(food.type, food.id, food.inDangerZone, food.zoneMultiplier, food);
                    this.carriedFoodPiece.units = unitsTaken;  // Track how many units carried
                    this.carriedFoodValue = 0;  // No gold value in new system
                    this.targetFood = food;
                    this.state = 'carrying';
                    this.angle = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);

                    // Mark food as depleted when empty (will respawn when all units accounted for)
                    if (food.isEmpty()) {
                        food.isDepleted = true;
                        const idx = foodItems.indexOf(food);
                        if (idx !== -1) foodItems.splice(idx, 1);
                        // Clear zone occupation so respawn can happen when all units are delivered/dropped
                        if (food.zoneSpot !== null && food.zoneSpot !== undefined) {
                            zoneOccupied.delete(food.zoneSpot);
                        }
                    }
                }
            }

            carryFood() {
                // Ant is carrying a food piece back to nest
                if (!this.carriedFoodPiece) {
                    this.state = 'exploring';
                    return;
                }

                // Move toward nest
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const turnRate = 0.1;
                const angleDiff = this.angleDiff(angleToNest, this.angle);
                this.angle += angleDiff * turnRate;

                // Ants move slower when carrying, adjusted by carrySpeedBonus
                const carrySpeed = this.getCarrySpeed();
                this.x += Math.cos(this.angle) * carrySpeed;
                this.y += Math.sin(this.angle) * carrySpeed;

                // Deposit pheromones
                this.depositTimer++;
                if (this.depositTimer > 4) {
                    depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 3);
                    this.depositTimer = 0;
                }

                // Check if reached nest
                const distToNest = this.distanceToNest();
                if (distToNest < getColonySize()) {
                    // Count units delivered
                    const unitsDelivered = this.carriedFoodPiece.units || 1;
                    const deliveredFoodType = this.carriedFoodPiece.type;
                    const zoneMultiplier = this.carriedFoodPiece.zoneMultiplier || 1;
                    const foodConfig = CONFIG.foodTypes[deliveredFoodType];

                    // Record experience for the delivering ant
                    for (let i = 0; i < unitsDelivered; i++) {
                        this.recordDelivery(1, this.carriedFoodPiece.fromDangerZone);
                    }

                    // FOOD REWORK: Apply bonuses directly to the delivering ant
                    const bonus = FOOD_BONUSES[deliveredFoodType];
                    if (bonus) {
                        const totalBonus = unitsDelivered * bonus.perUnit * zoneMultiplier;

                        if (bonus.stat === 'all') {
                            // Golden Apple gives +1 to ALL stats per unit
                            this.maxHp += totalBonus;
                            this.currentHp += totalBonus;  // Also heal by the HP gained
                            this.atk += totalBonus;
                            this.def += totalBonus;
                            this.carryCapacity += totalBonus;
                        } else if (bonus.stat === 'hp') {
                            this.maxHp += totalBonus;
                            this.currentHp += totalBonus;  // Also heal by the HP gained
                        } else if (bonus.stat === 'atk') {
                            this.atk += totalBonus;
                        } else if (bonus.stat === 'def') {
                            this.def += totalBonus;
                        } else if (bonus.stat === 'speed') {
                            // Speed bonus: +0.05 speed per unit (so +1 = 5% faster)
                            this.speed += totalBonus * 0.05;
                        } else if (bonus.stat === 'hp5') {
                            // HP5: Passive regen - heal 1 HP per 5 seconds per stack
                            this.hp5Stacks = (this.hp5Stacks || 0) + totalBonus;
                        }

                        // Check if this food type is Lv.10 for ability (still accumulated for colony)
                        if (foodLevels[deliveredFoodType] >= 10) {
                            if (!accumulatedBonuses.abilities.includes(bonus.ability)) {
                                accumulatedBonuses.abilities.push(bonus.ability);
                            }
                        }
                    }

                    // Track delivery for harvest summary
                    cycleDeliveries.push({
                        foodType: deliveredFoodType,
                        units: unitsDelivered,
                        zoneMultiplier: zoneMultiplier,
                        emoji: foodConfig.emoji
                    });

                    // Update food item's delivered count (triggers respawn when all units accounted for)
                    if (this.carriedFoodPiece.sourceFood) {
                        this.carriedFoodPiece.sourceFood.onUnitsDelivered(unitsDelivered);
                    }

                    foodCollected += unitsDelivered;

                    // LUCKY BIRTH PASSIVE: 20% chance for +1 gold on delivery
                    if (this.luckyDelivery && Math.random() < 0.2) {
                        earnCoins(1);
                        spawnFloatingText(this.x, this.y - 25, ' +1g', '#ffd700', 10);
                    }

                    // Show bonus gained floating text on the delivering ant
                    const bonusText = bonus ?
                        (bonus.stat === 'all' ? `+${unitsDelivered * zoneMultiplier} ALL` :
                        `+${unitsDelivered * bonus.perUnit * zoneMultiplier} ${bonus.stat.toUpperCase()}`) :
                        '+Food';
                    spawnFloatingText(this.x, this.y - 25, bonusText, foodConfig.effectColor || '#00ff88', 12, 120, this);

                    // Reset state
                    this.carriedFoodPiece = null;
                    this.carriedFoodValue = 0;
                    this.targetFood = null;
                    this.foundFoodRecently = true;

                    // No rest delay - ant immediately goes back to exploring
                    this.state = 'exploring';
                }
            }

            returnToNest() {
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const pheromoneTurn = samplePheromoneDirection(this.x, this.y, this.angle, 'home');
                const directTurn = this.angleDiff(angleToNest, this.angle) * 0.12;

                this.angle += directTurn + pheromoneTurn * 0.4 + (Math.random() - 0.5) * 0.08;

                if (this.foundFoodRecently) {
                    this.depositTimer++;
                    if (this.depositTimer > 4) {
                        depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 2.5);
                        this.depositTimer = 0;
                    }
                }

                this.move();

                if (this.distanceToNest() < getColonySize()) {
                    this.state = 'exploring';
                    this.foundFoodRecently = false;
                    this.targetFood = null;  // Clear so ant can spot new food
                    this.angle += Math.PI + (Math.random() - 0.5) * 1.2;
                }
            }

            move() {
                const effectiveSpeed = this.getEffectiveSpeed();
                const dx = Math.cos(this.angle) * effectiveSpeed;
                const dy = Math.sin(this.angle) * effectiveSpeed;
                this.x += dx;
                this.y += dy;

                // Track distance traveled for stats
                this.experience.distanceTraveled += Math.abs(dx) + Math.abs(dy);
            }

            bounceOffWalls() {
                const margin = 15;
                if (this.x < margin) { this.x = margin; this.angle = Math.PI - this.angle; }
                if (this.x > width - margin) { this.x = width - margin; this.angle = Math.PI - this.angle; }
                if (this.y < margin) { this.y = margin; this.angle = -this.angle; }
                if (this.y > height - margin) { this.y = height - margin; this.angle = -this.angle; }
            }

            distanceToNest() {
                return Math.hypot(this.x - CONFIG.nestX, this.y - CONFIG.nestY);
            }

            angleDiff(target, current) {
                let diff = target - current;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                return diff;
            }

            draw() {
                const antLevel = this.getLevel();

                // Draw sci-fi energy trail for level 2+ only
                if (antLevel >= 2 && this.positionHistory.length > 3) {
                    // Bright neon color palette - cycles for high levels
                    const trailThemes = {
                        2: { core: [0, 255, 200], glow: [0, 255, 255] },    // Cyan
                        3: { core: [100, 180, 255], glow: [150, 220, 255] }, // Electric blue
                        4: { core: [200, 100, 255], glow: [230, 150, 255] }, // Violet
                        5: { core: [255, 220, 100], glow: [255, 255, 180] }  // Golden
                    };

                    // For levels 6+, cycle through themes or use golden
                    const themeLevel = antLevel <= 5 ? antLevel : ((antLevel - 2) % 4) + 2;
                    const theme = trailThemes[themeLevel] || trailThemes[5];
                    const time = Date.now() * 0.005;
                    const len = this.positionHistory.length;

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Outer glow layer - BRIGHT
                    for (let i = 1; i < len; i++) {
                        const progress = i / len;
                        const glowAlpha = progress * (0.15 + antLevel * 0.08);
                        const glowWidth = progress * (4 + antLevel * 2);

                        ctx.strokeStyle = `rgba(${theme.glow[0]}, ${theme.glow[1]}, ${theme.glow[2]}, ${glowAlpha})`;
                        ctx.lineWidth = glowWidth;
                        ctx.beginPath();
                        ctx.moveTo(this.positionHistory[i - 1].x, this.positionHistory[i - 1].y);
                        ctx.lineTo(this.positionHistory[i].x, this.positionHistory[i].y);
                        ctx.stroke();
                    }

                    // Core energy line - bright white/color center
                    for (let i = 1; i < len; i++) {
                        const progress = i / len;
                        const coreAlpha = progress * (0.5 + antLevel * 0.1);
                        const coreWidth = progress * (1.5 + antLevel * 0.5);

                        ctx.strokeStyle = `rgba(${theme.core[0]}, ${theme.core[1]}, ${theme.core[2]}, ${coreAlpha})`;
                        ctx.lineWidth = coreWidth;
                        ctx.beginPath();
                        ctx.moveTo(this.positionHistory[i - 1].x, this.positionHistory[i - 1].y);
                        ctx.lineTo(this.positionHistory[i].x, this.positionHistory[i].y);
                        ctx.stroke();
                    }

                    // Energy nodes for level 3+
                    if (antLevel >= 3) {
                        const nodeInterval = 4;
                        for (let i = nodeInterval; i < len; i += nodeInterval) {
                            const pos = this.positionHistory[i];
                            const progress = i / len;
                            const pulse = 0.7 + Math.sin(time + i) * 0.3;
                            const nodeSize = (2 + antLevel) * progress * pulse;

                            // Glowing node
                            ctx.fillStyle = `rgba(${theme.glow[0]}, ${theme.glow[1]}, ${theme.glow[2]}, ${0.6 * progress})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
                            ctx.fill();

                            // White hot center
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * progress})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, nodeSize * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                ctx.save();
                ctx.translate(this.x, this.y);

                // SHADOW STEP: Ant becomes semi-transparent while stealthed
                if (this.shadowStepActive) {
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                    // Dark shadow aura
                    const shadowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
                    shadowGrad.addColorStop(0, 'rgba(44, 62, 80, 0.5)');
                    shadowGrad.addColorStop(0.7, 'rgba(44, 62, 80, 0.2)');
                    shadowGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = shadowGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Rally Cry buff glow (golden aura before rotation)
                if (this.rallyBoostTimer > 0) {
                    const pulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
                    const rallyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                    rallyGrad.addColorStop(0, `rgba(255, 215, 0, ${0.4 * pulse})`);
                    rallyGrad.addColorStop(0.5, `rgba(241, 196, 15, ${0.2 * pulse})`);
                    rallyGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = rallyGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.rotate(this.angle);

                // Size increases with level (35% per level above 1) - level 5 is 140% bigger!
                // Thick-Skinned passive also adds +15% size
                let sizeMultiplier = this.sizeMultiplier;
                if (this.birthPassive && this.birthHpBonus) {
                    sizeMultiplier *= 1.15;
                }
                const levelSizeBonus = 1 + (antLevel - 1) * 0.35;
                const size = CONFIG.antSize * sizeMultiplier * levelSizeBonus;
                const legWave = Math.sin(this.legPhase) * 0.35;

                // Type-based colors - use accent for highlights
                let baseColor = this.colorConfig || CONFIG.antTypes.worker.color;
                const accent = this.accentColor || baseColor;

                // Birth passive color tints
                if (this.birthPassive) {
                    const tint = this.birthPassive.color;
                    baseColor = {
                        r: Math.floor(baseColor.r * 0.7 + tint.r * 0.3),
                        g: Math.floor(baseColor.g * 0.7 + tint.g * 0.3),
                        b: Math.floor(baseColor.b * 0.7 + tint.b * 0.3)
                    };
                }

                const r = baseColor.r;
                const g = baseColor.g;
                const b = baseColor.b;
                const bodyColor = `rgb(${r}, ${g}, ${b})`;
                const darkColor = `rgb(${Math.max(0, r - 20)}, ${Math.max(0, g - 15)}, ${Math.max(0, b - 10)})`;
                const accentColorStr = `rgb(${accent.r}, ${accent.g}, ${accent.b})`;
                const legColor = `rgb(${Math.min(255, r + 30)}, ${Math.min(255, g + 25)}, ${Math.min(255, b + 20)})`;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 2, size * 1.2, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs - use accent color for visibility
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.12;
                ctx.lineCap = 'round';

                const legPositions = [-0.15, 0.05, 0.25];
                for (let i = 0; i < 3; i++) {
                    const attachX = legPositions[i] * size;
                    const phase = (i === 1) ? -legWave : legWave;

                    ctx.beginPath();
                    ctx.moveTo(attachX, -size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, -size * 0.45 - phase * size * 0.15, attachX - size * 0.1, -size * 0.7 - phase * size * 0.1);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(attachX, size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, size * 0.45 + phase * size * 0.15, attachX - size * 0.1, size * 0.7 + phase * size * 0.1);
                    ctx.stroke();
                }

                // Gaster (abdomen) - main body color
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.5, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Gaster stripe/marking for visibility
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.35, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = darkColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.7, 0, size * 0.15, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Petiole
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.1, 0, size * 0.1, size * 0.07, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax - with accent highlight
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.28, size * 0.18, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax accent stripe
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.18, size * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.55, 0, size * 0.22, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes - white with black pupil for visibility
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(size * 0.62, -size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.arc(size * 0.62, size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(size * 0.64, -size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.arc(size * 0.64, size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.fill();

                // Antennae - use accent color
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.07;
                const antennaWave = Math.sin(this.legPhase * 0.6) * 0.12;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, -size * 0.12);
                ctx.lineTo(size * 0.88, -size * 0.25);
                ctx.lineTo(size * 1.05, -size * 0.2 + antennaWave * size);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(size * 0.7, size * 0.12);
                ctx.lineTo(size * 0.88, size * 0.25);
                ctx.lineTo(size * 1.05, size * 0.2 - antennaWave * size);
                ctx.stroke();

                // Draw carried food piece with zone-based glow
                if (this.carriedFoodPiece && this.state === 'carrying') {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    const pieceSize = 10;
                    const pieceX = size * 0.8;
                    const pieceY = -size * 0.3;

                    // Zone-based glow
                    const glowGrad = ctx.createRadialGradient(pieceX, pieceY, 0, pieceX, pieceY, pieceSize * 0.8);
                    if (this.carriedFoodPiece.fromDangerZone) {
                        glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.6)');
                        glowGrad.addColorStop(1, 'transparent');
                    } else {
                        glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.5)');
                        glowGrad.addColorStop(1, 'transparent');
                    }
                    ctx.fillStyle = glowGrad;
                    ctx.beginPath();
                    ctx.arc(pieceX, pieceY, pieceSize * 0.8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = `${pieceSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.carriedFoodPiece.emoji, pieceX, pieceY);
                    ctx.restore();
                }

                // IRON SHELL visual - metallic shine when below 30% HP
                if (this.hasSkill('ironShell') && this.currentHp / this.maxHp < 0.3) {
                    ctx.save();

                    // Metallic overlay
                    const shinePhase = Math.sin(Date.now() / 150) * 0.3 + 0.7;
                    const gradient = ctx.createLinearGradient(-size, -size, size, size);
                    gradient.addColorStop(0, `rgba(150, 200, 255, ${0.3 * shinePhase})`);
                    gradient.addColorStop(0.5, `rgba(220, 240, 255, ${0.5 * shinePhase})`);
                    gradient.addColorStop(1, `rgba(100, 150, 220, ${0.3 * shinePhase})`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(-size * 0.2, 0, size * 0.9, size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Shield icon above
                    ctx.rotate(-this.angle);
                    ctx.font = `${size * 0.5}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = shinePhase;
                    ctx.fillText('', 0, -size * 1.3);

                    ctx.restore();
                }

                // Birth passive indicator (small icon)
                if (this.birthPassive) {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    ctx.font = `${size * 0.4}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = 0.8;
                    ctx.fillText(this.birthPassive.icon, size * 0.8, -size * 0.5);
                    ctx.restore();
                }

                // Skill indicator (show skill icons for ants with skills)
                if ((this.chosenSkill || this.chosenSkill2) && !this.isPouncing) {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    ctx.font = `${size * 0.5}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const now = Date.now();

                    // Draw first skill icon
                    if (this.chosenSkill) {
                        const onCooldown1 = this.chosenSkill.type === 'active' &&
                            (now - this.lastSkillUse) < this.chosenSkill.cooldown;
                        ctx.globalAlpha = onCooldown1 ? 0.4 : 0.9;
                        ctx.fillText(this.chosenSkill.icon, -size * 0.8, -size * 0.5);
                    }

                    // Draw second skill icon (if present)
                    if (this.chosenSkill2) {
                        const onCooldown2 = this.chosenSkill2.type === 'active' &&
                            (now - this.lastSkillUse2) < this.chosenSkill2.cooldown;
                        ctx.globalAlpha = onCooldown2 ? 0.4 : 0.9;
                        ctx.fillText(this.chosenSkill2.icon, -size * 1.4, -size * 0.5);
                    }

                    ctx.restore();
                }

                // Food buff indicator - show active buff icons above ant
                if (this.activeBuffs && this.activeBuffs.length > 0) {
                    ctx.save();
                    ctx.rotate(-this.angle);

                    const buffStartY = -size * 1.5;
                    let buffIndex = 0;

                    for (const buff of this.activeBuffs) {
                        // Calculate time remaining for the buff
                        const timeRemaining = buff.endTime - Date.now();
                        const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;

                        // Position buffs in a row above the ant
                        const buffX = (buffIndex - (this.activeBuffs.length - 1) / 2) * size * 0.8;
                        const buffY = buffStartY;

                        // Draw colored glow behind buff
                        const glowGrad = ctx.createRadialGradient(buffX, buffY, 0, buffX, buffY, size * 0.5);
                        glowGrad.addColorStop(0, buff.color || 'rgba(255, 200, 100, 0.6)');
                        glowGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = glowGrad;
                        ctx.globalAlpha = pulse;
                        ctx.beginPath();
                        ctx.arc(buffX, buffY, size * 0.5, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw buff emoji
                        ctx.globalAlpha = 1;
                        ctx.font = `${size * 0.5}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(buff.emoji || '', buffX, buffY);

                        // Draw time remaining indicator bar below
                        const barWidth = size * 0.6;
                        const barHeight = 2;
                        const barY = buffY + size * 0.35;
                        const remainingPercent = Math.max(0, timeRemaining / (buff.endTime - (buff.endTime - 30000)));

                        // Background bar
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.fillRect(buffX - barWidth / 2, barY, barWidth, barHeight);

                        // Progress bar
                        ctx.fillStyle = buff.color || '#ffd700';
                        ctx.fillRect(buffX - barWidth / 2, barY, barWidth * Math.min(1, timeRemaining / 30000), barHeight);

                        buffIndex++;
                    }

                    ctx.restore();
                }

                // Selection indicator - large triangle above selected ant
                if (selectedAnt === this) {
                    ctx.save();
                    ctx.rotate(-this.angle);

                    // Detection radius visualization (shows exact current range)
                    const detectionBonus = 1 + (this.traitRolls.detection - 0.5) * 0.4;
                    const detectionRadius = this.foodDetectRadius * detectionBonus;

                    // Detection ring - dashed outline
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.4)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, detectionRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Subtle inner fill
                    const detectGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, detectionRadius);
                    detectGrad.addColorStop(0, 'rgba(0, 200, 255, 0.03)');
                    detectGrad.addColorStop(0.8, 'rgba(0, 200, 255, 0.06)');
                    detectGrad.addColorStop(1, 'rgba(0, 200, 255, 0)');
                    ctx.setLineDash([]);
                    ctx.fillStyle = detectGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, detectionRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Animated bounce
                    const bounce = Math.sin(Date.now() / 150) * 4;
                    const triangleY = -size * 2.2 - bounce;
                    const triSize = size * 1.2;  // Much bigger triangle

                    // Strong glow effect
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 20;

                    // Outer glow ring
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();

                    // Draw main triangle (pointing down)
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.7);
                    ctx.lineTo(-triSize * 0.5, triangleY);
                    ctx.lineTo(triSize * 0.5, triangleY);
                    ctx.closePath();
                    ctx.fill();

                    // Inner lighter triangle
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#80ffbb';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.5);
                    ctx.lineTo(-triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.lineTo(triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }

                // PERSISTENT HEALTH BAR - Show during combat (when fightingTimer > 0)
                if (this.fightingTimer > 0 && this.currentHp < this.maxHp) {
                    ctx.save();
                    ctx.rotate(-this.angle);  // Unrotate so bar is horizontal

                    const barWidth = size * 2.5;
                    const barHeight = 4;
                    const barY = -size * 1.8;
                    const hpPercent = this.currentHp / this.maxHp;

                    // Background bar
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);

                    // HP fill - always green for ants
                    ctx.fillStyle = '#00ff88';
                    ctx.fillRect(-barWidth / 2, barY, barWidth * hpPercent, barHeight);

                    // Border
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-barWidth / 2, barY, barWidth, barHeight);

                    ctx.restore();
                }

                ctx.restore();
            }
        }

        function initAnts() {
            ants = [];
            for (let i = 0; i < CONFIG.initialAnts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * CONFIG.nestRadius * 0.7;
                // Start with all workers
                ants.push(new Ant(CONFIG.nestX + Math.cos(angle) * dist, CONFIG.nestY + Math.sin(angle) * dist, 'worker'));
            }
        }

        // ===========================================
        // RENDERING
        // ===========================================

        function drawGround() {
            // Brighter, greener forest floor
            const gradient = ctx.createRadialGradient(width * 0.4, height * 0.35, 0, width * 0.5, height * 0.5, Math.max(width, height) * 0.8);
            gradient.addColorStop(0, '#3a4a30');
            gradient.addColorStop(0.3, '#2e3d28');
            gradient.addColorStop(0.6, '#243320');
            gradient.addColorStop(1, '#1a2818');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Warm light beam
            const beamGradient = ctx.createRadialGradient(width * 0.3, height * 0.2, 0, width * 0.3, height * 0.2, height * 0.8);
            beamGradient.addColorStop(0, 'rgba(255, 250, 220, 0.08)');
            beamGradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.04)');
            beamGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = beamGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw forest elements
            for (const el of forestElements) drawForestElement(el);

            // Draw grass
            drawGrass();

            // Subtle vignette
            const vignetteGradient = ctx.createRadialGradient(width / 2, height / 2, Math.min(width, height) * 0.35, width / 2, height / 2, Math.max(width, height) * 0.85);
            vignetteGradient.addColorStop(0, 'transparent');
            vignetteGradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.1)');
            vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            ctx.fillStyle = vignetteGradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawPheromones() {
            const cellSize = CONFIG.pheromoneGridSize;

            // Use soft blending for smooth trails
            ctx.globalCompositeOperation = 'lighter';

            for (let row = 0; row < pheromoneGrid.rows; row++) {
                for (let col = 0; col < pheromoneGrid.cols; col++) {
                    const idx = row * pheromoneGrid.cols + col;
                    const foodPh = pheromoneGrid.food[idx];

                    if (foodPh > 0.5) {
                        const x = col * cellSize + cellSize / 2;
                        const y = row * cellSize + cellSize / 2;

                        // Normalize strength (0-1 range, where 1 = very strong trail)
                        const strength = Math.min(1, foodPh / 15);

                        // Smaller base size, blends together into continuous trail
                        const size = cellSize * (0.5 + strength * 0.3);

                        // Alpha scales with strength but kept low for smooth blending
                        const alpha = 0.08 + strength * 0.25;

                        // Color shifts from pale green to bright cyan-green for strong trails
                        const r = Math.round(50 - strength * 30);
                        const g = Math.round(150 + strength * 105);
                        const b = Math.round(80 + strength * 120);

                        // Soft radial gradient for each point - creates smooth blending
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`);
                        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';
        }

        function getColonySize() {
            // Colony grows slightly based on ant population
            return CONFIG.nestRadius * Math.min(2.5, 1 + ants.length / 100);
        }

        function drawNest() {
            const currentRadius = getColonySize();
            const cx = CONFIG.nestX;
            const cy = CONFIG.nestY;
            const antCount = ants.length;

            // Draw defense radius if Fortified Nest is active
            if (upgradeMultipliers.nestDefenseBonus > 0) {
                const defRadius = upgradeMultipliers.nestDefenseRadius;
                const pulse = Math.sin(Date.now() / 600) * 0.15 + 0.85;

                // Outer glow
                const glowGrad = ctx.createRadialGradient(cx, cy, defRadius * 0.7, cx, cy, defRadius * 1.1);
                glowGrad.addColorStop(0, 'transparent');
                glowGrad.addColorStop(0.5, `rgba(100, 180, 255, ${0.08 * pulse})`);
                glowGrad.addColorStop(0.8, `rgba(100, 180, 255, ${0.15 * pulse})`);
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, defRadius * 1.1, 0, Math.PI * 2);
                ctx.fill();

                // Defense circle border
                ctx.strokeStyle = `rgba(100, 180, 255, ${0.4 * pulse})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.arc(cx, cy, defRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Shield icon at top of circle
                ctx.save();
                ctx.translate(cx, cy - defRadius - 10);
                ctx.font = '14px serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(100, 180, 255, ${0.8 * pulse})`;
                ctx.fillText('', 0, 0);
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * pulse})`;
                ctx.fillText(`+${upgradeMultipliers.nestDefenseBonus}`, 0, 14);
                ctx.restore();
            }

            // Excavated dirt
            ctx.fillStyle = '#4a4030';
            const dirtPiles = 20 + Math.min(antCount, 100) * 0.3;
            for (let i = 0; i < dirtPiles; i++) {
                const angle = (i / dirtPiles) * Math.PI * 2 + Math.sin(i * 1.7) * 0.4;
                const dist = currentRadius * (1.1 + Math.sin(i * 2.9) * 0.2);
                const blobSize = currentRadius * (0.06 + Math.sin(i * 4.1) * 0.03);
                ctx.beginPath();
                ctx.ellipse(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.5, blobSize * 1.2, blobSize * 0.4, angle * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Shadow
            const shadowGrad = ctx.createRadialGradient(cx + currentRadius * 0.1, cy + currentRadius * 0.15, 0, cx, cy, currentRadius * 1.3);
            shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            shadowGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.12)');
            shadowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = shadowGrad;
            ctx.beginPath();
            ctx.ellipse(cx + currentRadius * 0.1, cy + currentRadius * 0.12, currentRadius * 1.2, currentRadius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main mound
            const baseGrad = ctx.createRadialGradient(cx - currentRadius * 0.2, cy - currentRadius * 0.25, 0, cx, cy, currentRadius * 1.2);
            baseGrad.addColorStop(0, '#6a5a45');
            baseGrad.addColorStop(0.3, '#5a4a38');
            baseGrad.addColorStop(0.6, '#4a3a2a');
            baseGrad.addColorStop(1, '#3a2a1f');

            ctx.fillStyle = baseGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius, currentRadius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Texture (using deterministic positions based on index to avoid flickering)
            const textureDots = 25 + Math.min(antCount, 100) * 0.4;
            for (let i = 0; i < textureDots; i++) {
                // Use deterministic pseudo-random based on index
                const seed1 = Math.sin(i * 12.9898) * 43758.5453;
                const seed2 = Math.sin(i * 78.233) * 43758.5453;
                const seed3 = Math.sin(i * 45.164) * 43758.5453;
                const angle = (seed1 - Math.floor(seed1)) * Math.PI * 2;
                const dist = (seed2 - Math.floor(seed2)) * currentRadius * 0.9;
                const brightness = 40 + (seed3 - Math.floor(seed3)) * 25;
                ctx.fillStyle = `rgb(${brightness + 25}, ${brightness + 15}, ${brightness})`;
                const dotSize = 1 + (Math.sin(i * 23.14) * 0.5 + 0.5) * 2;
                ctx.beginPath();
                ctx.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.55, dotSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Entrance
            const entranceGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, currentRadius * 0.25);
            entranceGrad.addColorStop(0, '#080604');
            entranceGrad.addColorStop(0.6, '#100e0a');
            entranceGrad.addColorStop(1, '#2a2218');

            ctx.fillStyle = entranceGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.22, currentRadius * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Entrance rim
            ctx.strokeStyle = '#6a5838';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.25, currentRadius * 0.17, 0, Math.PI * 0.8, Math.PI * 0.2);
            ctx.stroke();

            // Auto-spawn cooldown timer (WoW-style sweep on nest entrance)
            if (!gameOver) {
                const elapsed = getElapsedSeconds();
                const timeSinceLastSpawn = elapsed - lastAutoSpawnTime;
                const remaining = Math.max(0, AUTO_SPAWN_INTERVAL - timeSinceLastSpawn);
                const progress = remaining / AUTO_SPAWN_INTERVAL;  // 1 = full cooldown, 0 = ready

                if (progress > 0 && progress < 1) {
                    // Draw cooldown sweep over entrance
                    const entranceRadius = currentRadius * 0.22;

                    // Dark overlay sweep (clockwise from top)
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.arc(cx, cy, entranceRadius, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
                    ctx.closePath();
                    ctx.fill();

                    // Countdown number
                    const seconds = Math.ceil(remaining);
                    ctx.fillStyle = 'rgba(123, 237, 159, 0.9)';
                    ctx.font = 'bold 10px "Orbitron", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${seconds}`, cx, cy);

                    // Small ant icon above nest showing spawn incoming
                    ctx.font = '12px serif';
                    ctx.fillStyle = `rgba(123, 237, 159, ${0.5 + Math.sin(Date.now() / 300) * 0.3})`;
                    ctx.fillText('', cx, cy - currentRadius * 0.4);
                }
            }
        }

        function drawFood() {
            for (const food of foodItems) food.draw();
        }

        function drawAnts() {
            for (const ant of ants) ant.draw();
        }

        function updateUI() {
            document.getElementById('coins').textContent = coins;
            document.getElementById('ant-count').textContent = ants.length;
            document.getElementById('food-collected').textContent = foodCollected;
            document.getElementById('survival-timer').textContent = formatTime(getElapsedSeconds());

            // Count ants (all workers now)
            document.getElementById('worker-count').textContent = ants.length;

            // Food buttons are always available (food is free in new system)
            // Disabled state is only set by cooldown system

            // Update ant button states and costs
            document.querySelectorAll('.ant-btn').forEach(btn => {
                const antType = btn.dataset.ant;
                const cost = getAntSpawnCost(antType);
                btn.classList.toggle('disabled', coins < cost || ants.length >= CONFIG.maxAnts);
            });

            // Update displayed costs
            updateAntCosts();
        }

        // ===========================================
        // INPUT HANDLING
        // ===========================================

        let selectedFoodType = null;
        let isPlacing = false;
        let lastPlaceTime = 0;
        let showHint = false;  // Disabled - no longer showing "click to drop food" hint
        let foodPlacementActive = false;
        let foodPlacementTimeout = null;

        // Food cooldown tracking - stores end timestamps for each food type
        const foodCooldowns = {
            sugar: 0,
            protein: 0,
            fruit: 0,
            feast: 0,
            nectar: 0
        };
        const FOOD_COOLDOWN_DURATION = 30000; // 30 seconds in milliseconds

        // Initialize cooldown overlays on food buttons
        function initFoodCooldownOverlays() {
            document.querySelectorAll('.food-btn').forEach(btn => {
                // Add position relative for overlay positioning
                btn.style.position = 'relative';

                // Create cooldown overlay element
                const overlay = document.createElement('div');
                overlay.className = 'cooldown-overlay';
                overlay.innerHTML = '<span class="cooldown-timer">30</span>';
                btn.appendChild(overlay);

                // Create progress bar
                const progress = document.createElement('div');
                progress.className = 'cooldown-progress';
                progress.style.width = '0%';
                btn.appendChild(progress);
            });
        }

        // Start cooldown for a specific food type
        function startFoodCooldown(foodType) {
            const endTime = Date.now() + FOOD_COOLDOWN_DURATION;
            foodCooldowns[foodType] = endTime;

            const btn = document.querySelector(`.food-btn[data-food="${foodType}"]`);
            if (btn) {
                btn.classList.add('on-cooldown');
            }
        }

        // Check if a food type is on cooldown
        function isFoodOnCooldown(foodType) {
            return Date.now() < foodCooldowns[foodType];
        }

        // Update all food cooldown timers
        function updateFoodCooldowns() {
            const now = Date.now();

            for (const foodType of Object.keys(foodCooldowns)) {
                const btn = document.querySelector(`.food-btn[data-food="${foodType}"]`);
                if (!btn) continue;

                const endTime = foodCooldowns[foodType];
                const remaining = endTime - now;

                if (remaining > 0) {
                    // Still on cooldown
                    const seconds = Math.ceil(remaining / 1000);
                    const timerEl = btn.querySelector('.cooldown-timer');
                    const progressEl = btn.querySelector('.cooldown-progress');

                    if (timerEl) {
                        timerEl.textContent = seconds;
                    }
                    if (progressEl) {
                        const progressPercent = (remaining / FOOD_COOLDOWN_DURATION) * 100;
                        progressEl.style.width = progressPercent + '%';
                    }

                    btn.classList.add('on-cooldown');
                } else {
                    // Cooldown finished
                    btn.classList.remove('on-cooldown');
                    const progressEl = btn.querySelector('.cooldown-progress');
                    if (progressEl) {
                        progressEl.style.width = '0%';
                    }
                }
            }
        }

        // Drag selection state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragCurrentX = 0;
        let dragCurrentY = 0;
        let dragThreshold = 10; // Minimum pixels to trigger drag vs click

        // Food placement functions removed - food auto-spawns in zones now
        function activateFoodPlacement(foodType) { }
        function deactivateFoodPlacement() { }

        // Food levels panel doesn't need click handlers

        // ===========================================
        // CHARACTER CARD SYSTEM
        // ===========================================

        let characterCardOpen = false;

        const ANT_CARD_DATA = {
            worker: {
                icon: '',
                title: 'Worker',
                subtitle: 'Colony Backbone',
                description: 'The reliable workhorse of the colony. Balanced stats make them versatile foragers that can survive a few hits.',
                stats: [
                    { name: 'HP', value: '10', class: '' },
                    { name: 'ATK', value: '2', class: '' },
                    { name: 'DEF', value: '2', class: '' },
                    { name: 'SPD', value: 'Normal', class: '' }
                ],
                traits: [
                    { text: 'Balanced', class: '' },
                    { text: 'Efficient Carrier', class: 'positive' },
                    { text: 'Common', class: '' }
                ]
            }
        };

        const PREDATOR_CARD_DATA = {
            spider: {
                icon: '',
                title: 'Spider',
                subtitle: 'Glass Cannon',
                description: 'A fast but fragile hunter. Low defense makes it easy to kill, but watch out for its speed!',
                stats: [
                    { name: 'HP', value: '40', class: 'neutral' },
                    { name: 'ATK', value: '4', class: 'neutral' },
                    { name: 'DEF', value: '1', class: 'good' },
                    { name: 'SPD', value: '1.8', class: 'bad' }
                ],
                traits: [
                    { text: 'Fast', class: 'negative' },
                    { text: 'Fragile', class: 'positive' },
                    { text: 'Respawns', class: 'negative' }
                ]
            },
            beetle: {
                icon: '',
                title: 'Beetle',
                subtitle: 'Armored Tank',
                description: 'A tanky predator with high HP and DEF but very low damage. Hard to kill but not very threatening.',
                stats: [
                    { name: 'HP', value: '60', class: 'bad' },
                    { name: 'ATK', value: '1', class: 'good' },
                    { name: 'DEF', value: '4', class: 'bad' },
                    { name: 'SPD', value: '0.5', class: 'good' }
                ],
                traits: [
                    { text: 'Armored', class: 'negative' },
                    { text: 'Weak Attack', class: 'positive' },
                    { text: 'Slow Patrol', class: 'positive' }
                ]
            }
        };

        // Helper to get stat class based on value comparison
        function getStatClass(value, baseline) {
            const ratio = value / baseline;
            if (ratio >= 1.35) return 'legendary';
            if (ratio >= 1.2) return 'exceptional';
            if (ratio >= 1.05) return 'good';
            if (ratio >= 0.95) return '';
            if (ratio >= 0.85) return 'weak';
            return 'poor';
        }

        // Generate dynamic card data for an individual ant
        // WoW/Hearthstone-style stat rarity thresholds
        // Returns: 'common' (white), 'uncommon' (green), 'rare' (blue), 'epic' (purple), 'legendary' (orange)
        // Calibrated so ~50% common, ~30% uncommon, ~15% rare, ~4% epic, ~1% legendary
        function getStatRarity(statName, value) {
            const thresholds = {
                // HP: base=10, max with levels ~50+
                'HP': { uncommon: 18, rare: 30, epic: 45, legendary: 60 },
                // ATK: base=2, max with levels ~15+
                'ATK': { uncommon: 5, rare: 10, epic: 15, legendary: 20 },
                // DEF: base=2, max with levels ~12+
                'DEF': { uncommon: 4, rare: 7, epic: 10, legendary: 14 },
                // SPD: base=0.5, max ~1.0+
                'SPD': { uncommon: 0.55, rare: 0.7, epic: 0.85, legendary: 1.0 },
                // DET: base=48, varies with upgrades
                'DET': { uncommon: 30, rare: 60, epic: 100, legendary: 150 },
                // CAP: base=1, max with levels ~6+
                'CAP': { uncommon: 2, rare: 4, epic: 6, legendary: 8 },
                // PHER: base=0.8
                'PHER': { uncommon: 1.0, rare: 2.0, epic: 3.5, legendary: 5.0 },
                // HP5: starts at 0, gained from nectar. 1 = heals 1 HP/5s
                'HP5': { uncommon: 1, rare: 3, epic: 5, legendary: 8 }
            };

            const t = thresholds[statName];
            if (!t) return 'common';

            if (value >= t.legendary) return 'legendary';
            if (value >= t.epic) return 'epic';
            if (value >= t.rare) return 'rare';
            if (value >= t.uncommon) return 'uncommon';
            return 'common';
        }

        function generateAntCardData(ant) {
            const baseData = ANT_CARD_DATA[ant.type];
            const typeConfig = CONFIG.antTypes[ant.type];
            const level = ant.getLevel();
            const xpTotal = ant.getTotalExp();
            const xpProgress = ant.getLevelProgress();
            const xpToNext = ant.getXpToNextLevel();

            // Calculate Pokemon-style stats
            const currentHp = ant.currentHp || ant.maxHp;
            const maxHp = ant.maxHp || typeConfig.hp;
            const atk = ant.atk || typeConfig.atk;
            const def = ant.def || typeConfig.def;
            const hpPercent = Math.round((currentHp / maxHp) * 100);

            // HP class based on current health
            const hpClass = hpPercent >= 75 ? 'good' : hpPercent >= 40 ? '' : hpPercent >= 20 ? 'weak' : 'bad';

            // Calculate effective ATK using the ant's method (includes Last Stand, Bloodlust, etc.)
            const permAtkBonus = ant.permAtkBonus || 0;
            const permDefBonus = ant.permDefBonus || 0;
            const baseEffectiveAtk = atk + permAtkBonus;
            const fullEffectiveAtk = ant.getEffectiveAtk();  // Includes Last Stand, Bloodlust, Rally Cry, etc.

            // Check all active combat bonuses for ATK
            const bloodlustStacks = ant.bloodlustStacks || 0;
            const hasLastStand = ant.hasSkill && ant.hasSkill('lastStand') && (ant.currentHp / ant.maxHp) < 0.5;
            const hasRallyBoost = (ant.rallyBoostTimer || 0) > 0;
            const hasShadowStep = ant.shadowStepActive && ant.shadowStepBonusDamage;
            const hasCombatBonus = fullEffectiveAtk > baseEffectiveAtk;

            // Check active SPD bonuses
            const momentumStacks = ant.momentumStacks || 0;
            const hasAdrenaline = ant.adrenalineActive || false;
            const baseSpdValue = ant.speed * upgradeMultipliers.antSpeed;
            let effectiveSpdValue = baseSpdValue;
            if (momentumStacks > 0) effectiveSpdValue *= (1 + momentumStacks * 0.05);
            if (hasAdrenaline) effectiveSpdValue *= 2;

            // Calculate effective DEF including nest defense bonus and Iron Shell
            let effectiveDef = def + permDefBonus;
            let hasNestBonus = false;
            const hasIronShell = ant.hasSkill && ant.hasSkill('ironShell');
            if (upgradeMultipliers.nestDefenseBonus > 0) {
                const distToNest = Math.hypot(ant.x - CONFIG.nestX, ant.y - CONFIG.nestY);
                if (distToNest <= upgradeMultipliers.nestDefenseRadius) {
                    effectiveDef += upgradeMultipliers.nestDefenseBonus;
                    hasNestBonus = true;
                }
            }

            // Build ATK display string - show full effective ATK with bonus indicator
            let atkDisplay = Math.round(fullEffectiveAtk);
            let atkClass = getStatRarity('ATK', fullEffectiveAtk);
            if (hasCombatBonus) {
                const boostSources = [];
                if (hasLastStand) boostSources.push('3x');
                if (bloodlustStacks > 0) boostSources.push(`${bloodlustStacks}`);
                if (hasRallyBoost) boostSources.push('+50%');
                if (hasShadowStep) boostSources.push('3x');
                const boostIndicator = boostSources.length > 0 ? ` ${boostSources.join(' ')}` : '';
                atkDisplay = `${Math.round(fullEffectiveAtk)}${boostIndicator}`;
                atkClass = 'legendary';
            } else if (permAtkBonus > 0) {
                atkDisplay = `${Math.round(fullEffectiveAtk)} (+${permAtkBonus})`;
            }

            // Build DEF display string
            let defDisplay = Math.round(effectiveDef);
            let defClass = getStatRarity('DEF', effectiveDef);
            const totalDefBonus = permDefBonus + (hasNestBonus ? upgradeMultipliers.nestDefenseBonus : 0);
            const defBonuses = [];
            if (totalDefBonus > 0) defBonuses.push(`+${totalDefBonus}`);
            if (hasIronShell) defBonuses.push('');
            if (defBonuses.length > 0) {
                defDisplay = `${Math.round(effectiveDef)} (${defBonuses.join(' ')})`;
                if (hasIronShell) defClass = 'epic';
            }

            // Build SPD display string
            let spdDisplay = effectiveSpdValue.toFixed(2);
            let spdClass = getStatRarity('SPD', effectiveSpdValue);
            const hasSpdBonus = momentumStacks > 0 || hasAdrenaline;
            if (hasSpdBonus) {
                const spdBonuses = [];
                if (momentumStacks > 0) spdBonuses.push(`${momentumStacks}`);
                if (hasAdrenaline) spdBonuses.push('2x');
                spdDisplay = `${effectiveSpdValue.toFixed(2)} ${spdBonuses.join(' ')}`;
                spdClass = 'legendary';
            }

            // Calculate other stat values
            const detValue = ant.foodDetectRadius * upgradeMultipliers.detectionRadius;
            const capValue = ant.carryCapacity + upgradeMultipliers.carryCapacity;
            const pherValue = ant.pheromoneStrength;

            // Check for Pathfinder DET bonus
            const hasPathfinder = ant.hasSkill && ant.hasSkill('pathfinder');
            let detDisplay = Math.round(detValue);
            let detClass = getStatRarity('DET', detValue);
            if (hasPathfinder) {
                const boostedDet = detValue * 1.5;
                detDisplay = `${Math.round(boostedDet)} +50%`;
                detClass = 'epic';
            }

            // Check for Heavy Lifter CAP bonus
            const hasHeavyLifter = ant.hasSkill && ant.hasSkill('heavyLifter');
            let capDisplay = Math.round(capValue);
            let capClass = getStatRarity('CAP', capValue);
            if (hasHeavyLifter) {
                const boostedCap = capValue + 1;
                capDisplay = `${Math.round(boostedCap)} +1`;
                capClass = 'epic';
            }

            // Check for Scavenger XP bonus (show as trait instead)
            const hasScavenger = ant.hasSkill && ant.hasSkill('scavenger');

            // Check for Lucky gold bonus (show as trait instead)
            const hasLucky = ant.hasSkill && ant.hasSkill('lucky');

            // Build dynamic stats with WoW-style rarity colors
            const stats = [
                {
                    name: 'HP',
                    value: `${Math.round(currentHp)}/${Math.round(maxHp)}`,
                    class: getStatRarity('HP', maxHp),
                    hpData: { current: currentHp, max: maxHp }
                },
                {
                    name: 'ATK',
                    value: atkDisplay,
                    class: atkClass
                },
                {
                    name: 'DEF',
                    value: defDisplay,
                    class: defClass
                },
                {
                    name: 'SPD',
                    value: spdDisplay,
                    class: spdClass
                },
                {
                    name: 'DET',
                    value: detDisplay,
                    class: detClass
                },
                {
                    name: 'CAP',
                    value: capDisplay,
                    class: capClass
                },
                {
                    name: 'PHER',
                    value: pherValue.toFixed(1),
                    class: getStatRarity('PHER', pherValue)
                },
                {
                    name: 'HP5',
                    value: ant.hp5Stacks || 0,
                    class: getStatRarity('HP5', ant.hp5Stacks || 0)
                }
            ];

            // Build dynamic traits
            const traits = [];

            // Level indicator first (no max level)
            const levelClass = level >= 10 ? 'legendary' : level >= 7 ? 'exceptional' : level >= 5 ? 'good' : level >= 3 ? '' : 'weak';
            traits.push({ text: `Level ${level}`, class: levelClass });

            // Skill indicators if unlocked
            if (ant.chosenSkill) {
                traits.push({ text: ant.chosenSkill.name, class: 'skill' });
            }
            if (ant.chosenSkill2) {
                traits.push({ text: ant.chosenSkill2.name, class: 'skill' });
            }

            // Active effect indicators (show current buffs/stacks)
            if (hasLastStand) {
                traits.push({ text: ' Last Stand Active', class: 'legendary' });
            }
            if (bloodlustStacks > 0) {
                traits.push({ text: ` Bloodlust x${bloodlustStacks}`, class: 'legendary' });
            }
            if (momentumStacks > 0) {
                traits.push({ text: ` Momentum x${momentumStacks}`, class: 'epic' });
            }
            if (hasAdrenaline) {
                traits.push({ text: ' Adrenaline Active', class: 'legendary' });
            }
            if (hasRallyBoost) {
                traits.push({ text: ' Rally Boost', class: 'epic' });
            }
            if (hasShadowStep) {
                traits.push({ text: ' Shadow Step Ready', class: 'legendary' });
            }
            if (ant.spiritLinkActive) {
                traits.push({ text: ' Spirit Link Active', class: 'epic' });
            }
            if (hasScavenger) {
                traits.push({ text: ' +25% XP', class: 'good' });
            }
            if (hasLucky) {
                traits.push({ text: ' +10% Gold Chance', class: 'good' });
            }
            if (ant.secondWindUsed === false && ant.hasSkill && ant.hasSkill('secondWind')) {
                traits.push({ text: ' Second Wind Ready', class: 'epic' });
            } else if (ant.secondWindUsed === true) {
                traits.push({ text: ' Second Wind Used', class: 'weak' });
            }

            // Add experience-based traits
            if (ant.experience.dangerDeliveries >= 10) {
                traits.push({ text: 'Daredevil', class: 'exceptional' });
            } else if (ant.experience.dangerDeliveries >= 5) {
                traits.push({ text: 'Risk Taker', class: 'good' });
            }

            if (ant.experience.totalDeliveries >= 30) {
                traits.push({ text: 'Veteran', class: 'exceptional' });
            } else if (ant.experience.totalDeliveries >= 15) {
                traits.push({ text: 'Hardworker', class: 'positive' });
            }

            if (ant.experience.predatorEscapes >= 5) {
                traits.push({ text: 'Survivor', class: 'legendary' });
            } else if (ant.experience.predatorEscapes >= 2) {
                traits.push({ text: 'Escapist', class: 'good' });
            }

            if (ant.experience.foodDiscovered >= 10) {
                traits.push({ text: 'Explorer', class: 'good' });
            }

            // Add trait-based special labels
            if (ant.traitRolls.speed >= 0.95) {
                traits.push({ text: 'Swift', class: 'legendary' });
            }
            if (ant.traitRolls.detection >= 0.95) {
                traits.push({ text: 'Sharp Eyes', class: 'legendary' });
            }
            if (ant.traitRolls.goldBonus >= 0.95) {
                traits.push({ text: 'Midas', class: 'legendary' });
            }

            // Type indicator at end
            traits.push({ text: baseData.title, class: '' });

            // Build description with experience info and skill details
            let desc = baseData.description;

            // Add skill descriptions if unlocked
            if (ant.chosenSkill) {
                desc += ` [${ant.chosenSkill.name}]: ${ant.chosenSkill.description}`;
            }
            if (ant.chosenSkill2) {
                desc += ` [${ant.chosenSkill2.name}]: ${ant.chosenSkill2.description}`;
            }
            if (!ant.chosenSkill && level < 3) {
                desc += ` Unlocks skill at Level 3.`;
            } else if (ant.chosenSkill && !ant.chosenSkill2 && level < 7) {
                desc += ` Unlocks second skill at Level 7.`;
            }

            return {
                icon: baseData.icon,
                title: ant.name,
                subtitle: `Lv.${level} ${baseData.title}`,
                description: desc,
                stats: stats,
                traits: traits,
                // Additional data for enhanced card
                level: level,
                xpTotal: xpTotal,
                xpProgress: xpProgress,
                xpToNext: xpToNext,
                skill1: ant.chosenSkill,
                skill2: ant.chosenSkill2,
                deliveries: ant.experience.totalDeliveries,
                dangerDeliveries: ant.experience.dangerDeliveries,
                discoveries: ant.experience.foodDiscovered
            };
        }

        // Generate dynamic card data for a predator (spider or beetle)
        function generatePredatorCardData(predator, key) {
            const baseData = PREDATOR_CARD_DATA[key];
            const cfg = CONFIG.predators[key];

            // Calculate HP percentage for class
            const hpPercent = Math.round((predator.currentHp / predator.maxHp) * 100);
            const hpClass = hpPercent >= 75 ? 'bad' : hpPercent >= 40 ? 'neutral' : hpPercent >= 20 ? 'good' : 'weak';

            // Get speed value from predator or config
            const speedValue = predator.speed || cfg.speed || cfg.patrolSpeed || 1.0;
            const speedClass = speedValue >= 1.5 ? 'bad' : speedValue >= 1.0 ? 'neutral' : 'good';

            // Build dynamic stats
            const stats = [
                {
                    name: 'HP',
                    value: `${Math.round(predator.currentHp)}/${predator.maxHp}`,
                    class: hpClass
                },
                {
                    name: 'ATK',
                    value: Math.round(predator.atk),
                    class: predator.atk >= 12 ? 'bad' : predator.atk >= 8 ? 'neutral' : 'good'
                },
                {
                    name: 'DEF',
                    value: Math.round(predator.def),
                    class: predator.def >= 6 ? 'bad' : predator.def >= 3 ? 'neutral' : 'good'
                },
                {
                    name: 'SPD',
                    value: speedValue.toFixed(1),
                    class: speedClass
                }
            ];

            // Build dynamic traits based on current state
            const traits = [...baseData.traits];

            // Add wave trait if predator has wave level
            if (predator.wave && predator.wave > 0) {
                traits.unshift({
                    text: `WAVE ${predator.wave}`,
                    class: predator.wave >= 7 ? 'bad' : predator.wave >= 5 ? 'neutral' : ''
                });
            }

            // Add skill trait if predator has a skill
            if (predator.skill) {
                const skillNames = {
                    ambush: 'AMBUSH',
                    swift: 'SWIFT',
                    venomous: 'VENOMOUS',
                    stomp: 'STOMP',
                    regenerate: 'REGEN',
                    armored: 'ARMORED'
                };
                traits.push({
                    text: skillNames[predator.skill] || predator.skill.toUpperCase(),
                    class: 'bad'
                });
            }

            // Add health-based trait
            if (hpPercent <= 25) {
                traits.unshift({ text: 'Near Death', class: 'good' });
            } else if (hpPercent <= 50) {
                traits.unshift({ text: 'Wounded', class: 'positive' });
            }

            // Add state-based trait
            if (predator.state === 'stunned') {
                traits.unshift({ text: 'Stunned', class: 'positive' });
            } else if (predator.state === 'eating') {
                traits.unshift({ text: 'Feeding', class: 'negative' });
            } else if (predator.state === 'hunting') {
                traits.unshift({ text: 'Hunting', class: 'negative' });
            }

            return {
                icon: baseData.icon,
                title: baseData.title,
                subtitle: baseData.subtitle,
                description: baseData.description,
                stats: stats,
                traits: traits
            };
        }

        // Track update interval for real-time character card updates
        let cardUpdateInterval = null;

        // Stat tooltips explaining what each stat does
        const STAT_TOOLTIPS = {
            'HP': 'Health points. When HP reaches 0, the ant dies. Regenerates slowly over time.',
            'ATK': 'Attack power. Higher ATK deals more damage to predators in combat.',
            'DEF': 'Defense rating. Reduces damage taken from predator attacks.',
            'SPD': 'Movement speed while exploring. Improves with level and upgrades.',
            'DET': 'Detection radius for spotting food sources. Higher = spots food from further away.',
            'CAP': 'Carry capacity. Units of food carried per trip. Higher = more food delivered at once.',
            'PHER': 'Pheromone trail strength. Higher values leave stronger trails for others to follow.',
            'HP5': 'Health regen per 5 seconds. Heals this amount of HP every 5 seconds. Gained from nectar deliveries.'
        };

        // Trait tooltips explaining what each trait means
        const TRAIT_TOOLTIPS = {
            // Level traits
            'Level 1': 'Novice ant, just starting out',
            'Level 2': 'Experienced ant with improved stats',
            'Level 3': 'Skilled ant - special ability unlocked!',
            'Level 4': 'Expert ant with significantly boosted stats',
            'Level 5': 'Master ant - maximum power achieved',
            // Experience-based traits
            'Daredevil': '10+ deliveries from danger zones - fearless!',
            'Risk Taker': '5+ deliveries from danger zones',
            'Veteran': '30+ total food deliveries',
            'Hardworker': '15+ total food deliveries',
            'Survivor': 'Escaped predators 5+ times - unkillable!',
            'Escapist': 'Escaped predators 2+ times',
            'Explorer': 'Discovered 10+ food sources',
            // Genetic traits
            'Swift': 'Born with exceptional speed (95%+ roll)',
            'Sharp Eyes': 'Born with exceptional detection (95%+ roll)',
            'Midas': 'Born with exceptional gold bonus (95%+ roll) - +95-100% gold per delivery!',
            // Skill traits
            'Efficient Forager': 'Follows pheromone trails with 95% accuracy instead of 70%',
            'Berserker': '+100% ATK when below 40% HP',
            'Trailblazer': 'Creates glowing beacon when discovering food',
            // Type traits
            'Worker': 'Standard colony worker - balanced stats',
            // Ant type base traits
            'Balanced': 'Average stats across the board',
            'Efficient Carrier': 'Good at transporting food',
            'Common': 'Standard worker type',
            'Brave': 'Will fight instead of flee',
            // Predator traits
            'Territorial': 'Guards a specific area',
            'Can Be Stunned': 'Can be temporarily disabled',
            'Deadly Strike': 'Instant kill on contact',
            'Fast': 'High movement speed',
            'Unpredictable': 'Erratic movement patterns',
            'Armored': 'Resistant to damage',
            'Slow Moving': 'Easy to outrun'
        };

        // Stat ranges for bar percentage calculation
        // Each stat has a min and max defining the expected range
        // Bar fills based on where the value falls in this range
        const STAT_RANGES = {
            'HP': { min: 0, max: 60 },      // base=10, 60+ with levels
            'ATK': { min: 0, max: 20 },     // base=2, 20+ with levels
            'DEF': { min: 0, max: 14 },     // base=2, 14+ with levels
            'SPD': { min: 0.2, max: 1.0 },  // base=0.5, 1.0+ is fast
            'DET': { min: 5, max: 200 },    // base=48, varies with upgrades
            'CAP': { min: 1, max: 8 },      // base=1, 6+ with levels
            'PHER': { min: 0.3, max: 5.0 }  // base=0.8
        };

        // Calculate bar percentage for a stat
        function getStatBarPercent(statName, value, antType) {
            // Check if we have a defined range for this stat
            const range = STAT_RANGES[statName];
            if (range) {
                // Parse the value - for HP, extract first number from "x/y" format
                let numValue;
                if (statName === 'HP' && typeof value === 'string' && value.includes('/')) {
                    // For HP bar, use max HP (second value) to show the stat quality
                    numValue = parseFloat(value.split('/')[1]) || 0;
                } else {
                    numValue = parseFloat(value) || 0;
                }

                // Calculate percentage: ((value - min) / (max - min)) * 100, clamped to 0-100
                const percent = ((numValue - range.min) / (range.max - range.min)) * 100;
                return Math.max(0, Math.min(100, percent));
            }

            // Fallback for legacy stat names (for compatibility)
            const typeConfig = CONFIG.antTypes[antType] || CONFIG.antTypes.worker;
            const levelBonuses = typeConfig.levelBonuses || {};
            let baseline, max;

            switch(statName) {
                case 'Speed':
                    baseline = typeConfig.speed;
                    max = baseline + (levelBonuses.speed || 0) * 4 * 1.4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Capacity':
                    baseline = typeConfig.carryCapacity;
                    max = baseline + (levelBonuses.carryCapacity || 0) * 4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Detection':
                    baseline = typeConfig.foodDetectRadius;
                    max = baseline + (levelBonuses.foodDetectRadius || 0) * 4 * 1.4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Combat':
                    const fightChance = parseInt(value.split('/')[0]) || 0;
                    return Math.min(100, fightChance * 1.25);
                case 'Trail':
                    return Math.min(100, parseFloat(value) / 2.3);
                case 'Spawn':
                    const secs = parseInt(value) || 15;
                    return Math.min(100, (20 - secs) * 10);
                case 'Haul':
                    return Math.min(100, parseFloat(value));
                case 'Gold':
                    return parseFloat(value.replace(/[+%]/g, ''));
                default:
                    return 50;
            }
        }

        // Generate dynamic HP tooltip showing current/max HP
        function getHpTooltip(currentHp, maxHp) {
            const hpPercent = Math.round((currentHp / maxHp) * 100);
            let status, statusClass;

            if (hpPercent >= 90) {
                status = 'Healthy';
                statusClass = 'good';
            } else if (hpPercent >= 75) {
                status = 'Minor wounds';
                statusClass = 'good';
            } else if (hpPercent >= 50) {
                status = 'Injured';
                statusClass = '';
            } else if (hpPercent >= 25) {
                status = 'Badly hurt';
                statusClass = 'weak';
            } else {
                status = 'Critical!';
                statusClass = 'bad';
            }

            return `<span class="hp-current">${currentHp}</span>/<span class="hp-max">${maxHp}</span> HP (${hpPercent}%)<br><span class="hp-status ${statusClass}">${status}</span><br><small>Regenerates slowly over time</small>`;
        }

        function showCharacterCard(data, ant = null, predator = null, predatorKey = null) {
            selectedAnt = ant;
            selectedPredator = predator;
            selectedPredatorKey = predatorKey;
            const card = document.getElementById('character-card');

            // Update basic info
            document.getElementById('card-icon').textContent = data.icon;
            document.getElementById('card-title').textContent = data.title;
            document.getElementById('card-subtitle').textContent = data.subtitle;

            // Update compact HP and XP bars (only for ants)
            const expSection = document.getElementById('card-exp-section');
            if (ant && ant.experience) {
                expSection.style.display = 'block';

                const level = ant.getLevel();
                const xpProgress = ant.getLevelProgress();
                const currentHp = Math.round(ant.currentHp || ant.maxHp);
                const maxHp = Math.round(ant.maxHp);
                const hpPercent = (currentHp / maxHp) * 100;

                // Update HP bar
                const hpBar = document.getElementById('compact-hp-bar');
                const hpText = document.getElementById('compact-hp-text');
                if (hpBar) {
                    hpBar.style.width = `${hpPercent}%`;
                    hpBar.className = 'compact-bar hp';
                    if (hpPercent <= 20) hpBar.classList.add('critical');
                    else if (hpPercent <= 40) hpBar.classList.add('low');
                }
                if (hpText) hpText.textContent = `${currentHp}/${maxHp}`;

                // Update XP bar (no max level cap)
                const xpBar = document.getElementById('compact-xp-bar');
                const levelEl = document.getElementById('compact-level');
                if (xpBar) {
                    xpBar.style.width = `${xpProgress}%`;
                    xpBar.className = 'compact-bar xp';
                    // Add special glow for high levels
                    if (level >= 10) xpBar.classList.add('legendary');
                    else if (level >= 7) xpBar.classList.add('epic');
                    else if (level >= 5) xpBar.classList.add('rare');
                }
                if (levelEl) levelEl.textContent = `Lv.${level}`;

                document.getElementById('card-id').textContent = `#${String(ant.id).padStart(3, '0')}`;

                // Show skills if ant has any - WoW-style square icons
                const skillSection = document.getElementById('card-skill-section');
                if (ant.chosenSkill || ant.chosenSkill2) {
                    skillSection.style.display = 'block';
                    const now = Date.now();

                    // Helper function to render a skill icon
                    const renderSkillIcon = (skill, skillKey, slotNum) => {
                        const lastUse = ant.getLastSkillUse(skillKey);
                        const cooldownRemaining = Math.max(0, (lastUse + skill.cooldown) - now);
                        const cooldownPercent = skill.cooldown > 0 ? (cooldownRemaining / skill.cooldown) * 100 : 0;
                        const isReady = cooldownRemaining === 0 || skill.type === 'passive';
                        const cooldownSeconds = Math.ceil(cooldownRemaining / 1000);
                        const isPassive = skill.type === 'passive';
                        const cooldownText = isPassive ? 'Passive' : `${skill.cooldown / 1000}s cooldown`;
                        const stateClass = isPassive ? 'passive' : (isReady ? 'ready' : 'on-cooldown');
                        const levelText = slotNum === 1 ? 'Level 3 Skill' : 'Level 7 Skill';

                        return `
                            <div class="card-skill">
                                <div class="wow-skill-icon ${stateClass}" data-skill-wrapper="${slotNum}">
                                    <div class="wow-ready-glow"></div>
                                    <span class="skill-emoji">${skill.icon}</span>
                                    ${!isPassive ? `<div class="wow-cooldown-sweep" style="--cooldown-percent: ${cooldownPercent}%"></div>` : ''}
                                    ${!isPassive && cooldownSeconds > 0 ? `<span class="wow-cooldown-text">${cooldownSeconds}</span>` : ''}
                                    ${isPassive ? `<span class="wow-passive-badge">P</span>` : ''}
                                </div>
                                <div class="ability-tooltip">
                                    <div class="ability-tooltip-header">
                                        <span class="ability-tooltip-icon">${skill.icon}</span>
                                        <div class="ability-tooltip-title">
                                            <div class="ability-tooltip-name">${skill.name}</div>
                                            <div class="ability-tooltip-type">${isPassive ? 'Passive Ability' : 'Active Ability'}</div>
                                        </div>
                                    </div>
                                    <div class="ability-tooltip-desc">${skill.description}</div>
                                    <div class="ability-tooltip-meta">
                                        <span class="ability-tooltip-cooldown">${cooldownText}</span>
                                        <span>${levelText}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    };

                    let skillsHtml = '<div class="card-skills-row">';
                    if (ant.chosenSkill) {
                        skillsHtml += renderSkillIcon(ant.chosenSkill, ant.skillKey, 1);
                    }
                    if (ant.chosenSkill2) {
                        skillsHtml += renderSkillIcon(ant.chosenSkill2, ant.skillKey2, 2);
                    }
                    skillsHtml += '</div>';
                    skillSection.innerHTML = skillsHtml;
                } else {
                    skillSection.style.display = 'none';
                }
            } else {
                // Predator mode - show HP bar only
                expSection.style.display = 'block';
                document.getElementById('hp-bar-row').style.display = 'flex';
                document.getElementById('card-id').textContent = 'PREDATOR';
                document.getElementById('card-skill-section').style.display = 'none';
                // Hide XP row for predators
                const xpRow = expSection.querySelector('.compact-bar-row:last-child');
                if (xpRow) xpRow.style.display = 'none';
            }

            // Build compact stats grid (exclude HP since it has its own bar)
            let statsHtml = '';
            for (const stat of data.stats) {
                if (stat.name === 'HP') continue; // Skip HP, we have the bar
                const tooltip = STAT_TOOLTIPS[stat.name] || '';
                statsHtml += `<div class="stat-item" data-stat="${stat.name}">
                    <div class="stat-header">
                        <span class="stat-name">${stat.name}</span>
                        <span class="stat-val ${stat.class || ''}">${stat.value}</span>
                    </div>
                    ${tooltip ? `<div class="stat-tooltip">${tooltip}</div>` : ''}
                </div>`;
            }
            document.getElementById('card-stats').innerHTML = statsHtml;

            // Build compact traits (only show level and skill)
            let traitsHtml = '';
            for (const trait of data.traits) {
                // Only include Level and skill traits in compact mode
                if (trait.text.startsWith('Level') || trait.class === 'skill') {
                    const tooltip = TRAIT_TOOLTIPS[trait.text] || '';
                    const tooltipHtml = tooltip ? `<span class="trait-tooltip">${tooltip}</span>` : '';
                    traitsHtml += `<span class="trait-tag ${trait.class}">${trait.text}${tooltipHtml}</span>`;
                }
            }
            document.getElementById('card-traits').innerHTML = traitsHtml;

            card.classList.remove('hidden');
            characterCardOpen = true;

            // Start real-time updates for ants or predators
            if (cardUpdateInterval) clearInterval(cardUpdateInterval);
            cardUpdateInterval = setInterval(() => {
                if (characterCardOpen) {
                    if (selectedAnt) {
                        updateCardRealTime();
                    } else if (selectedPredator) {
                        updatePredatorCardRealTime();
                    }
                }
            }, 100);  // Faster updates for smoother HP display
        }

        // Real-time update function for the card (compact version)
        function updateCardRealTime() {
            if (!selectedAnt || !characterCardOpen) return;

            // Check if ant still exists
            if (!ants.includes(selectedAnt)) {
                closeCharacterCard();
                return;
            }

            const ant = selectedAnt;
            const level = ant.getLevel();
            const xpProgress = ant.getLevelProgress();
            const currentHp = Math.round(ant.currentHp || ant.maxHp);
            const maxHp = Math.round(ant.maxHp);
            const hpPercent = (currentHp / maxHp) * 100;

            // Update compact HP bar
            const hpBar = document.getElementById('compact-hp-bar');
            const hpText = document.getElementById('compact-hp-text');
            if (hpBar) {
                hpBar.style.width = `${hpPercent}%`;
                hpBar.className = 'compact-bar hp';
                if (hpPercent <= 20) hpBar.classList.add('critical');
                else if (hpPercent <= 40) hpBar.classList.add('low');
            }
            if (hpText) hpText.textContent = `${currentHp}/${maxHp}`;

            // Update compact XP bar (no max level cap)
            const xpBar = document.getElementById('compact-xp-bar');
            const levelEl = document.getElementById('compact-level');
            if (xpBar) {
                xpBar.style.width = `${xpProgress}%`;
                xpBar.className = 'compact-bar xp';
                // Add special glow for high levels
                if (level >= 10) xpBar.classList.add('legendary');
                else if (level >= 7) xpBar.classList.add('epic');
                else if (level >= 5) xpBar.classList.add('rare');
            }
            if (levelEl) levelEl.textContent = `Lv.${level}`;

            // Update subtitle with current level
            const baseData = ANT_CARD_DATA[ant.type];
            document.getElementById('card-subtitle').textContent = `Lv.${level} ${baseData.title}`;

            // Update stat values without rebuilding
            const cardData = generateAntCardData(ant);
            const statItems = document.querySelectorAll('.stat-item');
            let statIndex = 0;

            cardData.stats.forEach((stat) => {
                if (stat.name === 'HP') return; // Skip HP
                if (statItems[statIndex]) {
                    const valEl = statItems[statIndex].querySelector('.stat-val');
                    if (valEl) {
                        valEl.textContent = stat.value;
                        valEl.className = `stat-val ${stat.class || ''}`;
                    }
                }
                statIndex++;
            });

            // Update skill cooldowns in real-time (both slots)
            const now = Date.now();

            // Helper function to update a skill cooldown display
            const updateSkillCooldown = (skill, skillKey, slotNum) => {
                if (!skill || skill.type === 'passive') return;

                const lastUse = ant.getLastSkillUse(skillKey);
                const cooldownRemaining = Math.max(0, (lastUse + skill.cooldown) - now);
                const cooldownPercent = skill.cooldown > 0 ? (cooldownRemaining / skill.cooldown) * 100 : 0;
                const isReady = cooldownRemaining === 0;
                const cooldownSeconds = Math.ceil(cooldownRemaining / 1000);

                const wrapper = document.querySelector(`[data-skill-wrapper="${slotNum}"]`);
                if (wrapper) {
                    const sweep = wrapper.querySelector('.wow-cooldown-sweep');
                    const text = wrapper.querySelector('.wow-cooldown-text');

                    if (isReady) {
                        wrapper.classList.add('ready');
                        wrapper.classList.remove('on-cooldown');
                    } else {
                        wrapper.classList.remove('ready');
                        wrapper.classList.add('on-cooldown');
                    }

                    if (sweep) {
                        sweep.style.setProperty('--cooldown-percent', `${cooldownPercent}%`);
                    }
                    if (text) {
                        text.textContent = cooldownSeconds > 0 ? cooldownSeconds : '';
                    }
                }
            };

            // Update both skill slots
            if (ant.chosenSkill) updateSkillCooldown(ant.chosenSkill, ant.skillKey, 1);
            if (ant.chosenSkill2) updateSkillCooldown(ant.chosenSkill2, ant.skillKey2, 2);
        }

        function closeCharacterCard() {
            document.getElementById('character-card').classList.add('hidden');
            characterCardOpen = false;
            selectedAnt = null;
            selectedPredator = null;
            selectedPredatorKey = null;
            if (cardUpdateInterval) {
                clearInterval(cardUpdateInterval);
                cardUpdateInterval = null;
            }
        }

        // Real-time update function for predator cards
        function updatePredatorCardRealTime() {
            if (!selectedPredator || !selectedPredatorKey || !characterCardOpen) return;

            // Check if predator still exists
            const predatorArray = selectedPredatorKey === 'spider' ? spiderPredators : beetlePredators;
            if (!predatorArray.includes(selectedPredator)) {
                closeCharacterCard();
                return;
            }

            const predator = selectedPredator;
            const cardData = generatePredatorCardData(predator, selectedPredatorKey);

            // Update compact HP bar for predators
            const hpStat = cardData.stats.find(s => s.name === 'HP');
            if (hpStat) {
                const [currentHp, maxHp] = String(hpStat.value).split('/').map(Number);
                const hpPercent = (currentHp / maxHp) * 100;

                const hpBar = document.getElementById('compact-hp-bar');
                const hpText = document.getElementById('compact-hp-text');
                if (hpBar) {
                    hpBar.style.width = `${hpPercent}%`;
                    hpBar.className = 'compact-bar hp';
                    if (hpPercent <= 20) hpBar.classList.add('critical');
                    else if (hpPercent <= 40) hpBar.classList.add('low');
                }
                if (hpText) hpText.textContent = `${currentHp}/${maxHp}`;
            }

            // Update stat values without rebuilding (skip HP)
            const statItems = document.querySelectorAll('.stat-item');
            let statIndex = 0;
            cardData.stats.forEach((stat) => {
                if (stat.name === 'HP') return; // Skip HP
                if (statItems[statIndex]) {
                    const valEl = statItems[statIndex].querySelector('.stat-val');
                    if (valEl) {
                        valEl.textContent = stat.value;
                        valEl.className = `stat-val ${stat.class || ''}`;
                    }
                }
                statIndex++;
            });
        }

        // Helper to get predator stat bar percentage
        function getPredatorStatBarPercent(statName, value, predatorKey) {
            const cfg = CONFIG.predators[predatorKey];
            switch (statName) {
                case 'HP':
                    const [current, max] = String(value).split('/').map(Number);
                    return (current / max) * 100;
                case 'ATK':
                    return Math.min((parseFloat(value) / 20) * 100, 100);
                case 'DEF':
                    return Math.min((parseFloat(value) / 10) * 100, 100);
                case 'SPD':
                    return Math.min((parseFloat(value) / 3) * 100, 100);
                default:
                    return 50;
            }
        }

        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            panel.classList.toggle('collapsed');
        }

        function findClickedEntity(x, y) {
            // Check predators first (larger click targets)
            for (const { predator, key } of getAllPredatorsWithKeys()) {
                const dist = Math.hypot(predator.x - x, predator.y - y);
                if (dist < 30) {
                    return { type: 'predator', key: key, predator: predator };
                }
            }

            // Check ants
            for (const ant of ants) {
                const dist = Math.hypot(ant.x - x, ant.y - y);
                if (dist < 15) {
                    return { type: 'ant', ant: ant };
                }
            }

            return null;
        }

        function findAntsInRect(x1, y1, x2, y2) {
            // Normalize rectangle coordinates
            const left = Math.min(x1, x2);
            const right = Math.max(x1, x2);
            const top = Math.min(y1, y2);
            const bottom = Math.max(y1, y2);

            const foundAnts = [];
            for (const ant of ants) {
                if (ant.x >= left && ant.x <= right && ant.y >= top && ant.y <= bottom) {
                    foundAnts.push(ant);
                }
            }
            return foundAnts;
        }

        function findEntitiesInRect(x1, y1, x2, y2) {
            // Normalize rectangle coordinates
            const left = Math.min(x1, x2);
            const right = Math.max(x1, x2);
            const top = Math.min(y1, y2);
            const bottom = Math.max(y1, y2);

            const entities = [];

            // Check predators
            for (const { predator, key } of getAllPredatorsWithKeys()) {
                if (predator.x >= left && predator.x <= right && predator.y >= top && predator.y <= bottom) {
                    entities.push({ type: 'predator', key: key, predator: predator });
                }
            }

            // Check ants
            for (const ant of ants) {
                if (ant.x >= left && ant.x <= right && ant.y >= top && ant.y <= bottom) {
                    entities.push({ type: 'ant', ant: ant });
                }
            }

            return entities;
        }

        function drawSelectionRect() {
            if (!isDragging) return;

            const left = Math.min(dragStartX, dragCurrentX);
            const top = Math.min(dragStartY, dragCurrentY);
            const right = Math.max(dragStartX, dragCurrentX);
            const bottom = Math.max(dragStartY, dragCurrentY);
            const w = right - left;
            const h = bottom - top;

            if (w < dragThreshold && h < dragThreshold) return;

            ctx.save();

            // Semi-transparent fill
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(left, top, w, h);

            // Animated dashed border
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.lineDashOffset = -Date.now() / 50;
            ctx.strokeRect(left, top, w, h);

            // Corner accents
            const cornerSize = 12;
            ctx.setLineDash([]);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 8;

            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(left, top + cornerSize);
            ctx.lineTo(left, top);
            ctx.lineTo(left + cornerSize, top);
            ctx.stroke();

            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, top);
            ctx.lineTo(right, top);
            ctx.lineTo(right, top + cornerSize);
            ctx.stroke();

            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(left, bottom - cornerSize);
            ctx.lineTo(left, bottom);
            ctx.lineTo(left + cornerSize, bottom);
            ctx.stroke();

            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, bottom);
            ctx.lineTo(right, bottom);
            ctx.lineTo(right, bottom - cornerSize);
            ctx.stroke();

            // Show count of entities in selection
            const entitiesInRect = findEntitiesInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
            if (entitiesInRect.length > 0) {
                const antCount = entitiesInRect.filter(e => e.type === 'ant').length;
                const predatorCount = entitiesInRect.filter(e => e.type === 'predator').length;

                ctx.shadowBlur = 12;
                ctx.font = 'bold 14px "Orbitron", monospace';

                // Build text based on what's selected
                let text = '';
                if (antCount > 0 && predatorCount > 0) {
                    text = `${antCount} ANT${antCount > 1 ? 'S' : ''} + ${predatorCount} PREDATOR${predatorCount > 1 ? 'S' : ''}`;
                } else if (antCount > 0) {
                    text = `${antCount} ANT${antCount > 1 ? 'S' : ''}`;
                } else if (predatorCount > 0) {
                    text = `${predatorCount} PREDATOR${predatorCount > 1 ? 'S' : ''}`;
                }

                const metrics = ctx.measureText(text);
                const padding = 8;
                const boxWidth = metrics.width + padding * 2;
                const boxHeight = 24;
                const boxX = left + w / 2 - boxWidth / 2;
                const boxY = top - boxHeight - 8;

                // Background
                ctx.fillStyle = 'rgba(0, 20, 10, 0.95)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = predatorCount > 0 ? '#ff6666' : '#00ff88';
                ctx.lineWidth = 1;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // Text
                ctx.fillStyle = predatorCount > 0 ? '#ff6666' : '#00ff88';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, left + w / 2, boxY + boxHeight / 2);
            }

            ctx.restore();
        }

        function placeFood(x, y) {
            // Only place food if placement mode is active
            if (!foodPlacementActive || !selectedFoodType) return false;

            const now = Date.now();
            const minInterval = selectedFoodType === 'sugar' ? 100 : 200;
            if (now - lastPlaceTime < minInterval) return false;
            lastPlaceTime = now;

            // Check if position is within a food spot
            let inFoodSpot = false;
            for (const spot of foodSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius) {
                    inFoodSpot = true;
                    break;
                }
            }
            if (!inFoodSpot) return false;

            if (addFood(x, y, selectedFoodType)) {
                showHint = false;

                // Start cooldown for this food type
                const placedFoodType = selectedFoodType;
                startFoodCooldown(placedFoodType);

                // Deactivate placement mode since food is now on cooldown
                deactivateFoodPlacement();

                return true;
            }
            return false;
        }

        let wasDragging = false; // Track if we just finished a drag

        // Assign food zone multipliers based on distance from hive
        // Nearest = x1, Middle = x2, Furthest = x3
        // Also reorders foodSpots array so index 0 = nearest, etc.
        function assignFoodZoneMultipliers() {
            if (foodSpots.length === 0) return;

            // Sort foodSpots array directly by distance from nest (nearest first)
            foodSpots.sort((a, b) => {
                const distA = Math.hypot(a.x - CONFIG.nestX, a.y - CONFIG.nestY);
                const distB = Math.hypot(b.x - CONFIG.nestX, b.y - CONFIG.nestY);
                return distA - distB;
            });

            // Assign multipliers: x1 for nearest, x2 for middle, x3 for furthest
            const multipliers = [1, 2, 3];
            foodSpots.forEach((spot, i) => {
                spot.multiplier = multipliers[Math.min(i, multipliers.length - 1)];
            });
        }

        // Get the food zone multiplier for a given position
        function getFoodZoneMultiplier(x, y) {
            for (const spot of foodSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius) {
                    return spot.multiplier || 1;
                }
            }
            return 1; // Default multiplier outside food zones
        }

        // Preview multipliers during hive placement (temporary, not saved to spots)
        let previewMultipliers = new Map();
        let isPreviewingHivePlacement = false;

        // Calculate preview multipliers based on hypothetical hive position
        function calculatePreviewMultipliers(hiveX, hiveY) {
            if (foodSpots.length === 0) return;

            // Calculate distance from each food spot to the hypothetical hive position
            const spotsWithDistance = foodSpots.map((spot, index) => ({
                spot: spot,
                index: index,
                distance: Math.hypot(spot.x - hiveX, spot.y - hiveY)
            }));

            // Sort by distance (nearest first)
            spotsWithDistance.sort((a, b) => a.distance - b.distance);

            // Assign preview multipliers: x1 for nearest, x2 for middle, x3 for furthest
            const multipliers = [1, 2, 3];
            previewMultipliers.clear();
            spotsWithDistance.forEach((item, i) => {
                previewMultipliers.set(item.spot, multipliers[Math.min(i, multipliers.length - 1)]);
            });
        }

        // Get the multiplier to display (preview during placement, actual otherwise)
        function getDisplayMultiplier(spot) {
            if (isPreviewingHivePlacement && previewMultipliers.has(spot)) {
                return previewMultipliers.get(spot);
            }
            return spot.multiplier || 1;
        }

        // Hive placement function - called when player clicks to place hive at game start
        function placeHive(x, y) {
            if (gameStarted) return;

            // Check if placement is inside a food zone (within 80px of any food spot)
            const FOOD_ZONE_RADIUS = 80;
            for (const spot of foodSpots) {
                const dist = Math.hypot(x - spot.x, y - spot.y);
                if (dist < FOOD_ZONE_RADIUS) {
                    // Too close to a food zone - show warning and reject
                    spawnFloatingText(x, y, 'Too close to food zone!', '#ff6b6b', 14, 90);
                    return;
                }
            }

            // Set the nest position to where the player clicked
            CONFIG.nestX = x;
            CONFIG.nestY = y;

            // Assign food zone multipliers based on distance from hive
            // Sort food spots by distance and assign x1, x2, x3 multipliers
            assignFoodZoneMultipliers();

            // Initialize food in all zones (auto-spawned, no manual placement)
            initFoodInZones();

            // Initialize ants at the new hive location
            ants = [];
            for (let i = 0; i < CONFIG.initialAnts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * CONFIG.nestRadius * 0.7;
                ants.push(new Ant(CONFIG.nestX + Math.cos(angle) * dist, CONFIG.nestY + Math.sin(angle) * dist, 'worker'));
            }
            totalAntsSpawned = ants.length;

            // Start the game
            gameStarted = true;
            gameStartTime = Date.now();
            pausedTime = 0;
            pauseStartTime = null;

            // Initialize cycle timer for food rework
            initCycleTimer();

            // Hide the placement overlay and hive cursor
            document.getElementById('hive-placement-overlay').classList.add('hidden');
            document.getElementById('hive-cursor').classList.add('hidden');
            isPreviewingHivePlacement = false;
            previewMultipliers.clear();
        }

        // Add click handler to hive placement overlay
        document.getElementById('hive-placement-overlay').addEventListener('click', (e) => {
            placeHive(e.clientX, e.clientY);
        });

        // Add touch handler to hive placement overlay
        document.getElementById('hive-placement-overlay').addEventListener('touchend', (e) => {
            if (e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                placeHive(touch.clientX, touch.clientY);
            }
        });

        // Add mousemove handler for hive cursor and multiplier preview
        document.getElementById('hive-placement-overlay').addEventListener('mousemove', (e) => {
            const hiveCursor = document.getElementById('hive-cursor');

            // Update hive cursor position
            hiveCursor.style.left = e.clientX + 'px';
            hiveCursor.style.top = e.clientY + 'px';
            hiveCursor.classList.remove('hidden');

            // Calculate and update preview multipliers
            isPreviewingHivePlacement = true;
            calculatePreviewMultipliers(e.clientX, e.clientY);
        });

        // Show hive cursor when mouse enters overlay
        document.getElementById('hive-placement-overlay').addEventListener('mouseenter', (e) => {
            const hiveCursor = document.getElementById('hive-cursor');
            hiveCursor.classList.remove('hidden');
            isPreviewingHivePlacement = true;
        });

        // Hide hive cursor when mouse leaves overlay
        document.getElementById('hive-placement-overlay').addEventListener('mouseleave', (e) => {
            const hiveCursor = document.getElementById('hive-cursor');
            hiveCursor.classList.add('hidden');
            isPreviewingHivePlacement = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // Handle hive placement at game start
            if (!gameStarted) {
                placeHive(e.clientX, e.clientY);
                return;
            }

            // If card is open, close it and don't start drag
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            // Start potential drag selection
            isDragging = true;
            wasDragging = false;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragCurrentX = e.clientX;
            dragCurrentY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            // Handle selection drag
            if (isDragging) {
                dragCurrentX = e.clientX;
                dragCurrentY = e.clientY;

                // Check if we've exceeded the threshold to be considered a drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                if (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold) {
                    wasDragging = true;
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isPlacing = false;

            if (isDragging) {
                isDragging = false;

                // Check if this was a significant drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                const wasDragSelection = Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold;

                if (wasDragSelection) {
                    // Find all entities (ants and predators) in selection rectangle
                    const selectedEntities = findEntitiesInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
                    if (selectedEntities.length > 0) {
                        // Select a random entity from the selection
                        const randomEntity = selectedEntities[Math.floor(Math.random() * selectedEntities.length)];
                        if (randomEntity.type === 'ant') {
                            showCharacterCard(generateAntCardData(randomEntity.ant), randomEntity.ant);
                        } else if (randomEntity.type === 'predator') {
                            showCharacterCard(generatePredatorCardData(randomEntity.predator, randomEntity.key), null, randomEntity.predator, randomEntity.key);
                        }
                    }
                    wasDragging = false;
                    return;
                }
            }

            // Only process click if we weren't dragging
            if (!wasDragging && !foodPlacementActive) {
                const entity = findClickedEntity(e.clientX, e.clientY);
                if (entity) {
                    if (entity.type === 'ant') {
                        showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                    } else if (entity.type === 'predator') {
                        showCharacterCard(generatePredatorCardData(entity.predator, entity.key), null, entity.predator, entity.key);
                    }
                }
            }
            wasDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isPlacing = false;
            isDragging = false;
            wasDragging = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            // Handle hive placement at game start
            if (!gameStarted) {
                placeHive(touchX, touchY);
                return;
            }

            // If card is open, close it on any touch
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            // Check if touching an entity
            const entity = findClickedEntity(touchX, touchY);
            if (entity) {
                if (entity.type === 'ant') {
                    showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                } else if (entity.type === 'predator') {
                    showCharacterCard(generatePredatorCardData(entity.predator, entity.key), null, entity.predator, entity.key);
                }
                return;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            // Food placement removed - auto-spawns now
        });

        canvas.addEventListener('touchend', () => isPlacing = false);

        // ===========================================
        // HARVEST CYCLE SYSTEM
        // ===========================================

        let harvestModalOpen = false;

        // Initialize cycle timer when game starts
        function initCycleTimer() {
            cycleStartTime = Date.now();
            lastCycleTime = Date.now();
        }

        // Update cycle timer UI based on auto-spawn time
        function updateCycleTimerUI() {
            if (harvestModalOpen) return;

            // Calculate time remaining until next auto-spawn
            const elapsed = getElapsedSeconds();
            const timeSinceLastSpawn = elapsed - lastAutoSpawnTime;
            const remaining = Math.max(0, AUTO_SPAWN_INTERVAL - timeSinceLastSpawn);
            const seconds = Math.ceil(remaining);

            // Update UI
            const countdownEl = document.getElementById('cycle-countdown');
            const barFillEl = document.getElementById('cycle-bar-fill');
            if (countdownEl) countdownEl.textContent = seconds + 's';
            if (barFillEl) barFillEl.style.width = (remaining / AUTO_SPAWN_INTERVAL * 100) + '%';

            // Update preview stats
            updatePreviewStats();

            // Update food level displays
            updateFoodLevelDisplays();
        }

        // Update the preview stats display
        function updatePreviewStats() {
            const previewEl = document.getElementById('preview-stats');
            if (!previewEl) return;

            const parts = [];
            if (accumulatedBonuses.hp > 0) parts.push(`HP+${accumulatedBonuses.hp}`);
            if (accumulatedBonuses.atk > 0) parts.push(`ATK+${accumulatedBonuses.atk}`);
            if (accumulatedBonuses.def > 0) parts.push(`DEF+${accumulatedBonuses.def}`);
            if (accumulatedBonuses.carry > 0) parts.push(`CARRY+${accumulatedBonuses.carry}`);

            previewEl.textContent = parts.length > 0 ? parts.join(' ') : '--';
        }

        // Update food level displays in the UI
        function updateFoodLevelDisplays() {
            for (const foodType of Object.keys(foodLevels)) {
                const levelEl = document.getElementById(`${foodType}-level`);
                if (levelEl) {
                    const level = foodLevels[foodType];
                    levelEl.textContent = level;  // Just the number
                    if (level >= 10) {
                        levelEl.classList.add('max-level');
                    } else {
                        levelEl.classList.remove('max-level');
                    }
                }
            }
        }

        // Trigger harvest summary modal
        function triggerHarvestSummary() {
            harvestModalOpen = true;

            // Populate the modal
            const deliveriesEl = document.getElementById('harvest-deliveries');
            const hpEl = document.getElementById('harvest-hp');
            const atkEl = document.getElementById('harvest-atk');
            const defEl = document.getElementById('harvest-def');
            const carryEl = document.getElementById('harvest-carry');
            const abilitiesEl = document.getElementById('harvest-abilities');

            // Show delivered food icons
            if (deliveriesEl) {
                if (cycleDeliveries.length > 0) {
                    deliveriesEl.innerHTML = cycleDeliveries.map((d, i) =>
                        `<span class="harvest-food-icon" style="animation-delay: ${i * 0.1}s">${d.emoji}</span>`
                    ).join('');
                } else {
                    deliveriesEl.innerHTML = '<div class="harvest-no-deliveries">No food delivered this cycle</div>';
                }
            }

            // Show accumulated stats
            if (hpEl) {
                hpEl.textContent = `+${accumulatedBonuses.hp}`;
                hpEl.classList.toggle('has-bonus', accumulatedBonuses.hp > 0);
            }
            if (atkEl) {
                atkEl.textContent = `+${accumulatedBonuses.atk}`;
                atkEl.classList.toggle('has-bonus', accumulatedBonuses.atk > 0);
            }
            if (defEl) {
                defEl.textContent = `+${accumulatedBonuses.def}`;
                defEl.classList.toggle('has-bonus', accumulatedBonuses.def > 0);
            }
            if (carryEl) {
                carryEl.textContent = `+${accumulatedBonuses.carry}`;
                carryEl.classList.toggle('has-bonus', accumulatedBonuses.carry > 0);
            }

            // Show abilities
            if (abilitiesEl) {
                if (accumulatedBonuses.abilities.length > 0) {
                    abilitiesEl.innerHTML = accumulatedBonuses.abilities.map(ability => {
                        const bonus = Object.values(FOOD_BONUSES).find(b => b.ability === ability);
                        const name = bonus ? bonus.abilityName : ability;
                        return `<span class="harvest-ability">${name}</span>`;
                    }).join('');
                } else {
                    abilitiesEl.innerHTML = '';
                }
            }

            // Show modal
            const modal = document.getElementById('harvest-modal');
            if (modal) modal.classList.add('visible');
        }

        // Spawn ant with accumulated bonuses
        function spawnHarvestAnt() {
            if (gameOver) return;

            // Only spawn if there are any bonuses accumulated or we have deliveries
            const hasAnyBonus = accumulatedBonuses.hp > 0 || accumulatedBonuses.atk > 0 ||
                               accumulatedBonuses.def > 0 || accumulatedBonuses.carry > 0 ||
                               cycleDeliveries.length > 0;

            if (hasAnyBonus && ants.length < CONFIG.maxAnts) {
                // Create new ant at hive
                const angle = Math.random() * Math.PI * 2;
                const spawnDist = getColonySize() * 0.3;
                const newAnt = new Ant(
                    CONFIG.nestX + Math.cos(angle) * spawnDist,
                    CONFIG.nestY + Math.sin(angle) * spawnDist,
                    'worker'
                );

                // Apply accumulated bonuses
                newAnt.permHpBonus = (newAnt.permHpBonus || 0) + accumulatedBonuses.hp;
                newAnt.maxHp += accumulatedBonuses.hp;
                newAnt.currentHp = newAnt.maxHp;
                newAnt.permAtkBonus = (newAnt.permAtkBonus || 0) + accumulatedBonuses.atk;
                newAnt.permDefBonus = (newAnt.permDefBonus || 0) + accumulatedBonuses.def;
                newAnt.carryCapacity += accumulatedBonuses.carry;

                // Apply abilities
                newAnt.harvestAbilities = [...accumulatedBonuses.abilities];

                ants.push(newAnt);
                totalAntsSpawned++;
                addSpawnNotification('worker');

                // Show birth effect
                spawnFloatingText(CONFIG.nestX, CONFIG.nestY - 30, 'NEW ANT!', '#00ff88', 16);
            }

            // Reset cycle
            resetCycle();
        }

        // Reset cycle for next harvest
        function resetCycle() {
            cycleStartTime = Date.now();
            accumulatedBonuses.hp = 0;
            accumulatedBonuses.atk = 0;
            accumulatedBonuses.def = 0;
            accumulatedBonuses.carry = 0;
            accumulatedBonuses.abilities = [];
            cycleDeliveries = [];
            harvestModalOpen = false;

            // Hide modal
            const modal = document.getElementById('harvest-modal');
            if (modal) modal.classList.remove('visible');
        }

        // Handle harvest continue button click
        document.getElementById('harvest-continue-btn')?.addEventListener('click', () => {
            spawnHarvestAnt();
            // Now show upgrade selection after ant spawns
            showUpgradeSelection();
            // Check for pending skill choices after upgrade closes
            setTimeout(() => {
                if (!skillChoiceModalOpen && pendingSkillChoices.length > 0) {
                    showNextSkillChoice();
                }
            }, 500);
        });

        // ===========================================
        // MAIN LOOP
        // ===========================================

        function update() {
            // Don't update if game hasn't started (waiting for hive placement)
            // Also pause during skill selection modal
            if (!gameStarted || gameOver || upgradesPaused || skillChoiceModalOpen) return;

            time++;

            // Check if it's time for upgrades
            checkUpgradeTime();

            // Check if it's time to auto-spawn a worker ant
            checkAutoSpawn();

            // Check if we should spawn more predators (every minute)
            checkPredatorSpawn();

            // Check for rare food spawns (golden apples)
            checkRareFoodSpawn();

            for (const ant of ants) {
                ant.update();
                ant.updateBuffs();  // Clean up expired food buffs
            }

            // Update all predators from arrays
            for (const spider of spiderPredators) spider.update();
            for (const beetle of beetlePredators) beetle.update();

            decayPheromones();
            updateAmbientParticles();
            updateSpawnNotifications();
            updateRareFoodNotifications();  // Golden apple notifications
            updateFoodTimers();
            updateDeathCounter();  // For Berserker skill
            updateTrailblazerBeacons();  // For Trailblazer skill
            checkAntPredatorCombat();  // All ants fight nearby predators
            updateFloatingTexts();  // Reward and damage floating text
            updateCombatEffects();  // Combat clash animations
            updateDeathEffects();   // Death particle animations
            updateLevelUpEffects(); // Level up visual effects
            updatePounceEffects();  // Pounce skill effects
            updateGoldBurstEffects(); // Gold Rush skill effects
            updateShockwaveEffects(); // Shockwave skill effects
            updateRallyCryEffects(); // Rally Cry skill effects
            updateVampireBiteEffects(); // Vampire Bite skill effects
            updateBerserkerEffects(); // Berserker skill effects
            updateSecondWindEffects(); // Second Wind phoenix effect
            updateScavengerEffects(); // Scavenger XP sparkles
            updateHeavyLifterEffects(); // Heavy Lifter strength aura
            updatePathfinderEffects(); // Pathfinder compass pulse
            updateMomentumEffects(); // Momentum speed streaks
            updateBloodlustEffects(); // Bloodlust crimson aura
            updateAdrenalineEffects(); // Adrenaline lightning surge
            updateDecoyEffects(); // Decoy spawn effect
            updateDecoyAnts(); // Decoy ghost ants
            updateLastStandEffects(); // Last Stand skull aura
            updateLuckyEffects(); // Lucky clover shimmer
            updatePackHunterEffects(); // Pack Hunter wolf howl
            updateDashEffects(); // Dash teleport effect
            updateEarthquakeEffects(); // Earthquake ground slam
            updateChainLightningEffects(); // Chain lightning arcs
            updateVoidRiftEffects(); // Void rift portals
            updateFireBreathEffects(); // Fire breath cones
            updateIceNovaEffects(); // Ice nova freeze
            updateShadowStepEffects(); // Shadow step stealth
            updateWarCryEffects(); // War cry terror
            updateHealingAuraEffects(); // Healing aura
            updateMeteorStrikeEffects(); // Meteor strike
            updateMirrorImageEffects(); // Mirror image clones
            updateMirrorDecoys(); // Mirror decoy entities
            checkMirrorDecoyCombat(); // Predators attack decoys
            updateBlinkEffects(); // Blink teleport
            updateSpiritLinkEffects(); // Spirit link chains
            updateSkilledAntsPanel(); // Update skill cooldowns in UI

            // Check for game over
            checkGameOver();
        }

        // Food no longer spoils - just update food items
        function updateFoodTimers() {
            for (const food of foodItems) {
                food.update();
            }
        }

        function drawHint() {
            if (!showHint) return;

            ctx.save();
            ctx.fillStyle = 'rgba(240, 235, 224, 0.5)';
            ctx.font = 'italic 16px "Playfair Display", Georgia, serif';
            ctx.textAlign = 'center';
            ctx.fillText('click to drop food', width / 2, height * 0.18);

            ctx.strokeStyle = 'rgba(240, 235, 224, 0.3)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(width / 2, height * 0.21);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.moveTo(width / 2 - 6, height * 0.26);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.lineTo(width / 2 + 6, height * 0.26);
            ctx.stroke();
            ctx.restore();
        }

        function render() {
            drawGround();
            drawSpots();
            drawPheromones();
            if (gameStarted) drawNest();  // Only draw nest after hive is placed
            drawFood();
            drawTrailblazerBeacons();  // Trailblazer skill beacons
            // Draw predators FIRST so ants appear on top during combat
            for (const spider of spiderPredators) spider.draw();
            for (const beetle of beetlePredators) beetle.draw();
            drawAnts();
            drawAmbientParticles();
            drawSpawnNotifications();
            drawRareFoodNotifications();  // Golden apple spawn notifications
            drawCombatEffects();  // Combat clash animations
            drawDeathEffects();   // Death particle animations
            drawLevelUpEffects(); // Level up visual effects
            drawPounceEffects();  // Pounce skill effects
            drawGoldBurstEffects(); // Gold Rush skill effects
            drawShockwaveEffects(); // Shockwave skill effects
            drawRallyCryEffects(); // Rally Cry skill effects
            drawVampireBiteEffects(); // Vampire Bite skill effects
            drawBerserkerEffects(); // Berserker skill effects
            drawSecondWindEffects(); // Second Wind phoenix effect
            drawScavengerEffects(); // Scavenger XP sparkles
            drawHeavyLifterEffects(); // Heavy Lifter strength aura
            drawPathfinderEffects(); // Pathfinder compass pulse
            drawMomentumEffects(); // Momentum speed streaks
            drawBloodlustEffects(); // Bloodlust crimson aura
            drawAdrenalineEffects(); // Adrenaline lightning surge
            drawDecoyEffects(); // Decoy spawn effect
            drawDecoyAnts(); // Decoy ghost ants
            drawLastStandEffects(); // Last Stand skull aura
            drawLuckyEffects(); // Lucky clover shimmer
            drawPackHunterEffects(); // Pack Hunter wolf howl
            drawDashEffects(); // Dash teleport effect
            drawEarthquakeEffects(); // Earthquake ground slam
            drawChainLightningEffects(); // Chain lightning arcs
            drawVoidRiftEffects(); // Void rift portals
            drawFireBreathEffects(); // Fire breath cones
            drawIceNovaEffects(); // Ice nova freeze
            drawShadowStepEffects(); // Shadow step stealth
            drawWarCryEffects(); // War cry terror
            drawHealingAuraEffects(); // Healing aura
            drawMeteorStrikeEffects(); // Meteor strike
            drawMirrorImageEffects(); // Mirror image clones
            drawMirrorDecoys(); // Mirror decoy entities with HP
            drawBlinkEffects(); // Blink teleport
            drawSpiritLinkEffects(); // Spirit link chains
            drawFloatingTexts();  // Reward and damage floating text
            drawHint();
            drawSelectionRect(); // Draw selection rectangle on top
        }

        function gameLoop() {
            update();
            render();
            updateUI();
            updateUpgradeCountdown();
            updateCycleTimerUI();  // Update cycle timer display based on upgrade time
            requestAnimationFrame(gameLoop);
        }

        function resize() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);

            initPheromoneGrid();
            CONFIG.nestX = width * 0.5;
            CONFIG.nestY = height * 0.55;

            generateForestElements();
            generateGrass();
            initAmbientParticles();
        }

        function initPredators() {
            // Generate random spots first
            generateMapSpots();

            // Update CONFIG.predators positions from the spots
            for (const spot of predatorSpots) {
                if (spot.type === 'spider') {
                    CONFIG.predators.spider.x = spot.x;
                    CONFIG.predators.spider.y = spot.y;
                } else if (spot.type === 'beetle') {
                    CONFIG.predators.beetle.x = spot.x;
                    CONFIG.predators.beetle.y = spot.y;
                }
            }

            // Don't spawn predators at game start - they spawn from dens over time
            spiderPredators = [];
            beetlePredators = [];
        }

        // Initialize
        resize();
        // Don't call initAnts() here - ants will be spawned when player places the hive
        ants = [];  // Start with empty ant array
        initPredators();

        // Track initial ants as spawned (will be updated when hive is placed)
        totalAntsSpawned = 0;

        // Initialize food cooldown system
        initFoodCooldownOverlays();
        setInterval(updateFoodCooldowns, 100);

        gameLoop();

        window.addEventListener('resize', resize);

        // Check if running on localhost - if so, hide WIP overlay and show game
        // On public site, show WIP overlay and hide game
        (function checkAccess() {
            const hostname = window.location.hostname;
            const isLocal = hostname === 'localhost' ||
                           hostname === '127.0.0.1' ||
                           hostname === '' ||  // file:// protocol
                           hostname.endsWith('.local');

            const wipOverlay = document.getElementById('wip-overlay');
            const canvas = document.getElementById('canvas');
            const uiElements = document.querySelectorAll('.ui-overlay, .upgrade-modal, .game-over-modal, .harvest-modal, .hive-placement-overlay');

            if (isLocal) {
                // On localhost - hide WIP, show game
                wipOverlay.classList.add('hidden');
            } else {
                // On public site - show WIP, hide game
                wipOverlay.classList.remove('hidden');
                canvas.style.display = 'none';
                uiElements.forEach(el => el.style.display = 'none');
            }
        })();
    </script>
</body>
</html>
