<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ant Colony - hafnr</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%230f0f0f'/><text x='4' y='26' font-family='Arial' font-size='26' font-weight='bold' fill='%23fff'>h</text><circle cx='26' cy='24' r='3' fill='%23fff'/></svg>">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7723236991764317"
        crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #1a2418;
            --surface: rgba(28, 32, 26, 0.92);
            --border: rgba(100, 120, 80, 0.3);
            --text: #f0ebe0;
            --text-muted: #a8b0a0;
            --accent: #b8d468;
            --accent-glow: rgba(184, 212, 104, 0.15);
            --gold: #f4d03f;
        }

        body {
            background: var(--bg);
            min-height: 100vh;
            min-height: 100dvh;
            font-family: 'Playfair Display', Georgia, serif;
            color: var(--text);
            overflow: hidden;
            touch-action: none;
        }

        /* Work in Progress Overlay */
        .wip-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
        }

        .wip-overlay.hidden {
            display: none;
        }

        .wip-icon {
            font-size: 64px;
            animation: wip-bounce 2s ease-in-out infinite;
        }

        @keyframes wip-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .wip-title {
            font-family: 'Playfair Display', serif;
            font-size: 32px;
            color: var(--accent);
            text-align: center;
        }

        .wip-message {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            text-align: center;
            max-width: 400px;
            line-height: 1.6;
        }

        .wip-back-link {
            margin-top: 16px;
            font-family: 'DM Mono', monospace;
            font-size: 13px;
            color: var(--text-muted);
            text-decoration: none;
            padding: 10px 20px;
            border: 1px solid var(--border);
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .wip-back-link:hover {
            color: var(--accent);
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            cursor: crosshair;
            z-index: 1;
        }

        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 13px;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            backdrop-filter: blur(16px);
            transition: all 0.25s ease;
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.5px;
        }

        .back-link:hover {
            color: var(--text);
            background: rgba(35, 40, 32, 0.95);
            border-color: rgba(120, 160, 80, 0.4);
            transform: translateX(-2px);
        }

        .info-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 12px;
            padding: 20px 22px;
            font-size: 14px;
            color: var(--text-muted);
            max-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .info-panel h3 {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: var(--accent);
            margin-bottom: 16px;
            letter-spacing: 3px;
            text-transform: uppercase;
            padding-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .info-panel h3 .collapse-icon {
            font-size: 14px;
            transition: transform 0.3s ease;
        }

        .info-panel.collapsed h3 .collapse-icon {
            transform: rotate(180deg);
        }

        .info-panel.collapsed .panel-content {
            display: none;
        }

        .info-panel h3:hover {
            color: var(--text);
            border-bottom: 1px solid var(--border);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .stat-label {
            opacity: 0.7;
        }

        .stat-value {
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-weight: 500;
            font-size: 14px;
        }

        .stat-value.coins {
            color: var(--gold);
        }

        .ant-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 12px;
            font-family: 'DM Mono', monospace;
            font-size: 11px;
        }

        .ant-type {
            padding: 2px 8px;
            border-radius: 4px;
            opacity: 0.9;
        }

        .ant-type.worker {
            background: rgba(70, 50, 35, 0.5);
            color: #a08060;
        }

        .ant-type.soldier {
            background: rgba(180, 50, 50, 0.5);
            color: #ff9080;
        }

        .ant-type.scout {
            background: rgba(200, 160, 50, 0.5);
            color: #ffe080;
        }

        .ant-type.carrier {
            background: rgba(70, 90, 120, 0.5);
            color: #a0c0e0;
        }

        .ant-type.queen {
            background: rgba(130, 60, 150, 0.5);
            color: #e0a0f0;
        }

        /* Character Card Styles - Tactical Dossier Theme */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&display=swap');

        .character-card {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 420px;
            background: linear-gradient(165deg, rgba(12, 14, 18, 0.97), rgba(8, 10, 12, 0.99));
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 4px;
            box-shadow:
                0 0 40px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(0, 255, 136, 0.1),
                inset 0 0 60px rgba(0, 255, 136, 0.02);
            z-index: 1000;
            overflow: visible;
            animation: cardAppear 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            font-family: 'Share Tech Mono', monospace;
        }

        .character-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 136, 0.015) 2px,
                    rgba(0, 255, 136, 0.015) 4px
                );
            pointer-events: none;
            z-index: 1;
        }

        .character-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 40%,
                rgba(0, 255, 136, 0.03) 50%,
                transparent 60%
            );
            animation: holographicSweep 4s linear infinite;
            pointer-events: none;
            z-index: 2;
        }

        @keyframes holographicSweep {
            from { transform: translateX(-30%) translateY(-30%) rotate(0deg); }
            to { transform: translateX(30%) translateY(30%) rotate(0deg); }
        }

        @keyframes cardAppear {
            from {
                opacity: 0;
                transform: translateX(30px) scale(0.95);
                filter: blur(10px);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
                filter: blur(0);
            }
        }

        .character-card.hidden {
            display: none;
        }

        .card-header {
            position: relative;
            display: flex;
            align-items: center;
            padding: 14px 16px;
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.08), transparent);
            border-bottom: 1px solid rgba(0, 255, 136, 0.15);
            gap: 12px;
            z-index: 3;
        }

        .card-header::before {
            content: 'UNIT DOSSIER';
            position: absolute;
            top: 4px;
            right: 40px;
            font-size: 8px;
            color: rgba(0, 255, 136, 0.4);
            letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif;
        }

        .card-icon {
            font-size: 48px;
            filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.4));
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.4)); }
            50% { filter: drop-shadow(0 0 12px rgba(0, 255, 136, 0.6)); }
        }

        .card-title-section {
            flex: 1;
        }

        .card-title-section h3 {
            margin: 0;
            font-size: 26px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            letter-spacing: 1px;
        }

        .card-subtitle {
            font-size: 13px;
            color: rgba(0, 255, 136, 0.6);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-top: 4px;
        }

        .card-close {
            background: rgba(255, 60, 60, 0.1);
            border: 1px solid rgba(255, 60, 60, 0.3);
            color: #ff4444;
            font-size: 18px;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 2px;
            transition: all 0.2s;
            font-family: 'Orbitron', sans-serif;
            z-index: 10;
        }

        .card-close:hover {
            background: rgba(255, 60, 60, 0.2);
            border-color: rgba(255, 60, 60, 0.6);
            box-shadow: 0 0 15px rgba(255, 60, 60, 0.3);
        }

        .card-body {
            padding: 20px 24px;
            position: relative;
            z-index: 3;
        }

        .card-stats {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 255, 136, 0.1);
            border-radius: 2px;
            padding: 12px 14px;
            position: relative;
            cursor: help;
            transition: all 0.2s;
        }

        .stat-item:hover {
            border-color: rgba(0, 255, 136, 0.4);
            background: rgba(0, 255, 136, 0.05);
        }

        .stat-item:hover .stat-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .stat-item .stat-name {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.7);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }

        .stat-item .stat-val {
            font-size: 18px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
        }

        .stat-bar-container {
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .stat-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
        }

        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: barShine 2s ease-in-out infinite;
        }

        @keyframes barShine {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar.good { background: linear-gradient(90deg, #00ff88, #00cc6a); box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
        .stat-bar.exceptional { background: linear-gradient(90deg, #a78bfa, #8b5cf6); box-shadow: 0 0 10px rgba(167, 139, 250, 0.5); }
        .stat-bar.legendary { background: linear-gradient(90deg, #ffd700, #ffaa00); box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        .stat-bar.neutral, .stat-bar.default { background: linear-gradient(90deg, #4a9eff, #2d7dd2); box-shadow: 0 0 10px rgba(74, 158, 255, 0.3); }
        .stat-bar.weak { background: linear-gradient(90deg, #9ca3af, #6b7280); }
        .stat-bar.poor { background: linear-gradient(90deg, #ef4444, #dc2626); box-shadow: 0 0 10px rgba(239, 68, 68, 0.3); }

        /* Starting stat marker - shows where stat began */
        .stat-start-marker {
            position: absolute;
            top: -2px;
            bottom: -2px;
            width: 2px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1px;
            z-index: 2;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.6);
        }
        .stat-start-marker::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -2px;
            width: 6px;
            height: 3px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1px;
        }

        .stat-item .stat-val.good { color: #00ff88; }
        .stat-item .stat-val.exceptional { color: #a78bfa; }
        .stat-item .stat-val.legendary { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.6); }
        .stat-item .stat-val.weak { color: #9ca3af; }
        .stat-item .stat-val.poor { color: #ef4444; }

        .stat-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(8px);
            background: rgba(8, 12, 16, 0.98);
            border: 1px solid rgba(0, 255, 136, 0.4);
            border-radius: 4px;
            padding: 12px 14px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.95);
            width: 220px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.2s ease-out;
            z-index: 1000;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 255, 136, 0.15);
            text-align: center;
        }

        .stat-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: rgba(0, 255, 136, 0.4);
        }

        /* HP tooltip dynamic styling */
        .stat-tooltip .hp-current {
            font-weight: 700;
            color: #00ff88;
            font-size: 14px;
        }

        .stat-tooltip .hp-max {
            font-weight: 700;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        .stat-tooltip .hp-status {
            display: block;
            margin-top: 4px;
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-tooltip .hp-status.good { color: #00ff88; }
        .stat-tooltip .hp-status.weak { color: #f59e0b; }
        .stat-tooltip .hp-status.bad { color: #ef4444; }

        .stat-tooltip small {
            display: block;
            margin-top: 6px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 10px;
        }

        .card-exp-section {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.15);
            border-radius: 2px;
            padding: 14px 16px;
            margin-bottom: 18px;
        }

        .exp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .exp-label {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.6);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }

        .exp-value {
            font-size: 24px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
        }

        .exp-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
        }

        .exp-detail {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .exp-detail .count {
            color: #00ff88;
            font-weight: 600;
        }

        .card-description {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            margin-bottom: 18px;
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid rgba(0, 255, 136, 0.3);
        }

        .card-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .trait-tag {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 3px;
            padding: 6px 14px;
            font-size: 11px;
            color: rgba(0, 255, 136, 0.8);
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
            position: relative;
            cursor: help;
        }

        .trait-tag:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .trait-tag .trait-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 10, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.4);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            font-family: 'Share Tech Mono', monospace;
            text-transform: none;
            letter-spacing: 0;
            color: #c0c0c0;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .trait-tag .trait-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 255, 136, 0.4);
        }

        .trait-tag:hover .trait-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .trait-tag.positive { border-color: rgba(125, 206, 160, 0.4); color: #7dcea0; }
        .trait-tag.negative { border-color: rgba(239, 68, 68, 0.4); color: #ef4444; }
        .trait-tag.special { border-color: rgba(255, 215, 0, 0.4); color: #ffd700; }
        .trait-tag.legendary {
            border-color: rgba(255, 215, 0, 0.6);
            color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 170, 0, 0.1));
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
            animation: legendaryPulse 2s ease-in-out infinite;
        }
        .trait-tag.exceptional {
            border-color: rgba(167, 139, 250, 0.5);
            color: #a78bfa;
            background: rgba(167, 139, 250, 0.1);
        }
        .trait-tag.good { border-color: rgba(0, 255, 136, 0.4); color: #00ff88; }
        .trait-tag.weak { border-color: rgba(156, 163, 175, 0.3); color: #9ca3af; }
        .trait-tag.poor { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .trait-tag.skill {
            border-color: rgba(59, 130, 246, 0.6);
            color: #60a5fa;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.1));
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
            animation: skillGlow 2.5s ease-in-out infinite;
        }

        @keyframes skillGlow {
            0%, 100% { box-shadow: 0 0 8px rgba(59, 130, 246, 0.3); }
            50% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
        }

        /* Level progress bar */
        .level-display {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .level-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
            letter-spacing: 2px;
        }

        .xp-total {
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            color: rgba(0, 255, 136, 0.7);
            background: rgba(0, 255, 136, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .level-bar-container {
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .level-bar {
            height: 100%;
            background: linear-gradient(90deg, #006633, #00aa55, #00ff88);
            transition: width 0.5s ease;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.4);
        }

        .level-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 100%);
            animation: levelShine 2s ease-in-out infinite;
        }

        .level-bar.max {
            background: linear-gradient(90deg, #cc8800, #ffd700, #ffee88, #ffd700, #cc8800);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .level-bar.max::after {
            animation: levelShineGold 1.5s ease-in-out infinite;
        }

        @keyframes levelShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        @keyframes levelShineGold {
            0% { transform: translateX(-100%); opacity: 0.5; }
            100% { transform: translateX(200%); opacity: 0.8; }
        }

        .level-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-family: 'Share Tech Mono', monospace;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9), 0 0 6px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            letter-spacing: 0.5px;
        }

        @keyframes legendaryPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        }

        .card-footer {
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(0, 255, 136, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 9px;
            color: rgba(0, 255, 136, 0.4);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            z-index: 3;
            position: relative;
        }

        .card-id {
            opacity: 0.6;
        }

        .card-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00ff88;
            animation: statusBlink 1.5s ease-in-out infinite;
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .instructions {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
            line-height: 1.7;
            font-size: 12px;
            font-style: italic;
            color: rgba(168, 176, 160, 0.75);
        }

        .bottom-ui {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .food-selector, .ant-selector {
            display: flex;
            gap: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 14px;
            padding: 12px 18px;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        /* Food Levels Panel (read-only display) */
        .food-levels-panel {
            display: flex;
            gap: 6px;
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 12px;
            padding: 10px 16px;
            align-items: center;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
        }

        .food-levels-label {
            color: var(--text-muted);
            font-size: 10px;
            margin-right: 8px;
            font-family: 'DM Mono', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.6;
        }

        .food-level-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 6px 8px;
            background: rgba(50, 60, 45, 0.3);
            border-radius: 8px;
            min-width: 40px;
        }

        .food-level-item .emoji {
            font-size: 18px;
        }

        .food-level-item .food-level {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--accent);
            font-weight: 600;
        }

        .food-level-item .food-level.max-level {
            color: var(--gold);
            text-shadow: 0 0 8px rgba(244, 208, 63, 0.6);
        }

        .food-label, .ant-label {
            color: var(--text-muted);
            font-size: 11px;
            margin-right: 10px;
            font-family: 'DM Mono', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.6;
            min-width: 45px;
        }

        .food-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(50, 60, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .food-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .food-btn:hover::before {
            opacity: 1;
        }

        .food-btn:hover {
            background: rgba(70, 80, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .food-btn.active {
            border-color: var(--accent);
            background: rgba(80, 100, 60, 0.45);
            box-shadow: 0 0 24px var(--accent-glow), inset 0 0 20px var(--accent-glow);
        }

        .food-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Food cooldown overlay styles */
        .food-btn.on-cooldown {
            pointer-events: none;
            cursor: not-allowed;
        }

        .food-btn .cooldown-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .food-btn.on-cooldown .cooldown-overlay {
            opacity: 1;
        }

        .food-btn .cooldown-timer {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .food-btn .cooldown-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--gold), var(--accent));
            border-radius: 0 0 8px 8px;
            transition: width 0.1s linear;
        }

        .food-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        .food-btn span.cost, .ant-btn span.cost {
            font-size: 9px;
            font-family: 'DM Mono', monospace;
            color: var(--gold);
            opacity: 0.9;
        }

        .ant-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(60, 50, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .ant-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .ant-btn:hover::before {
            opacity: 1;
        }

        .ant-btn:hover {
            background: rgba(80, 70, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .ant-btn:active {
            transform: translateY(-1px) scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .ant-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ant-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        @media (max-width: 600px) {
            .info-panel {
                max-width: 180px;
                padding: 14px 16px;
            }

            .ui-overlay {
                top: 12px;
                left: 12px;
            }

            .bottom-ui {
                bottom: 12px;
                gap: 6px;
            }

            .food-selector, .ant-selector {
                padding: 8px 12px;
                gap: 6px;
            }

            .food-btn, .ant-btn {
                width: 42px;
                height: 42px;
            }

            .food-btn span.emoji, .ant-btn span.emoji {
                font-size: 16px;
            }

            .food-btn span.cost, .ant-btn span.cost {
                font-size: 8px;
            }

            .food-label, .ant-label {
                display: none;
            }
        }

        /* Hive Placement Overlay */
        .hive-placement-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            cursor: none;
            transition: opacity 0.4s ease;
        }

        /* Hive cursor that follows mouse during placement */
        .hive-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 1600;
            font-size: 48px;
            transform: translate(-50%, -50%);
            opacity: 0.85;
            filter: drop-shadow(0 0 12px rgba(244, 208, 63, 0.8)) drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
            transition: transform 0.1s ease-out, opacity 0.2s ease;
        }

        .hive-cursor.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .hive-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 2px dashed rgba(244, 208, 63, 0.5);
            border-radius: 50%;
            animation: hiveCursorPulse 1.5s ease-in-out infinite;
        }

        @keyframes hiveCursorPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.15); opacity: 0.8; }
        }

        .hive-placement-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .hive-placement-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(244, 208, 63, 0.6);
            letter-spacing: 3px;
            margin-bottom: 16px;
            animation: hivePulse 2s ease-in-out infinite;
        }

        .hive-placement-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            letter-spacing: 2px;
        }

        @keyframes hivePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }

        /* Game Over Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .game-over-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .game-over-content {
            background: linear-gradient(165deg, rgba(20, 24, 18, 0.98), rgba(12, 14, 10, 0.99));
            border: 2px solid rgba(180, 60, 60, 0.5);
            border-radius: 16px;
            padding: 48px 64px;
            text-align: center;
            box-shadow: 0 0 60px rgba(180, 60, 60, 0.3), inset 0 0 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .game-over-modal.visible .game-over-content {
            transform: scale(1);
        }

        .game-over-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 42px;
            color: #ff6b6b;
            margin-bottom: 12px;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            letter-spacing: 4px;
        }

        .game-over-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 32px;
            letter-spacing: 2px;
        }

        .survival-time {
            font-family: 'Orbitron', sans-serif;
            font-size: 64px;
            color: var(--gold);
            text-shadow: 0 0 30px rgba(244, 208, 63, 0.6);
            margin-bottom: 8px;
        }

        .survival-label {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: var(--text-muted);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 32px;
        }

        .game-stats {
            display: flex;
            gap: 32px;
            justify-content: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .game-stat {
            text-align: center;
        }

        .game-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--accent);
        }

        .game-stat-label {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-top: 4px;
        }

        .restart-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            padding: 16px 48px;
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.2), rgba(184, 212, 104, 0.1));
            border: 2px solid var(--accent);
            color: var(--accent);
            border-radius: 8px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.3), rgba(184, 212, 104, 0.2));
            box-shadow: 0 0 30px rgba(184, 212, 104, 0.3);
            transform: scale(1.05);
        }

        /* Timer Display */
        .timer-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: var(--gold);
            text-align: center;
            padding: 12px;
            margin-bottom: 12px;
            background: rgba(244, 208, 63, 0.1);
            border: 1px solid rgba(244, 208, 63, 0.3);
            border-radius: 8px;
            letter-spacing: 2px;
        }

        .timer-label {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: var(--text-muted);
            letter-spacing: 2px;
            text-transform: uppercase;
            display: block;
            margin-bottom: 4px;
        }

        /* Danger warning pulse */
        .danger-warning {
            animation: dangerPulse 1s ease-in-out infinite;
        }

        @keyframes dangerPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 60, 60, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 60, 60, 0.6); }
        }

        /* Upgrade Selection Panel - TFT-Style Centered Modal */
        .upgrade-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(180deg, rgba(18, 22, 16, 0.97) 0%, rgba(12, 15, 10, 0.99) 100%);
            border: 2px solid rgba(184, 212, 104, 0.35);
            border-radius: 20px;
            padding: 28px 36px 32px;
            z-index: 2000;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow:
                0 0 80px rgba(0, 0, 0, 0.7),
                0 0 40px rgba(184, 212, 104, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            min-width: 720px;
            max-width: 880px;
            opacity: 0;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .upgrade-modal::before {
            content: '';
            position: absolute;
            top: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(184, 212, 104, 0.6), transparent);
            border-radius: 2px;
        }

        .upgrade-modal.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        .upgrade-modal.minimized {
            transform: translate(-50%, 0) scale(1);
            top: 20px;
            opacity: 1;
            pointer-events: auto;
            padding: 12px 20px;
            min-width: auto;
            max-width: none;
            width: auto;
            border-radius: 10px;
        }

        .upgrade-modal.minimized .upgrade-header,
        .upgrade-modal.minimized .upgrade-subtitle,
        .upgrade-modal.minimized .upgrade-options,
        .upgrade-modal.minimized .upgrade-count {
            display: none;
        }

        .upgrade-modal.minimized .upgrade-timer {
            margin-bottom: 0;
            padding: 4px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .upgrade-modal.minimized .upgrade-timer-bar {
            width: 100px;
            margin-top: 0;
        }

        .upgrade-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .upgrade-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(244, 208, 63, 0.5), 0 2px 4px rgba(0, 0, 0, 0.4);
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .upgrade-hide-btn {
            background: rgba(184, 212, 104, 0.15);
            border: 1px solid rgba(184, 212, 104, 0.35);
            color: var(--accent);
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .upgrade-hide-btn:hover {
            background: rgba(184, 212, 104, 0.25);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(184, 212, 104, 0.3);
        }

        .upgrade-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 20px;
            letter-spacing: 1.5px;
            text-align: center;
            opacity: 0.8;
        }

        .upgrade-timer {
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            color: var(--gold);
            text-align: center;
            margin-bottom: 20px;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(244, 208, 63, 0.12) 0%, rgba(244, 208, 63, 0.06) 100%);
            border-radius: 10px;
            border: 1px solid rgba(244, 208, 63, 0.25);
            box-shadow: inset 0 1px 0 rgba(244, 208, 63, 0.1);
        }

        .upgrade-timer-bar {
            height: 4px;
            background: rgba(244, 208, 63, 0.15);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .upgrade-timer-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), rgba(244, 230, 100, 1));
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(244, 208, 63, 0.6);
        }

        .upgrade-expand-btn {
            display: none;
            background: rgba(244, 208, 63, 0.15);
            border: 1px solid rgba(244, 208, 63, 0.35);
            color: var(--gold);
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            align-items: center;
            justify-content: center;
            transition: all 0.25s cubic-bezier(0.23, 1, 0.32, 1);
            margin-left: auto;
        }

        .upgrade-expand-btn:hover {
            background: rgba(244, 208, 63, 0.25);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(244, 208, 63, 0.3);
        }

        .upgrade-modal.minimized .upgrade-expand-btn {
            display: flex;
        }

        /* TFT-Style Horizontal Card Layout */
        .upgrade-options {
            display: flex;
            flex-direction: row;
            gap: 16px;
            justify-content: center;
            padding: 8px 0;
        }

        /* TFT-Style Upgrade Card */
        .upgrade-card {
            background: linear-gradient(165deg, rgba(35, 42, 32, 0.95) 0%, rgba(22, 26, 20, 0.98) 100%);
            border: 2px solid rgba(184, 212, 104, 0.2);
            border-radius: 16px;
            padding: 24px 20px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 180px;
            max-width: 220px;
            min-height: 200px;
        }

        .upgrade-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .upgrade-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center top, rgba(184, 212, 104, 0.08) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .upgrade-card:hover {
            border-color: var(--accent);
            transform: translateY(-8px) scale(1.03);
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(184, 212, 104, 0.2),
                0 0 60px rgba(184, 212, 104, 0.1);
        }

        .upgrade-card:hover::before {
            opacity: 1;
        }

        .upgrade-card:hover::after {
            opacity: 1;
        }

        .upgrade-card:active {
            transform: translateY(-4px) scale(1.01);
        }

        /* Card Emoji/Icon */
        .upgrade-emoji {
            font-size: 48px;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.4));
            flex-shrink: 0;
            transition: transform 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            margin-top: 8px;
        }

        .upgrade-card:hover .upgrade-emoji {
            transform: scale(1.15);
        }

        /* Card Info Container */
        .upgrade-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Card Name */
        .upgrade-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--accent);
            letter-spacing: 0.5px;
            text-shadow: 0 0 10px rgba(184, 212, 104, 0.3);
            line-height: 1.3;
        }

        /* Card Description */
        .upgrade-desc {
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.5;
            opacity: 0.85;
        }

        /* Stack Count Badge */
        .upgrade-stacks {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, var(--accent), rgba(160, 190, 90, 1));
            color: var(--bg);
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(184, 212, 104, 0.4);
        }

        /* Upgrade count display in UI */
        .upgrade-count {
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            color: var(--accent);
            text-align: center;
            padding: 10px 16px;
            margin-top: 16px;
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.1) 0%, rgba(184, 212, 104, 0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(184, 212, 104, 0.2);
        }

        /* Upgrade card wrapper for premium layout */
        .upgrade-card-wrapper {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex: 1;
            min-width: 180px;
            max-width: 220px;
        }

        /* Category label above upgrade card */
        .upgrade-category {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            letter-spacing: 2px;
            text-align: center;
            padding: 4px 12px;
            margin-bottom: 6px;
            border: 1px solid;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0.9;
        }

        /* When wrapper has premium, adjust card border radius */
        .upgrade-card-wrapper:has(.upgrade-premium) .upgrade-card {
            border-radius: 16px 16px 0 0;
            border-bottom: none;
        }

        /* Premium upgrade option - connected to card */
        .upgrade-premium {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(165deg, rgba(244, 208, 63, 0.12) 0%, rgba(244, 180, 63, 0.08) 100%);
            border: 2px solid rgba(244, 208, 63, 0.35);
            border-top: 1px dashed rgba(244, 208, 63, 0.4);
            border-radius: 0 0 16px 16px;
            padding: 12px 14px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.23, 1, 0.32, 1);
            margin-top: 0;
            position: relative;
        }

        /* Subtle connector line between card and premium */
        .upgrade-premium::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(244, 208, 63, 0.5), transparent);
        }

        .upgrade-premium:hover:not(.disabled) {
            background: linear-gradient(165deg, rgba(244, 208, 63, 0.2) 0%, rgba(244, 180, 63, 0.15) 100%);
            border-color: var(--gold);
            border-top-color: rgba(244, 208, 63, 0.6);
            box-shadow: 0 4px 15px rgba(244, 208, 63, 0.2);
        }

        /* Hover on wrapper lifts both elements together */
        .upgrade-card-wrapper:hover .upgrade-premium:not(.disabled) {
            border-top-color: rgba(244, 208, 63, 0.5);
        }

        .upgrade-premium.disabled {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.6);
        }

        .premium-cost {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--gold);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(244, 208, 63, 0.5);
            flex-shrink: 0;
        }

        .premium-desc {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: var(--gold);
            opacity: 0.9;
            text-align: center;
        }

        /* Food Level Display */
        .food-level {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: var(--accent);
            display: block;
            margin-top: 2px;
        }

        .food-btn .food-level.max-level {
            color: var(--gold);
            text-shadow: 0 0 6px rgba(244, 208, 63, 0.6);
        }

        /* Cycle Timer Display */
        .cycle-timer {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: 'DM Mono', monospace;
            font-size: 11px;
        }

        .cycle-label {
            color: var(--text-muted);
        }

        .cycle-countdown {
            color: var(--accent);
            font-weight: 500;
            min-width: 30px;
        }

        .cycle-bar {
            width: 60px;
            height: 4px;
            background: rgba(184, 212, 104, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .cycle-bar-fill {
            height: 100%;
            background: var(--accent);
            width: 100%;
            transition: width 0.5s linear;
        }

        /* Next Ant Preview */
        .next-ant-preview {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0, 255, 136, 0.08);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 6px;
            font-family: 'DM Mono', monospace;
            font-size: 10px;
        }

        .preview-title {
            color: rgba(0, 255, 136, 0.7);
        }

        .preview-stats {
            color: #00ff88;
        }

        /* Harvest Summary Modal */
        .harvest-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(180deg, rgba(12, 18, 14, 0.98) 0%, rgba(8, 12, 10, 0.99) 100%);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-radius: 16px;
            padding: 28px 36px;
            z-index: 3000;
            min-width: 400px;
            max-width: 500px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow:
                0 0 60px rgba(0, 0, 0, 0.8),
                0 0 30px rgba(0, 255, 136, 0.15);
            backdrop-filter: blur(10px);
        }

        .harvest-modal.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        .harvest-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .harvest-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            letter-spacing: 2px;
            display: block;
            margin-bottom: 8px;
        }

        .harvest-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: rgba(0, 255, 136, 0.6);
        }

        .harvest-body {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 24px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 136, 0.15);
        }

        .harvest-deliveries {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            max-width: 180px;
        }

        .harvest-food-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 6px rgba(0, 255, 136, 0.4));
            animation: harvestBounce 0.5s ease-out;
        }

        @keyframes harvestBounce {
            0% { transform: scale(0) rotate(-20deg); }
            60% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .harvest-arrow {
            font-size: 32px;
            color: var(--gold);
            animation: arrowPulse 1s ease-in-out infinite;
        }

        @keyframes arrowPulse {
            0%, 100% { opacity: 0.6; transform: translateX(0); }
            50% { opacity: 1; transform: translateX(5px); }
        }

        .harvest-ant {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .harvest-ant-icon {
            font-size: 48px;
            filter: drop-shadow(0 0 12px rgba(0, 255, 136, 0.6));
            animation: antHatch 0.8s ease-out 0.3s both;
        }

        @keyframes antHatch {
            0% { transform: scale(0) rotate(-30deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .harvest-ant-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #00ff88;
            letter-spacing: 1px;
        }

        .harvest-stats {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
        }

        .harvest-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 10px 16px;
            background: rgba(0, 255, 136, 0.08);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            min-width: 60px;
        }

        .harvest-stat-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: rgba(0, 255, 136, 0.7);
            letter-spacing: 1px;
        }

        .harvest-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: #00ff88;
            font-weight: 700;
        }

        .harvest-stat-value.has-bonus {
            color: var(--gold);
            text-shadow: 0 0 8px rgba(244, 208, 63, 0.5);
        }

        .harvest-abilities {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .harvest-ability {
            padding: 8px 14px;
            background: linear-gradient(165deg, rgba(244, 208, 63, 0.15) 0%, rgba(244, 180, 63, 0.1) 100%);
            border: 1px solid rgba(244, 208, 63, 0.4);
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--gold);
            letter-spacing: 1px;
            animation: abilityGlow 1.5s ease-in-out infinite;
        }

        @keyframes abilityGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(244, 208, 63, 0.2); }
            50% { box-shadow: 0 0 20px rgba(244, 208, 63, 0.4); }
        }

        .harvest-continue-btn {
            display: block;
            width: 100%;
            padding: 14px 24px;
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 200, 100, 0.15) 100%);
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 10px;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .harvest-continue-btn:hover {
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.3) 0%, rgba(0, 200, 100, 0.25) 100%);
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            transform: translateY(-2px);
        }

        /* No deliveries state */
        .harvest-no-deliveries {
            text-align: center;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            padding: 20px;
        }
    </style>
</head>
<body>
    <!-- Work in Progress Overlay - shown on public site, hidden on localhost -->
    <div class="wip-overlay" id="wip-overlay">
        <div class="wip-icon"></div>
        <h1 class="wip-title">Work in Progress</h1>
        <p class="wip-message">
            The ant colony simulation is currently under development.
            Check back soon for the full experience!
        </p>
        <a href="/" class="wip-back-link"> back to hafnr</a>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-overlay">
        <a href="/" class="back-link">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            back
        </a>
        <div class="info-panel" id="info-panel">
            <h3 onclick="toggleInfoPanel()">Ant Colony <span class="collapse-icon"></span></h3>
            <div class="panel-content">
                <div class="timer-display" id="timer-display">
                    <span class="timer-label">Survival Time</span>
                    <span id="survival-timer">0:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Coins</span>
                    <span class="stat-value coins" id="coins">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Population</span>
                    <span class="stat-value" id="ant-count">0</span>
                </div>
                <div class="ant-breakdown">
                    <span class="ant-type worker" id="worker-count" title="Workers">0</span>
                    <span class="ant-type soldier" id="soldier-count" title="Soldiers">0</span>
                    <span class="ant-type scout" id="scout-count" title="Scouts">0</span>
                    <span class="ant-type carrier" id="carrier-count" title="Carriers">0</span>
                    <span class="ant-type queen" id="queen-count" title="Queens">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Food stored</span>
                    <span class="stat-value" id="food-collected">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Character Card Modal -->
    <div id="character-card" class="character-card hidden">
        <div class="card-header">
            <span class="card-icon" id="card-icon"></span>
            <div class="card-title-section">
                <h3 id="card-title">Worker</h3>
                <span class="card-subtitle" id="card-subtitle">Ant</span>
            </div>
            <button class="card-close" onclick="closeCharacterCard()"></button>
        </div>
        <div class="card-body">
            <div class="card-exp-section" id="card-exp-section">
                <div class="exp-header">
                    <span class="exp-label">Experience</span>
                    <span class="exp-value" id="exp-value">0</span>
                </div>
                <div class="exp-details" id="exp-details"></div>
            </div>
            <div class="card-stats" id="card-stats"></div>
            <div class="card-description" id="card-description"></div>
            <div class="card-traits" id="card-traits"></div>
        </div>
        <div class="card-footer">
            <span class="card-id" id="card-id">ID: #000</span>
            <div class="card-status">
                <span class="status-dot"></span>
                <span>ACTIVE</span>
            </div>
        </div>
    </div>

    <div class="bottom-ui">
        <!-- Food Levels Display -->
        <div class="food-levels-panel">
            <span class="food-levels-label">Food Levels</span>
            <div class="food-level-item" title="Sugar - +HP per unit. Lv.10: Gold Hunter">
                <span class="emoji"></span>
                <span class="food-level" id="sugar-level">1</span>
            </div>
            <div class="food-level-item" title="Protein - +ATK per unit. Lv.10: Lifesteal">
                <span class="emoji"></span>
                <span class="food-level" id="protein-level">1</span>
            </div>
            <div class="food-level-item" title="Fruit - +Carry per unit. Lv.10: Fresh Keeper">
                <span class="emoji"></span>
                <span class="food-level" id="fruit-level">1</span>
            </div>
            <div class="food-level-item" title="Feast - +DEF per unit. Lv.10: Thorns">
                <span class="emoji"></span>
                <span class="food-level" id="feast-level">1</span>
            </div>
            <div class="food-level-item" title="Nectar - +HP per unit. Lv.10: Regeneration">
                <span class="emoji"></span>
                <span class="food-level" id="nectar-level">1</span>
            </div>
        </div>
        <!-- Cycle Timer Display -->
        <div class="cycle-timer" id="cycle-timer">
            <span class="cycle-label">Next Ant:</span>
            <span class="cycle-countdown" id="cycle-countdown">60s</span>
            <div class="cycle-bar">
                <div class="cycle-bar-fill" id="cycle-bar-fill"></div>
            </div>
        </div>
        <!-- Next Ant Preview -->
        <div class="next-ant-preview" id="next-ant-preview">
            <span class="preview-title">Bonuses:</span>
            <span class="preview-stats" id="preview-stats">--</span>
        </div>
    </div>

    <!-- Hive Placement Overlay -->
    <div id="hive-placement-overlay" class="hive-placement-overlay">
        <div class="hive-placement-text">CLICK TO PLACE YOUR HIVE</div>
        <div class="hive-placement-subtitle">Choose where your colony will begin</div>
    </div>

    <!-- Hive Cursor (follows mouse during placement) -->
    <div id="hive-cursor" class="hive-cursor hidden"></div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="game-over-modal">
        <div class="game-over-content">
            <div class="game-over-title">COLONY EXTINCT</div>
            <div class="game-over-subtitle">The darkness has consumed your colony</div>
            <div class="survival-time" id="final-time">0:00</div>
            <div class="survival-label">Survival Time</div>
            <div class="game-stats">
                <div class="game-stat">
                    <div class="game-stat-value" id="final-food">0</div>
                    <div class="game-stat-label">Food Collected</div>
                </div>
                <div class="game-stat">
                    <div class="game-stat-value" id="final-coins">0</div>
                    <div class="game-stat-label">Coins Earned</div>
                </div>
                <div class="game-stat">
                    <div class="game-stat-value" id="final-ants">0</div>
                    <div class="game-stat-label">Ants Spawned</div>
                </div>
            </div>
            <button class="restart-btn" onclick="restartGame()">RESTART</button>
        </div>
    </div>

    <!-- Harvest Summary Modal -->
    <div id="harvest-modal" class="harvest-modal">
        <div class="harvest-header">
            <span class="harvest-title">HARVEST COMPLETE</span>
            <span class="harvest-subtitle">New ant is hatching...</span>
        </div>
        <div class="harvest-body">
            <div class="harvest-deliveries" id="harvest-deliveries">
                <!-- Food icons delivered this cycle -->
            </div>
            <div class="harvest-arrow"></div>
            <div class="harvest-ant">
                <span class="harvest-ant-icon"></span>
                <span class="harvest-ant-label">New Ant</span>
            </div>
        </div>
        <div class="harvest-stats" id="harvest-stats">
            <div class="harvest-stat">
                <span class="harvest-stat-label">HP</span>
                <span class="harvest-stat-value" id="harvest-hp">+0</span>
            </div>
            <div class="harvest-stat">
                <span class="harvest-stat-label">ATK</span>
                <span class="harvest-stat-value" id="harvest-atk">+0</span>
            </div>
            <div class="harvest-stat">
                <span class="harvest-stat-label">DEF</span>
                <span class="harvest-stat-value" id="harvest-def">+0</span>
            </div>
            <div class="harvest-stat">
                <span class="harvest-stat-label">CARRY</span>
                <span class="harvest-stat-value" id="harvest-carry">+0</span>
            </div>
        </div>
        <div class="harvest-abilities" id="harvest-abilities">
            <!-- Abilities earned this cycle -->
        </div>
        <button class="harvest-continue-btn" id="harvest-continue-btn">SPAWN ANT</button>
    </div>

    <!-- Upgrade Selection Panel -->
    <div id="upgrade-modal" class="upgrade-modal">
        <div class="upgrade-header">
            <div class="upgrade-title">EVOLVE</div>
            <button class="upgrade-hide-btn" id="upgrade-hide-btn" title="Hide (still counting down)"></button>
        </div>
        <div class="upgrade-subtitle">Pick an upgrade</div>
        <div class="upgrade-timer" id="upgrade-timer">
            <span class="upgrade-timer-text">Auto-select in: <span id="upgrade-countdown">60</span>s</span>
            <button class="upgrade-expand-btn" id="upgrade-expand-btn" title="Show upgrade choices"></button>
            <div class="upgrade-timer-bar">
                <div class="upgrade-timer-fill" id="upgrade-timer-fill" style="width: 100%"></div>
            </div>
        </div>
        <div class="upgrade-options" id="upgrade-options">
            <!-- Upgrade cards will be inserted here by JavaScript -->
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let dpr = window.devicePixelRatio || 1;
        let width = window.innerWidth;
        let height = window.innerHeight;
        let time = 0;

        // ===========================================
        // FLOATING TEXT & COMBAT EFFECTS SYSTEM
        // ===========================================

        let floatingTexts = [];
        let combatEffects = [];
        let deathEffects = [];

        // Spawn a death effect (particle explosion + skull)
        function spawnDeathEffect(x, y, type = 'ant', color = null) {
            const isAnt = type === 'ant';
            const baseColor = color || (isAnt ? { r: 80, g: 50, b: 30 } : { r: 100, g: 100, b: 100 });
            const particleCount = isAnt ? 12 : 20;
            const particles = [];

            // Create particles that explode outward
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.3;
                const speed = 1.5 + Math.random() * 2.5;
                particles.push({
                    x: 0,
                    y: 0,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,  // Slight upward bias
                    size: isAnt ? (2 + Math.random() * 2) : (3 + Math.random() * 3),
                    color: `rgb(${baseColor.r + Math.random() * 30}, ${baseColor.g + Math.random() * 30}, ${baseColor.b + Math.random() * 20})`,
                    rotation: Math.random() * Math.PI * 2
                });
            }

            deathEffects.push({
                x: x,
                y: y,
                type: type,
                particles: particles,
                life: 50,  // frames
                maxLife: 50,
                skullScale: 0,
                emoji: isAnt ? '' : ''
            });
        }

        function updateDeathEffects() {
            for (let i = deathEffects.length - 1; i >= 0; i--) {
                const de = deathEffects[i];
                de.life--;

                // Animate skull pop-in then fade
                if (de.life > 35) {
                    de.skullScale += (1.2 - de.skullScale) * 0.3;
                } else if (de.life > 25) {
                    de.skullScale += (1.0 - de.skullScale) * 0.2;
                }

                // Update particles
                for (const p of de.particles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15;  // Gravity
                    p.vx *= 0.96;  // Air resistance
                    p.rotation += 0.1;
                }

                if (de.life <= 0) {
                    deathEffects.splice(i, 1);
                }
            }
        }

        function drawDeathEffects() {
            ctx.save();
            for (const de of deathEffects) {
                const alpha = de.life / de.maxLife;

                // Draw particles
                for (const p of de.particles) {
                    ctx.save();
                    ctx.globalAlpha = alpha * 0.8;
                    ctx.translate(de.x + p.x, de.y + p.y);
                    ctx.rotate(p.rotation);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    ctx.restore();
                }

                // Draw skull emoji with pop-in effect
                if (de.skullScale > 0.1) {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.translate(de.x, de.y - 10);
                    ctx.scale(de.skullScale, de.skullScale);
                    ctx.font = de.type === 'ant' ? '16px serif' : '22px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(de.emoji, 0, 0);
                    ctx.restore();
                }
            }
            ctx.restore();
        }

        function spawnFloatingText(x, y, text, color = '#ffd700', size = 14) {
            floatingTexts.push({
                x: x,
                y: y,
                text: text,
                color: color,
                size: size,
                alpha: 1,
                life: 60,  // frames
                vy: -1.5   // float upward
            });
        }

        function spawnCombatEffect(x, y, antHp, antMaxHp, predatorHp, predatorMaxHp) {
            combatEffects.push({
                x: x,
                y: y,
                antHp: antHp,
                antMaxHp: antMaxHp,
                predatorHp: predatorHp,
                predatorMaxHp: predatorMaxHp,
                life: 40,  // frames
                scale: 0,
                targetScale: 1
            });
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.y += ft.vy;
                ft.life--;
                ft.alpha = ft.life / 60;
                if (ft.life <= 0) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function drawFloatingTexts() {
            ctx.save();
            for (const ft of floatingTexts) {
                ctx.globalAlpha = ft.alpha;
                ctx.font = `bold ${ft.size}px 'Orbitron', sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillStyle = ft.color;
                ctx.shadowColor = ft.color;
                ctx.shadowBlur = 8;
                ctx.fillText(ft.text, ft.x, ft.y);
            }
            ctx.restore();
        }

        function updateCombatEffects() {
            for (let i = combatEffects.length - 1; i >= 0; i--) {
                const ce = combatEffects[i];
                ce.life--;
                ce.scale += (ce.targetScale - ce.scale) * 0.3;
                if (ce.life <= 0) {
                    combatEffects.splice(i, 1);
                }
            }
        }

        function drawCombatEffects() {
            ctx.save();
            for (const ce of combatEffects) {
                const alpha = ce.life / 40;
                ctx.globalAlpha = alpha;
                ctx.translate(ce.x, ce.y);
                ctx.scale(ce.scale, ce.scale);

                // Draw combat clash effect
                const clashSize = 25;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 10;

                // Clash lines
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + ce.life * 0.1;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 5, Math.sin(angle) * 5);
                    ctx.lineTo(Math.cos(angle) * clashSize, Math.sin(angle) * clashSize);
                    ctx.stroke();
                }

                // Health bars below
                const barWidth = 40;
                const barHeight = 6;
                const barY = 20;

                // Ant HP bar (green)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-barWidth/2 - 25, barY, barWidth, barHeight);
                ctx.fillStyle = '#00ff88';
                ctx.fillRect(-barWidth/2 - 25, barY, barWidth * (ce.antHp / ce.antMaxHp), barHeight);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 1;
                ctx.strokeRect(-barWidth/2 - 25, barY, barWidth, barHeight);

                // Predator HP bar (red)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(barWidth/2 - 15, barY, barWidth, barHeight);
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(barWidth/2 - 15, barY, barWidth * (ce.predatorHp / ce.predatorMaxHp), barHeight);
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 1;
                ctx.strokeRect(barWidth/2 - 15, barY, barWidth, barHeight);

                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            ctx.restore();
        }

        // ===========================================
        // SEEDED RANDOM NUMBER GENERATOR
        // ===========================================

        let currentSeed = Date.now();

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        class SeededRNG {
            constructor(seed) {
                this.seed = seed;
            }

            next() {
                this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
                return this.seed / 0x7fffffff;
            }

            nextRange(min, max) {
                return min + this.next() * (max - min);
            }

            nextInt(min, max) {
                return Math.floor(this.nextRange(min, max + 1));
            }
        }

        let rng = new SeededRNG(currentSeed);

        // ===========================================
        // MAP SPOTS (Food & Predator spawn points)
        // ===========================================

        let foodSpots = [];      // 5 spots for the 5 food types
        let predatorSpots = [];  // 2 spots where predators spawn (spider, beetle)

        function generateMapSpots() {
            foodSpots = [];
            predatorSpots = [];

            const margin = 100;
            const foodSpotSpacing = 200; // Minimum distance between food spots

            // Generate 5 food spots - one for each food type, well spaced across the map
            for (let i = 0; i < 5; i++) {
                let spot;
                let attempts = 0;
                do {
                    spot = {
                        x: rng.nextRange(margin, width - margin),
                        y: rng.nextRange(margin, height - margin),
                        type: 'food',
                        radius: 55,
                        multiplier: 1  // Default multiplier, will be set in placeHive()
                    };
                    attempts++;
                } while (
                    (foodSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < foodSpotSpacing)) &&
                    attempts < 50
                );
                foodSpots.push(spot);
            }

            // Generate 2 predator spots (spider and beetle)
            const predatorTypes = ['spider', 'beetle'];
            for (let i = 0; i < 2; i++) {
                let spot;
                let attempts = 0;
                do {
                    spot = {
                        x: rng.nextRange(margin, width - margin),
                        y: rng.nextRange(margin, height - margin),
                        type: predatorTypes[i],
                        radius: 40
                    };
                    attempts++;
                } while (
                    (foodSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < 100) ||
                    predatorSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < 150)) &&
                    attempts < 50
                );
                predatorSpots.push(spot);
            }
        }

        function drawSpots() {
            // Draw food spots with distance-based multipliers
            for (let i = 0; i < foodSpots.length; i++) {
                const spot = foodSpots[i];
                ctx.save();

                // Check if zone is occupied
                const isOccupied = zoneOccupied.has(i);

                // Color varies based on multiplier (x1=green, x2=yellow, x3=gold)
                // Use getDisplayMultiplier to show preview during hive placement
                const multiplier = getDisplayMultiplier(spot);
                let baseColor, labelColor;
                if (multiplier === 3) {
                    baseColor = { r: 255, g: 180, b: 50 };  // Gold for x3
                    labelColor = 'rgba(255, 200, 80, 0.9)';
                } else if (multiplier === 2) {
                    baseColor = { r: 220, g: 200, b: 80 };  // Yellow for x2
                    labelColor = 'rgba(220, 200, 80, 0.9)';
                } else {
                    baseColor = { r: 184, g: 212, b: 104 }; // Green for x1
                    labelColor = 'rgba(184, 212, 104, 0.7)';
                }

                // Dim occupied zones
                const alphaMultiplier = isOccupied ? 0.3 : 1.0;

                // Glowing circle for food spot
                const gradient = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.radius);
                gradient.addColorStop(0, `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.15 * alphaMultiplier})`);
                gradient.addColorStop(0.7, `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.08 * alphaMultiplier})`);
                gradient.addColorStop(1, `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // Dashed border (solid when occupied)
                ctx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.4 * alphaMultiplier})`;
                ctx.lineWidth = 2;
                if (!isOccupied) {
                    ctx.setLineDash([6, 6]);
                }
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label - show the food type for this zone
                ctx.fillStyle = labelColor;
                ctx.font = 'bold 10px "DM Mono", monospace';
                ctx.textAlign = 'center';

                // Before hive placement, show food type; after, show food type + level
                if (gameStarted && spot.assignedFoodType) {
                    const foodType = spot.assignedFoodType;
                    const foodConfig = CONFIG.foodTypes[foodType];
                    const emoji = foodConfig ? foodConfig.emoji : '';
                    const level = foodLevels[foodType] || 1;
                    ctx.fillText(`${emoji} Lv.${level}`, spot.x, spot.y - spot.radius - 8);
                } else {
                    // Before hive placement - show generic food zone label
                    ctx.fillText('FOOD ZONE', spot.x, spot.y - spot.radius - 8);
                }

                // Multiplier badge - show "?" before hive placement, actual multiplier after
                const badgeX = spot.x + spot.radius * 0.7;
                const badgeY = spot.y - spot.radius * 0.5;
                ctx.fillStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${0.9 * alphaMultiplier})`;
                ctx.beginPath();
                ctx.arc(badgeX, badgeY, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.font = 'bold 11px "DM Mono", monospace';
                // Show multiplier preview during hive placement, "?" before, actual value after
                const badgeText = gameStarted ? `x${multiplier}` : (isPreviewingHivePlacement ? `x${multiplier}` : '?');
                ctx.fillText(badgeText, badgeX, badgeY + 4);

                ctx.restore();
            }

            // Draw predator spots
            for (const spot of predatorSpots) {
                ctx.save();

                const color = spot.type === 'spider'
                    ? { r: 120, g: 40, b: 40 }
                    : { r: 80, g: 100, b: 50 };

                // Danger glow
                const gradient = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.radius);
                gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.25)`);
                gradient.addColorStop(0.7, `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`);
                gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // Pulsing border
                const pulse = Math.sin(Date.now() / 500) * 0.2 + 0.8;
                ctx.strokeStyle = `rgba(${color.r * 2}, ${color.g * 2}, ${color.b * 2}, ${0.5 * pulse})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = `rgba(${color.r * 2}, ${color.g * 2}, ${color.b * 2}, 0.8)`;
                ctx.font = 'bold 10px "DM Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(spot.type.toUpperCase() + ' DEN', spot.x, spot.y - spot.radius - 8);

                // Icon
                ctx.font = '20px sans-serif';
                ctx.fillText(spot.type === 'spider' ? '' : '', spot.x, spot.y + 6);

                ctx.restore();
            }
        }

        // ===========================================
        // CONFIGURATION
        // ===========================================

        const CONFIG = {
            nestX: 0,
            nestY: 0,
            nestRadius: 40,
            initialAnts: 10,
            maxAnts: 300,

            antSpeed: 0.7,
            antSize: 6,
            carryCapacity: 8,
            turnRate: 0.15,
            wanderStrength: 0.25,

            pheromoneGridSize: 10,
            pheromoneDecay: 0.996,
            pheromoneDeposit: 1.2,
            pheromoneMax: 255,
            pheromoneFollowStrength: 0.35,

            // Food types - size is now based on food level (units = level)
            // No costs - food is free to place
            foodTypes: {
                sugar: {
                    baseRadius: 14, value: 0, cost: 0, name: 'sugar', emoji: '',
                    bonusStat: 'hp', bonusPerUnit: 1, effectColor: '#ff6b81',
                    effectDesc: '+HP', abilityName: 'Gold Hunter'
                },
                protein: {
                    baseRadius: 16, value: 0, cost: 0, name: 'protein', emoji: '',
                    bonusStat: 'atk', bonusPerUnit: 1, effectColor: '#ff6b6b',
                    effectDesc: '+ATK', abilityName: 'Lifesteal'
                },
                fruit: {
                    baseRadius: 18, value: 0, cost: 0, name: 'fruit', emoji: '',
                    bonusStat: 'carry', bonusPerUnit: 1, effectColor: '#7bed9f',
                    effectDesc: '+Carry', abilityName: 'Fresh Keeper'
                },
                feast: {
                    baseRadius: 20, value: 0, cost: 0, name: 'feast', emoji: '',
                    bonusStat: 'def', bonusPerUnit: 1, effectColor: '#ffa502',
                    effectDesc: '+DEF', abilityName: 'Thorns'
                },
                nectar: {
                    baseRadius: 22, value: 0, cost: 0, name: 'nectar', emoji: '',
                    bonusStat: 'hp', bonusPerUnit: 1, effectColor: '#ff6b81',
                    effectDesc: '+HP', abilityName: 'Regeneration'
                },
                goldenApple: {
                    baseRadius: 24, value: 0, cost: 0, name: 'golden apple', emoji: '',
                    bonusStat: 'all', bonusPerUnit: 1, effectColor: '#ffd700',
                    effectDesc: '+ALL', abilityName: 'Champion', isRare: true,
                    glowColor: { r: 255, g: 215, b: 0 }
                }
            },

            // Ant types that can be spawned (costs scale up)
            antSpawnCosts: {
                worker:   { baseCost: 5, emoji: '', description: 'Balanced worker ant' },
                soldier:  { baseCost: 15, emoji: '', description: 'Fights predators' },
                scout:    { baseCost: 25, emoji: '', description: 'Fast explorer' },
                carrier:  { baseCost: 40, emoji: '', description: 'High carry capacity' },
                queen:    { baseCost: 80, emoji: '', description: 'Spawns workers over time' }
            },

            // Ant types with Pokemon-style stats (HP, ATK, DEF) plus behavior stats
            antTypes: {
                worker: {
                    // Classic dark brown ant - balanced stats
                    color: { r: 45, g: 30, b: 20 },
                    accentColor: { r: 70, g: 50, b: 35 },
                    // Pokemon-style stats
                    hp: 10,                  // Health points
                    atk: 2,                  // Attack power
                    def: 2,                  // Defense (damage reduction)
                    // Behavior stats
                    speed: 0.5,
                    carryCapacity: 1,
                    carrySpeedBonus: 1.0,
                    pheromoneStrength: 0.8,
                    foodDetectRadius: 48,    // 4x detection radius
                    // Level bonuses per level (1-5)
                    levelBonuses: {
                        hp: 2,               // +2 HP per level
                        atk: 0.5,            // +0.5 ATK per level
                        def: 0.5,            // +0.5 DEF per level
                        speed: 0.06,
                        carryCapacity: 0.25,
                        carrySpeedBonus: 0.08,
                        foodDetectRadius: 3
                    },
                    skillLevel: 3,
                    skillName: 'Efficient Forager',
                    skillDesc: 'Follows pheromone trails with 95% accuracy instead of 70%'
                },
                soldier: {
                    // Deep red/crimson - high ATK, good DEF
                    color: { r: 120, g: 25, b: 25 },
                    accentColor: { r: 180, g: 50, b: 50 },
                    // Pokemon-style stats
                    hp: 20,                  // Tanky
                    atk: 8,                  // High attack
                    def: 5,                  // Good defense
                    // Behavior stats
                    speed: 0.5,
                    carryCapacity: 1,
                    carrySpeedBonus: 0.9,
                    pheromoneStrength: 0.6,
                    foodDetectRadius: 10,
                    levelBonuses: {
                        hp: 5,               // +5 HP per level
                        atk: 2,              // +2 ATK per level
                        def: 1,              // +1 DEF per level
                        speed: 0.05,
                        foodDetectRadius: 2
                    },
                    skillLevel: 3,
                    skillName: 'Berserker',
                    skillDesc: 'ATK doubles when colony has lost ants to predators recently'
                },
                scout: {
                    // Bright golden/yellow - fast, low combat stats
                    color: { r: 180, g: 140, b: 40 },
                    accentColor: { r: 220, g: 180, b: 60 },
                    // Pokemon-style stats
                    hp: 6,                   // Fragile
                    atk: 1,                  // Low attack
                    def: 1,                  // Low defense
                    // Behavior stats
                    speed: 0.7,
                    carryCapacity: 1,
                    carrySpeedBonus: 0.9,
                    pheromoneStrength: 4.0,
                    foodDetectRadius: 160,
                    wanderStrength: 0.5,
                    levelBonuses: {
                        hp: 1,
                        atk: 0.25,
                        def: 0.25,
                        speed: 0.1,
                        pheromoneStrength: 1.0,
                        foodDetectRadius: 40
                    },
                    skillLevel: 3,
                    skillName: 'Trailblazer',
                    skillDesc: 'Discovering food creates a bright beacon visible to all nearby ants'
                },
                carrier: {
                    // Steel blue/gray - high HP, high DEF
                    color: { r: 50, g: 65, b: 85 },
                    accentColor: { r: 80, g: 100, b: 130 },
                    // Pokemon-style stats
                    hp: 25,                  // Very tanky
                    atk: 1,                  // Low attack
                    def: 6,                  // High defense
                    // Behavior stats
                    speed: 0.4,
                    carryCapacity: 3,
                    carrySpeedBonus: 1.2,
                    pheromoneStrength: 0.5,
                    foodDetectRadius: 14,
                    size: 1.35,
                    levelBonuses: {
                        hp: 6,               // +6 HP per level
                        atk: 0.25,
                        def: 1.5,            // +1.5 DEF per level
                        speed: 0.04,
                        carryCapacity: 0.5,
                        carrySpeedBonus: 0.12,
                        foodDetectRadius: 3
                    },
                    skillLevel: 3,
                    skillName: 'Beast of Burden',
                    skillDesc: 'No speed penalty when carrying food - moves at full speed always'
                },
                queen: {
                    // Royal purple/magenta - moderate stats, spawns workers
                    color: { r: 100, g: 45, b: 120 },
                    accentColor: { r: 150, g: 80, b: 170 },
                    // Pokemon-style stats
                    hp: 30,                  // High HP - valuable target
                    atk: 3,                  // Moderate attack
                    def: 4,                  // Moderate defense
                    // Behavior stats
                    speed: 0.25,
                    carryCapacity: 1,
                    carrySpeedBonus: 1,
                    pheromoneStrength: 1.2,
                    foodDetectRadius: 8,
                    size: 1.6,
                    spawnInterval: 900,
                    staysNearNest: true,
                    levelBonuses: {
                        speed: 0.02,
                        pheromoneStrength: 0.15,
                        spawnInterval: -100  // Faster spawning with levels (negative = better)
                    },
                    skillLevel: 3,
                    skillName: 'Royal Decree',
                    skillDesc: 'All ants within range receive +25% speed boost from royal inspiration'
                }
            },

            // Level thresholds (XP needed for each level)
            levelThresholds: [0, 8, 20, 40, 75],  // Level 1, 2, 3, 4, 5

            // Colony state tracking
            recentDeaths: 0,
            deathDecayTimer: 0,

            // Predator territories and stats
            predators: {
                spider: {
                    x: 0, y: 0, radius: 120,
                    multiplier: 3,
                    color: { r: 80, g: 20, b: 20 },
                    label: 'SPIDER ZONE',
                    huntRadius: 500,  // Hunt ants from far away
                    killRadius: 12,
                    speed: 1.8,
                    // Pokemon-style stats
                    hp: 40,                  // Lower HP - glass cannon
                    atk: 4,                  // Moderate attack
                    def: 1                   // Very low defense - easy to damage
                },
                beetle: {
                    x: 0, y: 0, radius: 90,
                    multiplier: 2,
                    color: { r: 50, g: 70, b: 35 },
                    label: 'BEETLE ZONE',
                    patrolSpeed: 0.7,
                    huntRadius: 300,  // Hunt ants from moderate distance
                    killRadius: 20,
                    blockRadius: 35,
                    // Pokemon-style stats
                    hp: 60,                  // Tanky
                    atk: 1,                  // Very low attack
                    def: 4                   // High defense - hard to damage
                }
            }
        };

        // ===========================================
        // CURRENCY SYSTEM
        // ===========================================

        let coins = 10;  // Starting gold for first upgrade (gold mainly comes from enemy kills now)

        // ===========================================
        // SURVIVAL MODE STATE
        // ===========================================

        let gameOver = false;
        let gameStarted = false;  // Game starts paused until hive is placed
        let gameStartTime = null;  // Will be set when hive is placed
        let pausedTime = 0;  // Track total paused time for accurate timer
        let pauseStartTime = null;  // When the current pause started
        let totalAntsSpawned = 0;
        let totalCoinsEarned = 0;
        let lastUpdateTime = Date.now();

        // Arrays to hold multiple predators of each type
        let spiderPredators = [];
        let beetlePredators = [];

        function getElapsedSeconds() {
            if (!gameStartTime) return 0;
            // Account for paused time
            let currentPausedTime = pausedTime;
            if (pauseStartTime !== null) {
                currentPausedTime += Date.now() - pauseStartTime;
            }
            return (Date.now() - gameStartTime - currentPausedTime) / 1000;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function checkGameOver() {
            if (gameOver) return;

            // Game over when all ants are dead (after 2 second grace period)
            if (ants.length === 0 && getElapsedSeconds() > 2) {
                triggerGameOver();
            }
        }

        function triggerGameOver() {
            gameOver = true;

            // Update final stats
            document.getElementById('final-time').textContent = formatTime(getElapsedSeconds());
            document.getElementById('final-food').textContent = foodCollected;
            document.getElementById('final-coins').textContent = totalCoinsEarned;
            document.getElementById('final-ants').textContent = totalAntsSpawned;

            // Show modal
            document.getElementById('game-over-modal').classList.add('visible');
        }

        let lastPredatorSpawnTime = 0;  // Track spawn time in seconds

        function checkPredatorSpawn() {
            if (gameOver) return;

            const elapsed = getElapsedSeconds();
            const spawnInterval = 60;  // Every 60 seconds

            // Check if enough time has passed since last spawn
            if (elapsed >= spawnInterval && elapsed - lastPredatorSpawnTime >= spawnInterval) {
                lastPredatorSpawnTime = elapsed;
                spawnAdditionalPredators();
            }
        }

        function spawnAdditionalPredators() {
            // Spawn one more of each predator type
            const newSpider = new Spider();
            // Offset position slightly
            newSpider.x += (Math.random() - 0.5) * 50;
            newSpider.y += (Math.random() - 0.5) * 50;
            spiderPredators.push(newSpider);

            const newBeetle = new Beetle();
            newBeetle.x += (Math.random() - 0.5) * 50;
            newBeetle.y += (Math.random() - 0.5) * 50;
            beetlePredators.push(newBeetle);
        }

        // ===========================================
        // RARE FOOD SPAWN SYSTEM
        // ===========================================

        let lastRareFoodSpawnTime = 0;
        const RARE_FOOD_SPAWN_INTERVAL = 45;  // Check every 45 seconds
        const RARE_FOOD_SPAWN_CHANCE = 0.35;  // 35% chance per check

        function checkRareFoodSpawn() {
            if (gameOver) return;

            const elapsed = getElapsedSeconds();

            // Check if enough time has passed since last rare food check
            if (elapsed - lastRareFoodSpawnTime >= RARE_FOOD_SPAWN_INTERVAL) {
                lastRareFoodSpawnTime = elapsed;

                // Roll for spawn
                if (Math.random() < RARE_FOOD_SPAWN_CHANCE) {
                    spawnRareFood();
                }
            }
        }

        function spawnRareFood() {
            // Spawn a golden apple at a random location on the map
            // Prefer spawning away from the nest but not too far
            const margin = 100;
            const maxDist = Math.min(width, height) * 0.4;
            const minDist = 150;  // Not too close to nest

            let x, y, dist;
            let attempts = 0;

            // Find a valid spawn location
            do {
                x = margin + Math.random() * (width - margin * 2);
                y = margin + Math.random() * (height - margin * 2);
                dist = Math.hypot(x - CONFIG.nestX, y - CONFIG.nestY);
                attempts++;
            } while ((dist < minDist || dist > maxDist) && attempts < 50);

            // Create the rare food item
            const goldenApple = new FoodItem(x, y, 'goldenApple');
            foodItems.push(goldenApple);

            // Show a notification using rare food notification system
            addRareFoodNotification(`Golden Apple appeared!`, x, y);
        }

        // Rare food notification system (separate from ant spawn notifications)
        let rareFoodNotifications = [];

        function addRareFoodNotification(text, x, y) {
            rareFoodNotifications.push({
                text,
                x,
                y,
                startTime: Date.now(),
                duration: 3000
            });
        }

        function updateRareFoodNotifications() {
            const now = Date.now();
            rareFoodNotifications = rareFoodNotifications.filter(n => now - n.startTime < n.duration);
        }

        function drawRareFoodNotifications() {
            const now = Date.now();
            for (const notif of rareFoodNotifications) {
                const elapsed = now - notif.startTime;
                const progress = elapsed / notif.duration;
                const alpha = 1 - progress;
                const yOffset = -30 * progress;  // Float upward
                const scale = 1 + Math.sin(elapsed / 100) * 0.1;  // Subtle pulse

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(notif.x, notif.y + yOffset);
                ctx.scale(scale, scale);
                ctx.fillStyle = '#ffd700';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 3;
                ctx.font = 'bold 16px "DM Mono", monospace';
                ctx.textAlign = 'center';
                ctx.strokeText(notif.text, 0, 0);
                ctx.fillText(notif.text, 0, 0);
                ctx.restore();
            }
        }

        // ===========================================
        // UPGRADE SYSTEM (Vampire Survivors style)
        // ===========================================

        let upgradesPaused = false;
        let lastUpgradeTime = 0;
        const UPGRADE_INTERVAL = 60;  // Seconds between upgrade offers
        const UPGRADE_CHOICE_TIMEOUT = 60;  // Seconds before auto-choosing
        let upgradeChoiceStartTime = 0;  // When the current upgrade choice was shown
        let activeUpgrades = [];  // Track which upgrades player has chosen
        let upgradeMultipliers = {
            antSpeed: 1,
            carryCapacity: 0,          // Changed to flat bonus (was misleading multiplier)
            spawnCostReduction: 1,
            foodValue: 1,
            coinBonus: 0,
            maxAnts: 0,
            detectionRadius: 1,
            atkBonus: 0,               // Flat ATK bonus for all ants
            defBonus: 0,               // Flat DEF bonus for all ants
            hpBonus: 0,                // Flat HP bonus for all ants
            queenSpawnRate: 1,
            nestDefenseRadius: 80,     // Radius around nest for defense bonus
            nestDefenseBonus: 0,       // DEF bonus when near nest
            pheromoneStrength: 1,      // Multiplier for pheromone deposits
            predatorHpMultiplier: 1,   // Multiplier for predator max HP (lower = weaker predators)
            goldRushActive: false,     // Temporary gold bonus flag
            goldRushEndTime: 0,        // When gold rush expires
            goldRushMultiplier: 1      // Gold multiplier during rush
        };

        const UPGRADE_POOL = [
            // ============================================
            // LEFT COLUMN: ANT TYPES - Spawning & Colony
            // ============================================
            {
                id: 'free_worker',
                name: 'Worker Swarm',
                description: 'Instantly spawn 5 free workers',
                emoji: '',
                category: 'ants',
                apply: () => {
                    for (let i = 0; i < 5; i++) {
                        if (ants.length < CONFIG.maxAnts) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 30 + Math.random() * 20;
                            const ant = new Ant(
                                CONFIG.nestX + Math.cos(angle) * dist,
                                CONFIG.nestY + Math.sin(angle) * dist,
                                'worker'
                            );
                            ants.push(ant);
                            totalAntsSpawned++;
                        }
                    }
                },
                maxStacks: 99,
                premium: {
                    cost: 25,
                    description: 'Instantly spawn 12 free workers',
                    apply: () => {
                        for (let i = 0; i < 12; i++) {
                            if (ants.length < CONFIG.maxAnts) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 30 + Math.random() * 20;
                                const ant = new Ant(
                                    CONFIG.nestX + Math.cos(angle) * dist,
                                    CONFIG.nestY + Math.sin(angle) * dist,
                                    'worker'
                                );
                                ants.push(ant);
                                totalAntsSpawned++;
                            }
                        }
                    }
                }
            },
            {
                id: 'free_soldier',
                name: 'Reinforcements',
                description: 'Instantly spawn 3 free soldiers',
                emoji: '',
                category: 'ants',
                apply: () => {
                    for (let i = 0; i < 3; i++) {
                        if (ants.length < CONFIG.maxAnts) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 30 + Math.random() * 20;
                            const ant = new Ant(
                                CONFIG.nestX + Math.cos(angle) * dist,
                                CONFIG.nestY + Math.sin(angle) * dist,
                                'soldier'
                            );
                            ants.push(ant);
                            totalAntsSpawned++;
                        }
                    }
                },
                maxStacks: 99,
                premium: {
                    cost: 40,
                    description: 'Instantly spawn 8 free soldiers',
                    apply: () => {
                        for (let i = 0; i < 8; i++) {
                            if (ants.length < CONFIG.maxAnts) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 30 + Math.random() * 20;
                                const ant = new Ant(
                                    CONFIG.nestX + Math.cos(angle) * dist,
                                    CONFIG.nestY + Math.sin(angle) * dist,
                                    'soldier'
                                );
                                ants.push(ant);
                                totalAntsSpawned++;
                            }
                        }
                    }
                }
            },
            {
                id: 'max_ants',
                name: 'Colony Expansion',
                description: 'Max colony size +30 ants',
                emoji: '',
                category: 'ants',
                apply: () => {
                    upgradeMultipliers.maxAnts += 30;
                    CONFIG.maxAnts += 30;
                },
                maxStacks: 5,
                premium: {
                    cost: 65,
                    description: 'Max colony size +100 ants',
                    apply: () => {
                        upgradeMultipliers.maxAnts += 100;
                        CONFIG.maxAnts += 100;
                    }
                }
            },
            {
                id: 'queen_boost',
                name: 'Royal Fertility',
                description: 'Queens spawn ants 30% faster',
                emoji: '',
                category: 'ants',
                apply: () => { upgradeMultipliers.queenSpawnRate *= 0.70; },
                maxStacks: 3,
                premium: {
                    cost: 80,
                    description: 'Queens spawn ants 55% faster',
                    apply: () => { upgradeMultipliers.queenSpawnRate *= 0.45; }
                }
            },
            // ============================================
            // MIDDLE COLUMN: ECONOMY - Gold & Resources
            // ============================================
            {
                id: 'food_value',
                name: 'Nutrient Rich',
                description: 'Food deliveries give +30% gold',
                emoji: '',
                category: 'economy',
                apply: () => { upgradeMultipliers.foodValue *= 1.30; },
                maxStacks: 4,
                premium: {
                    cost: 45,
                    description: 'Food deliveries give +75% gold',
                    apply: () => { upgradeMultipliers.foodValue *= 1.75; }
                }
            },
            {
                id: 'coin_bonus',
                name: 'Golden Harvest',
                description: '+3 bonus gold per delivery',
                emoji: '',
                category: 'economy',
                apply: () => { upgradeMultipliers.coinBonus += 3; },
                maxStacks: 5,
                premium: {
                    cost: 35,
                    description: '+8 bonus gold per delivery',
                    apply: () => { upgradeMultipliers.coinBonus += 8; }
                }
            },
            {
                id: 'cheap_spawns',
                name: 'Efficient Breeding',
                description: 'Ant spawn costs reduced by 20%',
                emoji: '',
                category: 'economy',
                apply: () => { upgradeMultipliers.spawnCostReduction *= 0.80; },
                maxStacks: 4,
                premium: {
                    cost: 50,
                    description: 'Ant spawn costs reduced by 45%',
                    apply: () => { upgradeMultipliers.spawnCostReduction *= 0.55; }
                }
            },
            {
                id: 'gold_rush',
                name: 'Gold Rush',
                description: 'Double gold income for 90 seconds',
                emoji: '',
                category: 'economy',
                apply: () => {
                    upgradeMultipliers.goldRushActive = true;
                    upgradeMultipliers.goldRushMultiplier = 2;
                    upgradeMultipliers.goldRushEndTime = Date.now() + 90000;
                },
                maxStacks: 99,
                premium: {
                    cost: 60,
                    description: 'Triple gold income for 120 seconds',
                    apply: () => {
                        upgradeMultipliers.goldRushActive = true;
                        upgradeMultipliers.goldRushMultiplier = 3;
                        upgradeMultipliers.goldRushEndTime = Date.now() + 120000;
                    }
                }
            },
            {
                id: 'coin_burst',
                name: 'Treasure Found',
                description: 'Instantly gain 75 gold',
                emoji: '',
                category: 'economy',
                apply: () => {
                    coins += 75;
                    totalCoinsEarned += 75;
                },
                maxStacks: 99,
                premium: {
                    cost: 40,
                    description: 'Instantly gain 200 gold',
                    apply: () => {
                        coins += 200;
                        totalCoinsEarned += 200;
                    }
                }
            },
            // ============================================
            // RIGHT COLUMN: OTHER - Combat & Foraging
            // ============================================
            {
                id: 'atk_boost',
                name: 'Combat Training',
                description: 'All ants gain +3 ATK',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.atkBonus += 3; },
                maxStacks: 5,
                premium: {
                    cost: 55,
                    description: 'All ants gain +8 ATK',
                    apply: () => { upgradeMultipliers.atkBonus += 8; }
                }
            },
            {
                id: 'def_boost',
                name: 'Hardened Carapace',
                description: 'All ants gain +3 DEF',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.defBonus += 3; },
                maxStacks: 5,
                premium: {
                    cost: 55,
                    description: 'All ants gain +8 DEF',
                    apply: () => { upgradeMultipliers.defBonus += 8; }
                }
            },
            {
                id: 'hp_boost',
                name: 'Vitality',
                description: 'All ants gain +8 max HP',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.hpBonus += 8; },
                maxStacks: 5,
                premium: {
                    cost: 50,
                    description: 'All ants gain +20 max HP',
                    apply: () => { upgradeMultipliers.hpBonus += 20; }
                }
            },
            {
                id: 'nest_defense',
                name: 'Fortified Nest',
                description: 'Ants near nest gain +5 DEF',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.nestDefenseBonus += 5; },
                maxStacks: 3,
                premium: {
                    cost: 70,
                    description: 'Ants near nest gain +12 DEF',
                    apply: () => { upgradeMultipliers.nestDefenseBonus += 12; }
                }
            },
            {
                id: 'predator_weakness',
                name: 'Predator Bane',
                description: 'Predators have -15% max HP',
                emoji: '',
                category: 'other',
                apply: () => {
                    upgradeMultipliers.predatorHpMultiplier *= 0.85;
                    // Apply to existing predators
                    if (typeof spider !== 'undefined' && spider) {
                        spider.hp = Math.max(1, Math.floor(spider.hp * 0.85));
                        spider.maxHp = Math.max(1, Math.floor(spider.maxHp * 0.85));
                    }
                    for (const beetle of beetlePredators) {
                        beetle.hp = Math.max(1, Math.floor(beetle.hp * 0.85));
                        beetle.maxHp = Math.max(1, Math.floor(beetle.maxHp * 0.85));
                    }
                },
                maxStacks: 3,
                premium: {
                    cost: 100,
                    description: 'Predators have -35% max HP',
                    apply: () => {
                        upgradeMultipliers.predatorHpMultiplier *= 0.65;
                        // Apply to existing predators
                        if (typeof spider !== 'undefined' && spider) {
                            spider.hp = Math.max(1, Math.floor(spider.hp * 0.65));
                            spider.maxHp = Math.max(1, Math.floor(spider.maxHp * 0.65));
                        }
                        for (const beetle of beetlePredators) {
                            beetle.hp = Math.max(1, Math.floor(beetle.hp * 0.65));
                            beetle.maxHp = Math.max(1, Math.floor(beetle.maxHp * 0.65));
                        }
                    }
                }
            },
            {
                id: 'detection',
                name: 'Keen Senses',
                description: 'Food detection radius +40%',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.detectionRadius *= 1.4; },
                maxStacks: 3,
                premium: {
                    cost: 40,
                    description: 'Food detection radius +100%',
                    apply: () => { upgradeMultipliers.detectionRadius *= 2.0; }
                }
            },
            {
                id: 'carry_boost',
                name: 'Strong Mandibles',
                description: 'Carry capacity +1 for all ants',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.carryCapacity += 1; },
                maxStacks: 4,
                premium: {
                    cost: 45,
                    description: 'Carry capacity +3 for all ants',
                    apply: () => { upgradeMultipliers.carryCapacity += 3; }
                }
            },
            {
                id: 'pheromone_boost',
                name: 'Scent Markers',
                description: 'Pheromone trails are 50% stronger',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.pheromoneStrength *= 1.5; },
                maxStacks: 3,
                premium: {
                    cost: 50,
                    description: 'Pheromone trails are 2x stronger',
                    apply: () => { upgradeMultipliers.pheromoneStrength *= 2.0; }
                }
            },
            {
                id: 'speed_boost',
                name: 'Swift Legs',
                description: 'All ants move 25% faster',
                emoji: '',
                category: 'other',
                apply: () => { upgradeMultipliers.antSpeed *= 1.25; },
                maxStacks: 4,
                premium: {
                    cost: 60,
                    description: 'All ants move 50% faster',
                    apply: () => { upgradeMultipliers.antSpeed *= 1.50; }
                }
            }
        ];

        function getUpgradeStacks(upgradeId) {
            return activeUpgrades.filter(u => u === upgradeId).length;
        }

        function getRandomUpgrades(count = 3) {
            // Filter out maxed upgrades
            const available = UPGRADE_POOL.filter(u => getUpgradeStacks(u.id) < u.maxStacks);

            // Organize by category: ants (left), economy (middle), other (right)
            const categories = {
                ants: available.filter(u => u.category === 'ants'),
                economy: available.filter(u => u.category === 'economy'),
                other: available.filter(u => u.category === 'other')
            };

            // Pick one random upgrade from each category
            const result = [];
            const order = ['ants', 'economy', 'other'];
            for (const cat of order) {
                if (categories[cat].length > 0) {
                    const shuffled = categories[cat].sort(() => Math.random() - 0.5);
                    result.push(shuffled[0]);
                }
            }

            // If we don't have 3, fill from any available
            if (result.length < 3) {
                const remaining = available.filter(u => !result.includes(u));
                const shuffled = remaining.sort(() => Math.random() - 0.5);
                while (result.length < 3 && shuffled.length > 0) {
                    result.push(shuffled.shift());
                }
            }

            return result;
        }

        let currentUpgradeChoices = [];  // Track current upgrade options for auto-select

        function showUpgradeSelection() {
            upgradesPaused = true;
            // Start pausing the survival timer
            if (pauseStartTime === null) {
                pauseStartTime = Date.now();
            }
            const upgrades = getRandomUpgrades(3);
            currentUpgradeChoices = upgrades;  // Store for auto-select
            upgradeChoiceStartTime = Date.now();  // Start countdown

            const container = document.getElementById('upgrade-options');
            container.innerHTML = '';

            // Category labels and colors
            const categoryInfo = {
                ants: { label: 'COLONY', color: '#7bed9f' },
                economy: { label: 'ECONOMY', color: '#ffd700' },
                other: { label: 'POWER', color: '#ff6b6b' }
            };

            upgrades.forEach(upgrade => {
                const stacks = getUpgradeStacks(upgrade.id);
                const hasPremium = upgrade.premium && upgrade.premium.cost;
                const canAffordPremium = hasPremium && coins >= upgrade.premium.cost;
                const catInfo = categoryInfo[upgrade.category] || { label: 'OTHER', color: '#888' };

                const card = document.createElement('div');
                card.className = 'upgrade-card-wrapper';
                card.innerHTML = `
                    <div class="upgrade-category" style="color: ${catInfo.color}; border-color: ${catInfo.color}">${catInfo.label}</div>
                    <div class="upgrade-card" data-upgrade-id="${upgrade.id}">
                        <div class="upgrade-emoji">${upgrade.emoji}</div>
                        <div class="upgrade-info">
                            <div class="upgrade-name">${upgrade.name}</div>
                            <div class="upgrade-desc">${upgrade.description}</div>
                        </div>
                        ${stacks > 0 ? `<div class="upgrade-stacks">x${stacks + 1}</div>` : ''}
                    </div>
                    ${hasPremium ? `
                        <div class="upgrade-premium ${canAffordPremium ? '' : 'disabled'}" data-upgrade-id="${upgrade.id}">
                            <span class="premium-cost">${upgrade.premium.cost}G</span>
                            <span class="premium-desc">${upgrade.premium.description}</span>
                        </div>
                    ` : ''}
                `;

                // Add click handlers
                const normalCard = card.querySelector('.upgrade-card');
                normalCard.onclick = () => selectUpgrade(upgrade);

                if (hasPremium) {
                    const premiumCard = card.querySelector('.upgrade-premium');
                    premiumCard.onclick = () => selectPremiumUpgrade(upgrade);
                }

                container.appendChild(card);
            });

            // Reset countdown display
            document.getElementById('upgrade-countdown').textContent = UPGRADE_CHOICE_TIMEOUT;
            document.getElementById('upgrade-timer-fill').style.width = '100%';

            const modal = document.getElementById('upgrade-modal');
            modal.classList.remove('minimized');
            modal.classList.add('visible');
        }

        function selectUpgrade(upgrade) {
            upgrade.apply();
            activeUpgrades.push(upgrade.id);

            // Recalculate stats for all existing ants so upgrade bonuses apply immediately
            for (const ant of ants) {
                ant.recalculateStats();
            }

            document.getElementById('upgrade-modal').classList.remove('visible');
            document.getElementById('upgrade-modal').classList.remove('minimized');
            upgradesPaused = false;
            // End the survival timer pause
            if (pauseStartTime !== null) {
                pausedTime += Date.now() - pauseStartTime;
                pauseStartTime = null;
            }
            lastUpgradeTime = getElapsedSeconds();
            currentUpgradeChoices = [];  // Clear choices
        }

        function selectPremiumUpgrade(upgrade) {
            if (!upgrade.premium || coins < upgrade.premium.cost) {
                return;  // Can't afford
            }

            // Deduct cost
            coins -= upgrade.premium.cost;

            // Apply premium effect
            upgrade.premium.apply();
            activeUpgrades.push(upgrade.id);

            // Recalculate stats for all existing ants so upgrade bonuses apply immediately
            for (const ant of ants) {
                ant.recalculateStats();
            }

            document.getElementById('upgrade-modal').classList.remove('visible');
            document.getElementById('upgrade-modal').classList.remove('minimized');
            upgradesPaused = false;
            // End the survival timer pause
            if (pauseStartTime !== null) {
                pausedTime += Date.now() - pauseStartTime;
                pauseStartTime = null;
            }
            lastUpgradeTime = getElapsedSeconds();
            currentUpgradeChoices = [];  // Clear choices
        }

        function updateUpgradeCountdown() {
            if (!upgradesPaused || currentUpgradeChoices.length === 0) return;

            const elapsed = (Date.now() - upgradeChoiceStartTime) / 1000;
            const remaining = Math.max(0, UPGRADE_CHOICE_TIMEOUT - elapsed);

            // Update countdown display
            document.getElementById('upgrade-countdown').textContent = Math.ceil(remaining);
            document.getElementById('upgrade-timer-fill').style.width = (remaining / UPGRADE_CHOICE_TIMEOUT * 100) + '%';

            // Auto-select if time runs out
            if (remaining <= 0 && currentUpgradeChoices.length > 0) {
                const randomIndex = Math.floor(Math.random() * currentUpgradeChoices.length);
                selectUpgrade(currentUpgradeChoices[randomIndex]);
            }
        }

        function toggleUpgradePanel() {
            const modal = document.getElementById('upgrade-modal');
            const btn = document.getElementById('upgrade-hide-btn');
            if (modal.classList.contains('minimized')) {
                modal.classList.remove('minimized');
                btn.textContent = '\u25C0';  // Left arrow
                btn.title = 'Hide (still counting down)';
            } else {
                modal.classList.add('minimized');
                btn.textContent = '\u25B6';  // Right arrow
                btn.title = 'Show upgrade choices';
            }
        }

        // Set up hide button event listener
        document.getElementById('upgrade-hide-btn').addEventListener('click', toggleUpgradePanel);
        document.getElementById('upgrade-expand-btn').addEventListener('click', toggleUpgradePanel);

        function checkUpgradeTime() {
            if (gameOver || upgradesPaused || harvestModalOpen) return;

            const elapsed = getElapsedSeconds();
            const timeSinceLastUpgrade = elapsed - lastUpgradeTime;

            if (timeSinceLastUpgrade >= UPGRADE_INTERVAL) {
                // First show harvest summary, then upgrades will show after ant spawns
                triggerHarvestSummary();
            }
        }

        function resetUpgrades() {
            activeUpgrades = [];
            upgradeMultipliers = {
                antSpeed: 1,
                carryCapacity: 0,          // Reset to 0 (flat bonus)
                spawnCostReduction: 1,
                foodValue: 1,
                coinBonus: 0,
                maxAnts: 0,
                detectionRadius: 1,
                atkBonus: 0,
                defBonus: 0,
                hpBonus: 0,
                queenSpawnRate: 1,
                nestDefenseRadius: 80,
                nestDefenseBonus: 0,
                pheromoneStrength: 1,
                predatorHpMultiplier: 1,
                goldRushActive: false,
                goldRushEndTime: 0,
                goldRushMultiplier: 1
            };
            lastUpgradeTime = 0;
            CONFIG.maxAnts = 300;  // Reset to default
        }

        function restartGame() {
            // Hide modals
            document.getElementById('game-over-modal').classList.remove('visible');
            document.getElementById('upgrade-modal').classList.remove('visible');

            // Reset upgrades
            resetUpgrades();
            upgradesPaused = false;

            // Reset game state - go back to hive placement mode
            gameOver = false;
            gameStarted = false;  // Require hive placement again
            gameStartTime = null;
            pausedTime = 0;
            pauseStartTime = null;
            lastUpdateTime = Date.now();
            lastPredatorSpawnTime = 0;
            coins = 50;
            totalAntsSpawned = 0;
            totalCoinsEarned = 0;

            // Clear entities - ants will spawn when hive is placed
            ants.length = 0;
            foodItems.length = 0;
            foodCollected = 0;
            antIdCounter = 0;
            antSpawnCounts = { worker: 0, soldier: 0, scout: 0, carrier: 0, queen: 0 };

            // Reset seed and regenerate spots
            currentSeed = Date.now();
            rng = new SeededRNG(currentSeed);
            generateMapSpots();

            // Update predator positions from spots
            for (const spot of predatorSpots) {
                if (spot.type === 'spider') {
                    CONFIG.predators.spider.x = spot.x;
                    CONFIG.predators.spider.y = spot.y;
                } else if (spot.type === 'beetle') {
                    CONFIG.predators.beetle.x = spot.x;
                    CONFIG.predators.beetle.y = spot.y;
                }
            }

            // Reset predator arrays - don't spawn at start, they come from dens
            spiderPredators = [];
            beetlePredators = [];

            // Don't spawn ants yet - wait for hive placement
            // Show the hive placement overlay again
            document.getElementById('hive-placement-overlay').classList.remove('hidden');

            // Reset preview state for hive placement
            isPreviewingHivePlacement = false;
            previewMultipliers.clear();

            resize();
            updateUI();
        }

        function canAfford(cost) {
            return coins >= cost;
        }

        function spendCoins(amount) {
            if (coins >= amount) {
                coins -= amount;
                updateUI();
                return true;
            }
            return false;
        }

        function earnCoins(amount) {
            coins += amount;
            totalCoinsEarned += amount;
            updateUI();
        }

        function isInDangerZone(x, y) {
            // Check if position is near a predator spawn spot
            for (const spot of predatorSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius * 2) {
                    return true;
                }
            }
            return false;
        }

        function getDangerZoneMultiplier(x, y) {
            // Removed hidden danger zone multiplier - zone multiplier (x1, x2, x3)
            // already accounts for distance/risk and is visible to the player
            return 1;
        }

        function isNearBeetle(x, y) {
            // Check all beetles in the array
            for (const beetle of beetlePredators) {
                if (Math.hypot(x - beetle.x, y - beetle.y) < CONFIG.predators.beetle.blockRadius) {
                    return true;
                }
            }
            return false;
        }

        // ===========================================
        // SPAWN NOTIFICATIONS
        // ===========================================

        let spawnNotifications = [];

        function addSpawnNotification(antType) {
            const typeNames = {
                worker: 'Worker',
                soldier: 'Soldier',
                scout: 'Scout',
                carrier: 'Carrier',
                queen: 'Queen'
            };
            const typeColors = {
                worker: 'rgba(139, 90, 43, 0.9)',
                soldier: 'rgba(170, 60, 50, 0.9)',
                scout: 'rgba(180, 140, 60, 0.9)',
                carrier: 'rgba(100, 80, 60, 0.9)',
                queen: 'rgba(200, 150, 100, 0.9)'
            };
            spawnNotifications.push({
                text: `${typeNames[antType]} spawned!`,
                color: typeColors[antType],
                x: CONFIG.nestX,
                y: CONFIG.nestY - getColonySize() - 20,
                alpha: 1,
                life: 90
            });
        }

        function updateSpawnNotifications() {
            for (let i = spawnNotifications.length - 1; i >= 0; i--) {
                const notif = spawnNotifications[i];
                notif.y -= 0.5;
                notif.life--;
                notif.alpha = notif.life / 90;
                if (notif.life <= 0) {
                    spawnNotifications.splice(i, 1);
                }
            }
        }

        function drawSpawnNotifications() {
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px "DM Mono", monospace';
            for (const notif of spawnNotifications) {
                ctx.fillStyle = notif.color.replace('0.9', notif.alpha.toFixed(2));
                ctx.fillText(notif.text, notif.x, notif.y);
            }
        }

        // ===========================================
        // AMBIENT PARTICLES
        // ===========================================

        let dustMotes = [];

        function initAmbientParticles() {
            dustMotes = [];
            const numDust = Math.floor((width * height) / 25000);
            for (let i = 0; i < numDust; i++) {
                dustMotes.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: 0.5 + Math.random() * 1.5,
                    alpha: 0.08 + Math.random() * 0.15,
                    speed: 0.08 + Math.random() * 0.15,
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.008 + Math.random() * 0.015
                });
            }
        }

        function updateAmbientParticles() {
            for (const dust of dustMotes) {
                dust.wobble += dust.wobbleSpeed;
                dust.y -= dust.speed * 0.3;
                dust.x += Math.sin(dust.wobble) * 0.25;
                if (dust.y < -10) {
                    dust.y = height + 10;
                    dust.x = Math.random() * width;
                }
            }
        }

        function drawAmbientParticles() {
            for (const dust of dustMotes) {
                const gradient = ctx.createRadialGradient(dust.x, dust.y, 0, dust.x, dust.y, dust.size * 2);
                gradient.addColorStop(0, `rgba(255, 250, 220, ${dust.alpha})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ===========================================
        // GRASS SYSTEM - Reduced density
        // ===========================================

        let grassClusters = [];

        function generateGrass() {
            grassClusters = [];
            const numClusters = Math.floor((width * height) / 50000); // Reduced from 25000

            for (let i = 0; i < numClusters; i++) {
                const clusterX = Math.random() * width;
                const clusterY = Math.random() * height;

                const distToNest = Math.hypot(clusterX - CONFIG.nestX, clusterY - CONFIG.nestY);
                if (distToNest < CONFIG.nestRadius * 3) continue;

                const cluster = {
                    x: clusterX,
                    y: clusterY,
                    blades: []
                };

                const numBlades = 4 + Math.floor(Math.random() * 5); // Reduced blades per cluster
                for (let j = 0; j < numBlades; j++) {
                    cluster.blades.push({
                        offsetX: (Math.random() - 0.5) * 15,
                        offsetY: (Math.random() - 0.5) * 6,
                        height: 12 + Math.random() * 20,
                        width: 1.5 + Math.random() * 1,
                        curve: (Math.random() - 0.5) * 0.5,
                        phase: Math.random() * Math.PI * 2,
                        swaySpeed: 0.012 + Math.random() * 0.008,
                        swayAmount: 0.015 + Math.random() * 0.02,
                        color: `hsl(${95 + Math.random() * 25}, ${35 + Math.random() * 20}%, ${28 + Math.random() * 15}%)`
                    });
                }

                grassClusters.push(cluster);
            }
        }

        function drawGrass() {
            for (const cluster of grassClusters) {
                for (const blade of cluster.blades) {
                    const x = cluster.x + blade.offsetX;
                    const y = cluster.y + blade.offsetY;
                    const sway = Math.sin(time * blade.swaySpeed + blade.phase) * blade.swayAmount * blade.height;

                    ctx.save();
                    ctx.strokeStyle = blade.color;
                    ctx.lineWidth = blade.width;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    const cp1x = x + blade.curve * blade.height * 0.5 + sway * 0.3;
                    const cp1y = y - blade.height * 0.5;
                    const cp2x = x + blade.curve * blade.height + sway;
                    const cp2y = y - blade.height * 0.85;
                    const endX = x + blade.curve * blade.height * 1.2 + sway * 1.2;
                    const endY = y - blade.height;

                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        // ===========================================
        // FOREST FLOOR - Reduced clutter
        // ===========================================

        let forestElements = [];

        function generateForestElements() {
            forestElements = [];
            const numElements = Math.floor((width * height) / 30000); // Reduced from 12000

            for (let i = 0; i < numElements; i++) {
                const type = Math.random();
                let element;

                if (type < 0.4) {
                    // Fallen leaf
                    element = {
                        type: 'leaf',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 8 + Math.random() * 12,
                        rotation: Math.random() * Math.PI * 2,
                        color: ['#5a6040', '#6b7050', '#4a5535', '#7a8560'][Math.floor(Math.random() * 4)],
                        alpha: 0.3 + Math.random() * 0.25
                    };
                } else if (type < 0.7) {
                    // Pebble
                    element = {
                        type: 'pebble',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 2 + Math.random() * 4,
                        color: ['#4a4840', '#5a5850', '#3a3835', '#6a6860'][Math.floor(Math.random() * 4)],
                        alpha: 0.4 + Math.random() * 0.25
                    };
                } else {
                    // Twig
                    element = {
                        type: 'twig',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        length: 15 + Math.random() * 25,
                        rotation: Math.random() * Math.PI,
                        thickness: 1 + Math.random() * 1.5,
                        color: '#4d3a2a',
                        alpha: 0.35 + Math.random() * 0.2
                    };
                }

                const distToNest = Math.hypot(element.x - CONFIG.nestX, element.y - CONFIG.nestY);
                if (distToNest > CONFIG.nestRadius * 2.5) {
                    forestElements.push(element);
                }
            }
        }

        function drawForestElement(el) {
            ctx.save();
            ctx.globalAlpha = el.alpha;

            switch (el.type) {
                case 'leaf':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, el.size * 0.35, el.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -el.size * 0.4);
                    ctx.lineTo(0, el.size * 0.4);
                    ctx.stroke();
                    break;

                case 'pebble':
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(el.x, el.y, el.size, el.size * 0.65, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'twig':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.strokeStyle = el.color;
                    ctx.lineWidth = el.thickness;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-el.length / 2, 0);
                    ctx.lineTo(el.length / 2, 0);
                    ctx.stroke();
                    break;
            }

            ctx.restore();
        }

        // ===========================================
        // PHEROMONE GRID
        // ===========================================

        let pheromoneGrid = { food: null, home: null, cols: 0, rows: 0 };

        function initPheromoneGrid() {
            const cellSize = CONFIG.pheromoneGridSize;
            pheromoneGrid.cols = Math.ceil(width / cellSize);
            pheromoneGrid.rows = Math.ceil(height / cellSize);
            const size = pheromoneGrid.cols * pheromoneGrid.rows;
            pheromoneGrid.food = new Float32Array(size);
            pheromoneGrid.home = new Float32Array(size);
        }

        function getPheromoneIndex(x, y) {
            const col = Math.floor(x / CONFIG.pheromoneGridSize);
            const row = Math.floor(y / CONFIG.pheromoneGridSize);
            if (col < 0 || col >= pheromoneGrid.cols || row < 0 || row >= pheromoneGrid.rows) return -1;
            return row * pheromoneGrid.cols + col;
        }

        function depositPheromone(x, y, type, amount) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return;
            const grid = type === 'food' ? pheromoneGrid.food : pheromoneGrid.home;
            // Apply pheromone strength upgrade multiplier
            const effectiveAmount = amount * upgradeMultipliers.pheromoneStrength;
            grid[idx] = Math.min(grid[idx] + effectiveAmount, CONFIG.pheromoneMax);
        }

        function getPheromone(x, y, type) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return 0;
            return (type === 'food' ? pheromoneGrid.food : pheromoneGrid.home)[idx];
        }

        function samplePheromoneDirection(x, y, currentAngle, type) {
            const sampleDist = 15;
            const sampleAngle = 0.5;
            const left = getPheromone(x + Math.cos(currentAngle - sampleAngle) * sampleDist, y + Math.sin(currentAngle - sampleAngle) * sampleDist, type);
            const center = getPheromone(x + Math.cos(currentAngle) * sampleDist, y + Math.sin(currentAngle) * sampleDist, type);
            const right = getPheromone(x + Math.cos(currentAngle + sampleAngle) * sampleDist, y + Math.sin(currentAngle + sampleAngle) * sampleDist, type);

            if (center >= left && center >= right) return 0;
            return (left > right ? -1 : 1) * sampleAngle * CONFIG.pheromoneFollowStrength;
        }

        function decayPheromones() {
            const decay = CONFIG.pheromoneDecay;
            for (let i = 0; i < pheromoneGrid.food.length; i++) {
                pheromoneGrid.food[i] *= decay;
                pheromoneGrid.home[i] *= decay;
                if (pheromoneGrid.food[i] < 0.01) pheromoneGrid.food[i] = 0;
                if (pheromoneGrid.home[i] < 0.01) pheromoneGrid.home[i] = 0;
            }
        }

        // ===========================================
        // PREDATORS (Spider, Beetle)
        // ===========================================

        // Helper to get all predators as a flat array
        function getAllPredators() {
            return [...spiderPredators, ...beetlePredators];
        }

        // Helper to get predators with their type key (for card display)
        function getAllPredatorsWithKeys() {
            const result = [];
            for (const p of spiderPredators) result.push({ predator: p, key: 'spider' });
            for (const p of beetlePredators) result.push({ predator: p, key: 'beetle' });
            return result;
        }

        // Attack an ant - uses Pokemon-style damage calculation
        function attackAnt(ant, predator) {
            // Get predator's attack power
            const attackPower = predator.atk || 10;

            // Ant takes damage and automatically retaliates (fights back)
            const survived = ant.takeDamage(attackPower, predator);

            if (!survived) {
                // Ant is killed - spawn death effect
                spawnDeathEffect(ant.x, ant.y, 'ant', ant.color);

                const idx = ants.indexOf(ant);
                if (idx !== -1) {
                    ants.splice(idx, 1);

                    // Track death for Berserker skill (decays over time)
                    CONFIG.recentDeaths++;
                    CONFIG.deathDecayTimer = 600;  // 10 seconds of rage
                }
                return true;  // Ant died
            }

            // Ant survived the hit - give it a panic response
            ant.panicTimer = 60;
            return false;  // Ant survived
        }

        // Legacy function name for compatibility
        function killAnt(ant, predator) {
            return attackAnt(ant, predator);
        }

        // Decay recent deaths counter over time
        function updateDeathCounter() {
            if (CONFIG.deathDecayTimer > 0) {
                CONFIG.deathDecayTimer--;
                if (CONFIG.deathDecayTimer <= 0) {
                    CONFIG.recentDeaths = Math.max(0, CONFIG.recentDeaths - 1);
                    if (CONFIG.recentDeaths > 0) {
                        CONFIG.deathDecayTimer = 300;  // Decay one at a time
                    }
                }
            }
        }

        // Active combat: All ants attack nearby predators (1 attack per second)
        function checkAntPredatorCombat() {
            const COMBAT_RANGE = 20;  // How close an ant needs to be to attack
            const ATTACK_COOLDOWN = 60;  // 60 frames = 1 second at 60fps
            const FIGHTING_DURATION = 60;  // 1 second - refreshes on each hit so they stay still while fighting

            // Combine all predators into one array
            const allPredators = [...spiderPredators, ...beetlePredators];

            for (const ant of ants) {
                // Skip ants that are in the hive resting
                if (ant.hiveRestTimer > 0) continue;

                // Skip ants that are busy or panicking
                if (ant.panicTimer > 0) continue;

                // Check attack cooldown (1 attack per second)
                if (time - ant.lastAttackTime < ATTACK_COOLDOWN) continue;

                for (const predator of allPredators) {
                    // Skip stunned or dead predators
                    if (predator.state === 'stunned' || predator.state === 'dead') continue;

                    const dist = Math.hypot(ant.x - predator.x, ant.y - predator.y);

                    if (dist < COMBAT_RANGE) {
                        // Both ant and predator stop to fight
                        ant.fightingTimer = FIGHTING_DURATION;
                        predator.fightingTimer = FIGHTING_DURATION;

                        // Face each other
                        ant.angle = Math.atan2(predator.y - ant.y, predator.x - ant.x);
                        predator.angle = Math.atan2(ant.y - predator.y, ant.x - predator.x);

                        // Ant is in combat range - deal damage!
                        const antAtk = ant.getEffectiveAtk();

                        if (antAtk > 0 && predator.currentHp !== undefined) {
                            const damageDealt = Math.max(1, antAtk - (predator.def || 0));
                            predator.currentHp -= damageDealt;

                            // Record attack time for cooldown
                            ant.lastAttackTime = time;

                            // Predator counter-attacks! (if not on its own cooldown)
                            let predatorDamage = 0;
                            if (time - (predator.lastAttackTime || 0) >= 60) {
                                predator.lastAttackTime = time;
                                const predatorAtk = predator.atk || 10;
                                const antDef = ant.getEffectiveDef();
                                predatorDamage = Math.max(1, predatorAtk - antDef);
                                ant.currentHp -= predatorDamage;

                                // Check if ant died from counter-attack
                                if (ant.currentHp <= 0) {
                                    spawnDeathEffect(ant.x, ant.y, 'ant', ant.color);
                                    const idx = ants.indexOf(ant);
                                    if (idx !== -1) {
                                        ants.splice(idx, 1);
                                        CONFIG.recentDeaths++;
                                        CONFIG.deathDecayTimer = 600;
                                    }
                                }
                            }

                            // Spawn combat effect
                            const midX = (ant.x + predator.x) / 2;
                            const midY = (ant.y + predator.y) / 2;
                            spawnCombatEffect(midX, midY, Math.max(0, ant.currentHp), ant.maxHp, Math.max(0, predator.currentHp), predator.maxHp);
                            spawnFloatingText(predator.x, predator.y - 15, `-${damageDealt}`, '#00ff88', 11);
                            if (predatorDamage > 0) {
                                spawnFloatingText(ant.x, ant.y - 15, `-${predatorDamage}`, '#ff4444', 11);
                            }

                            // Check if predator is killed - remove from game permanently
                            if (predator.currentHp <= 0) {
                                removePredator(predator);
                            }

                            // Only attack one predator per cooldown
                            break;
                        }
                    }
                }
            }
        }

        // Remove a predator from the game permanently
        function removePredator(predator) {
            // Spawn death effect before removing
            const predatorColor = predator.color || { r: 100, g: 80, b: 60 };
            spawnDeathEffect(predator.x, predator.y, 'predator', predatorColor);

            predator.state = 'dead';

            // GOLD FROM ENEMY KILLS - determine gold drop based on predator type
            let goldDrop = 0;
            const spiderIdx = spiderPredators.indexOf(predator);
            if (spiderIdx !== -1) {
                // Spider drops 3-5 gold
                goldDrop = 3 + Math.floor(Math.random() * 3);
                spiderPredators.splice(spiderIdx, 1);
            } else {
                const beetleIdx = beetlePredators.indexOf(predator);
                if (beetleIdx !== -1) {
                    // Beetle drops 5-8 gold
                    goldDrop = 5 + Math.floor(Math.random() * 4);
                    beetlePredators.splice(beetleIdx, 1);
                }
            }

            // Award gold and show floating text
            if (goldDrop > 0) {
                // Check for Gold Hunter ability on any ant
                const hasGoldHunter = ants.some(ant => ant.harvestAbilities && ant.harvestAbilities.includes('goldHunter'));
                if (hasGoldHunter) {
                    goldDrop += 2;  // Gold Hunter bonus
                }
                earnCoins(goldDrop);
                spawnFloatingText(predator.x, predator.y - 20, `+${goldDrop}g`, '#ffd700', 14);
            }
        }

        // Trailblazer beacons for Scout skill
        let trailblazerBeacons = [];

        function addTrailblazerBeacon(x, y, food) {
            trailblazerBeacons.push({
                x: x,
                y: y,
                food: food,
                timer: 300,  // 5 seconds
                pulsePhase: 0
            });
        }

        function updateTrailblazerBeacons() {
            for (let i = trailblazerBeacons.length - 1; i >= 0; i--) {
                const beacon = trailblazerBeacons[i];
                beacon.timer--;
                beacon.pulsePhase += 0.15;

                if (beacon.timer <= 0) {
                    trailblazerBeacons.splice(i, 1);
                    continue;
                }

                // Attract nearby ants toward the beacon
                for (const ant of ants) {
                    if (ant.type === 'soldier') continue;  // Soldiers ignore
                    if (ant.state !== 'exploring') continue;

                    const dist = Math.hypot(ant.x - beacon.x, ant.y - beacon.y);
                    if (dist < 150 && dist > 20) {
                        // Gently guide ants toward beacon
                        const angleToBeacon = Math.atan2(beacon.y - ant.y, beacon.x - ant.x);
                        const influence = 0.02 * (1 - dist / 150);
                        ant.angle += ant.angleDiff(angleToBeacon, ant.angle) * influence;
                    }
                }
            }
        }

        function drawTrailblazerBeacons() {
            for (const beacon of trailblazerBeacons) {
                const alpha = Math.min(1, beacon.timer / 60);
                const pulse = Math.sin(beacon.pulsePhase) * 0.3 + 0.7;

                ctx.save();

                // Outer glow rings
                for (let r = 3; r >= 1; r--) {
                    const radius = 20 + r * 15 + Math.sin(beacon.pulsePhase - r * 0.5) * 5;
                    ctx.beginPath();
                    ctx.arc(beacon.x, beacon.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * 0.15 * pulse / r})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Inner beacon
                ctx.beginPath();
                ctx.arc(beacon.x, beacon.y, 8 + pulse * 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha * 0.6 * pulse})`;
                ctx.fill();

                // Center bright spot
                ctx.beginPath();
                ctx.arc(beacon.x, beacon.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * pulse})`;
                ctx.fill();

                ctx.restore();
            }
        }

        class Spider {
            constructor() {
                const cfg = CONFIG.predators.spider;
                this.x = cfg.x;
                this.y = cfg.y;
                this.targetX = this.x;
                this.targetY = this.y;
                this.angle = Math.random() * Math.PI * 2;
                this.size = 18;
                this.speed = cfg.speed;
                this.legPhase = 0;
                this.state = 'hunting';
                this.eatTimer = 0;
                this.stunTimer = 0;
                this.lastAttackTime = 0;  // For 1 attack per second cooldown
                this.fightingTimer = 0;   // Timer for standing still during combat

                // Pokemon-style stats
                this.maxHp = cfg.hp;
                this.currentHp = cfg.hp;
                this.atk = cfg.atk;
                this.def = cfg.def;
            }

            stun(duration) {
                this.stunTimer = duration;
                this.state = 'stunned';
                // Note: No more respawn on death - predators are removed permanently
            }

            update() {
                // If fighting, decrement timer and skip movement
                if (this.fightingTimer > 0) {
                    this.fightingTimer--;
                    this.legPhase += 0.3;  // Still animate legs
                    return;
                }

                const cfg = CONFIG.predators.spider;
                this.legPhase += 0.2;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) this.state = 'hunting';
                    return;
                }

                if (this.state === 'eating') {
                    this.eatTimer--;
                    if (this.eatTimer <= 0) this.state = 'hunting';
                    return;
                }

                // Find nearest ant anywhere on the map
                let nearestAnt = null;
                let nearestDist = cfg.huntRadius;

                for (const ant of ants) {
                    const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestAnt = ant;
                    }
                }

                if (nearestAnt) {
                    this.targetX = nearestAnt.x;
                    this.targetY = nearestAnt.y;

                    // Check attack cooldown (1 attack per second = 60 frames)
                    if (nearestDist < cfg.killRadius && time - this.lastAttackTime >= 60) {
                        this.lastAttackTime = time;
                        if (killAnt(nearestAnt, this)) {
                            this.state = 'eating';
                            this.eatTimer = 60;
                        }
                    }
                } else {
                    // Wander freely across the entire map - pick new target frequently
                    const distToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                    if (Math.random() < 0.02 || distToTarget < 30) {
                        const margin = 50;
                        this.targetX = margin + Math.random() * (width - margin * 2);
                        this.targetY = margin + Math.random() * (height - margin * 2);
                    }
                }

                // Move toward target freely
                const angleToTarget = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                this.angle = angleToTarget;

                let newX = this.x + Math.cos(this.angle) * this.speed;
                let newY = this.y + Math.sin(this.angle) * this.speed;

                // Keep within screen bounds
                const margin = 20;
                newX = Math.max(margin, Math.min(width - margin, newX));
                newY = Math.max(margin, Math.min(height - margin, newY));

                this.x = newX;
                this.y = newY;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.3;

                // Stun effect
                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(3, 3, s * 0.8, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.strokeStyle = '#1a1008';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 4; i++) {
                        const attachY = -s * 0.3 + i * s * 0.2;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.2, attachY);
                        ctx.lineTo(side * s * 0.7, attachY - s * 0.2 + phase * s * 0.15);
                        ctx.lineTo(side * s * 0.9, attachY + s * 0.3 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Abdomen
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.3, s * 0.45, s * 0.55, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#3a2a18';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.2, s * 0.2, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.25, s * 0.3, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#400808';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 80, 80, 0.5)';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.fill();

                if (this.state === 'eating') {
                    ctx.fillStyle = 'rgba(200, 50, 50, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, -s * 0.55, s * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.6;
                        const y = Math.sin(angle) * s * 0.6 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }

            reset() {
                const cfg = CONFIG.predators.spider;
                this.x = cfg.x;
                this.y = cfg.y;
                this.targetX = this.x;
                this.targetY = this.y;
                this.angle = Math.random() * Math.PI * 2;
                this.state = 'hunting';
                this.eatTimer = 0;
                this.stunTimer = 0;
            }
        }

        class Beetle {
            constructor() {
                const cfg = CONFIG.predators.beetle;
                this.x = cfg.x;
                this.y = cfg.y;
                this.angle = Math.random() * Math.PI * 2;
                this.targetX = cfg.x;
                this.targetY = cfg.y;
                this.size = 22;
                this.legPhase = 0;
                this.state = 'patrolling';
                this.stunTimer = 0;
                this.wanderTimer = 0;
                this.lastAttackTime = 0;  // For 1 attack per second cooldown
                this.fightingTimer = 0;   // Timer for standing still during combat

                // Pokemon-style stats
                this.maxHp = cfg.hp;
                this.currentHp = cfg.hp;
                this.atk = cfg.atk;
                this.def = cfg.def;
            }

            stun(duration) {
                this.stunTimer = duration;
                this.state = 'stunned';
                // Note: No more respawn on death - predators are removed permanently
            }

            update() {
                // If fighting, decrement timer and skip movement
                if (this.fightingTimer > 0) {
                    this.fightingTimer--;
                    this.legPhase += 0.15;  // Still animate legs
                    return;
                }

                const cfg = CONFIG.predators.beetle;
                this.legPhase += 0.12;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) this.state = 'patrolling';
                    return;
                }

                // Find nearest ant to chase
                let nearestAnt = null;
                let nearestDist = cfg.huntRadius || 300;
                for (const ant of ants) {
                    const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestAnt = ant;
                    }
                }

                if (nearestAnt) {
                    // Chase the ant
                    this.targetX = nearestAnt.x;
                    this.targetY = nearestAnt.y;
                } else {
                    // Random wandering patrol across the entire map
                    this.wanderTimer--;
                    const distToTarget = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                    if (this.wanderTimer <= 0 || distToTarget < 30) {
                        // Pick a new random target anywhere on the map
                        const margin = 50;
                        this.targetX = margin + Math.random() * (width - margin * 2);
                        this.targetY = margin + Math.random() * (height - margin * 2);
                        this.wanderTimer = 60 + Math.random() * 120;  // New target every 1-3 seconds
                    }
                }

                // Move toward target
                const angleToTarget = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                this.angle = angleToTarget;

                let newX = this.x + Math.cos(this.angle) * cfg.patrolSpeed;
                let newY = this.y + Math.sin(this.angle) * cfg.patrolSpeed;

                // Keep within screen bounds
                const margin = 20;
                this.x = Math.max(margin, Math.min(width - margin, newX));
                this.y = Math.max(margin, Math.min(height - margin, newY));

                // Kill ants in radius (1 attack per second)
                if (time - this.lastAttackTime >= 60) {
                    for (let i = ants.length - 1; i >= 0; i--) {
                        const ant = ants[i];
                        if (Math.hypot(ant.x - this.x, ant.y - this.y) < cfg.killRadius) {
                            this.lastAttackTime = time;
                            killAnt(ant, this);
                            break;  // Only attack one ant per cooldown
                        }
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.2;

                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(4, 4, s * 0.7, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs (6 legs, 3 per side)
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 3; i++) {
                        const attachY = -s * 0.2 + i * s * 0.25;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.3, attachY);
                        ctx.lineTo(side * s * 0.6, attachY - s * 0.1 + phase * s * 0.1);
                        ctx.lineTo(side * s * 0.75, attachY + s * 0.15 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Shell (elytra)
                ctx.fillStyle = '#2a3520';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.1, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Shell line
                ctx.strokeStyle = '#1a2510';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.4);
                ctx.lineTo(0, s * 0.6);
                ctx.stroke();

                // Shell highlights
                ctx.fillStyle = '#3a4530';
                ctx.beginPath();
                ctx.ellipse(-s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#1a2010';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.55, s * 0.3, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mandibles
                ctx.strokeStyle = '#2a1010';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s * 0.15, -s * 0.7);
                ctx.lineTo(-s * 0.25, -s * 0.85);
                ctx.moveTo(s * 0.15, -s * 0.7);
                ctx.lineTo(s * 0.25, -s * 0.85);
                ctx.stroke();

                // Antennae
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-s * 0.1, -s * 0.65);
                ctx.lineTo(-s * 0.2, -s * 0.9);
                ctx.lineTo(-s * 0.15, -s * 1.0);
                ctx.moveTo(s * 0.1, -s * 0.65);
                ctx.lineTo(s * 0.2, -s * 0.9);
                ctx.lineTo(s * 0.15, -s * 1.0);
                ctx.stroke();

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.5;
                        const y = Math.sin(angle) * s * 0.5 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }

            reset() {
                const cfg = CONFIG.predators.beetle;
                this.x = cfg.x;
                this.y = cfg.y;
                this.angle = Math.random() * Math.PI * 2;
                this.targetX = cfg.x;
                this.targetY = cfg.y;
                this.state = 'patrolling';
                this.stunTimer = 0;
                this.wanderTimer = 0;
            }
        }

        // ===========================================
        // FOOD ITEMS
        // ===========================================

        let foodItems = [];
        let foodCollected = 0;

        // ===========================================
        // FOOD REWORK - LEVELING & CYCLE SYSTEM
        // ===========================================

        // Food levels persist between placements (Lv.1 to Lv.10)
        const foodLevels = {
            sugar: 1,
            protein: 1,
            fruit: 1,
            feast: 1,
            nectar: 1,
            goldenApple: 1
        };

        // Accumulated bonuses during current cycle (reset each minute)
        const accumulatedBonuses = {
            hp: 0,
            atk: 0,
            def: 0,
            carry: 0,
            abilities: []  // Lv.10 abilities earned this cycle
        };

        // Food types and their bonuses
        const FOOD_BONUSES = {
            sugar: { stat: 'hp', perUnit: 1, ability: 'goldHunter', abilityName: 'Gold Hunter', abilityDesc: '+2g per kill' },
            protein: { stat: 'atk', perUnit: 1, ability: 'lifesteal', abilityName: 'Lifesteal', abilityDesc: 'Heal on hit' },
            fruit: { stat: 'carry', perUnit: 1, ability: 'freshKeeper', abilityName: 'Fresh Keeper', abilityDesc: 'Food timer pauses while carrying' },
            feast: { stat: 'def', perUnit: 1, ability: 'thorns', abilityName: 'Thorns', abilityDesc: 'Reflect damage' },
            nectar: { stat: 'hp', perUnit: 1, ability: 'regeneration', abilityName: 'Regeneration', abilityDesc: '1 HP/5sec' },
            goldenApple: { stat: 'all', perUnit: 1, ability: 'champion', abilityName: 'Champion', abilityDesc: 'All abilities' }
        };

        // Track food delivered this cycle for harvest summary
        let cycleDeliveries = [];  // { foodType, units, zoneMultiplier }

        // Cycle timer (60 seconds = spawn new ant)
        const CYCLE_DURATION = 60000;  // 60 seconds in ms
        let cycleStartTime = null;
        let lastCycleTime = null;

        // Track which zone is occupied by food
        const zoneOccupied = new Map();  // Map<spotIndex, foodItem>

        // Track ant spawn counts for scaling costs
        let antSpawnCounts = { worker: 0, soldier: 0, scout: 0, carrier: 0, queen: 0 };

        function getAntSpawnCost(antType) {
            const base = CONFIG.antSpawnCosts[antType].baseCost;
            const count = antSpawnCounts[antType];
            // Cost increases by 20% for each ant of that type spawned, reduced by upgrades
            return Math.floor(base * Math.pow(1.2, count) * upgradeMultipliers.spawnCostReduction);
        }

        function spawnAnt(antType) {
            const cost = getAntSpawnCost(antType);
            if (!canAfford(cost)) return false;
            if (ants.length >= CONFIG.maxAnts) return false;
            if (gameOver) return false;

            spendCoins(cost);
            antSpawnCounts[antType]++;
            totalAntsSpawned++;

            const angle = Math.random() * Math.PI * 2;
            const spawnDist = getColonySize() * 0.3;
            const newAnt = new Ant(
                CONFIG.nestX + Math.cos(angle) * spawnDist,
                CONFIG.nestY + Math.sin(angle) * spawnDist,
                antType
            );
            ants.push(newAnt);
            addSpawnNotification(antType);
            updateAntCosts();
            return true;
        }

        function updateAntCosts() {
            for (const antType in CONFIG.antSpawnCosts) {
                const costEl = document.getElementById(`${antType}-cost`);
                if (costEl) {
                    costEl.textContent = getAntSpawnCost(antType);
                }
            }
        }

        const FOOD_LIFETIME_SECONDS = 60;  // 60 seconds until food spoils

        class FoodItem {
            constructor(x, y, type, zoneSpot = null) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = Math.random().toString(36).substr(2, 9);  // Unique ID for tracking
                const config = CONFIG.foodTypes[type];

                // Size is based on the food's current level (units = level)
                const foodLevel = foodLevels[type] || 1;
                this.size = foodLevel;  // Current size (units of food remaining)
                this.maxSize = foodLevel;  // Original size = level
                this.level = foodLevel;  // Store the level for reference
                this.baseRadius = config.baseRadius;
                this.valuePerUnit = 0;  // No gold value - gold comes from kills
                this.name = config.name;
                this.emoji = config.emoji;
                this.carriers = [];
                this.inDangerZone = isInDangerZone(x, y);
                this.zoneMultiplier = getFoodZoneMultiplier(x, y);  // Distance-based multiplier (x1, x2, x3)
                this.zoneSpot = zoneSpot;  // Reference to the zone spot this food is in
                this.spawnTime = Date.now();
                this.unitsDelivered = 0;  // Track how many units have been successfully delivered
            }

            update() {
                // Food no longer spoils - it stays until fully delivered
            }

            getTimeRemaining() {
                // Food doesn't expire anymore
                return 999;
            }

            getRadius() {
                // Radius scales with sqrt of remaining size, with min size
                const ratio = Math.max(0.3, this.size / this.maxSize);
                return this.baseRadius * Math.sqrt(ratio);
            }

            getValue() {
                // No gold value in new system - gold comes from kills only
                return 0;
            }

            // Called when food is fully delivered - respawns with leveled up food
            onFullyDelivered() {
                // Level up based on zone multiplier (x1 = +1, x2 = +2, x3 = +3)
                const levelGain = this.zoneMultiplier;
                const oldLevel = foodLevels[this.type];
                foodLevels[this.type] = Math.min(10, foodLevels[this.type] + levelGain);
                const newLevel = foodLevels[this.type];

                if (newLevel > oldLevel) {
                    spawnFloatingText(this.x, this.y - 20, `${this.emoji} Lv.${newLevel}!`, '#00ff88', 14);
                }

                // Check for Lv.10 ability unlock
                if (newLevel >= 10 && oldLevel < 10) {
                    const bonus = FOOD_BONUSES[this.type];
                    if (bonus && bonus.ability) {
                        spawnFloatingText(this.x, this.y - 40, `${bonus.abilityName}!`, '#ffd700', 16);
                    }
                }

                // Schedule respawn of this food at the same spot
                const respawnX = this.x;
                const respawnY = this.y;
                const respawnType = this.type;
                const respawnSpot = this.zoneSpot;

                // Clear zone occupation temporarily
                if (this.zoneSpot !== null) {
                    zoneOccupied.delete(this.zoneSpot);
                }

                // Respawn food after a short delay (1 second)
                setTimeout(() => {
                    respawnFoodAtZone(respawnSpot, respawnType, respawnX, respawnY);
                }, 1000);
            }

            // Single ant can always carry 1 unit
            canTakeUnit() {
                return this.size >= 1;
            }

            takeUnit() {
                if (this.size < 1) return 0;
                this.size -= 1;
                return 1;
            }

            isEmpty() {
                return this.size < 1;
            }

            addCarrier(ant) {
                if (!this.carriers.includes(ant)) this.carriers.push(ant);
            }

            removeCarrier(ant) {
                const idx = this.carriers.indexOf(ant);
                if (idx !== -1) this.carriers.splice(idx, 1);
            }

            draw() {
                const r = this.getRadius();
                if (r < 3) return;  // Too small to draw

                const foodConfig = CONFIG.foodTypes[this.type];
                const isRare = foodConfig.isRare || false;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow (offset more so it doesn't darken the emoji)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(3, 5, r * 0.9, r * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Zone-based glow behind emoji (or special glow for rare food)
                const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.2);
                if (isRare) {
                    // Golden sparkle glow for rare food
                    const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;
                    const gc = foodConfig.glowColor;
                    glowGrad.addColorStop(0, `rgba(${gc.r}, ${gc.g}, ${gc.b}, ${0.8 * pulse})`);
                    glowGrad.addColorStop(0.5, `rgba(${gc.r}, ${gc.g}, ${gc.b}, ${0.4 * pulse})`);
                    glowGrad.addColorStop(1, 'transparent');
                } else if (this.inDangerZone) {
                    // Golden/amber glow for danger zone food
                    glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.5)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 180, 50, 0.2)');
                    glowGrad.addColorStop(1, 'transparent');
                } else {
                    // Green glow for safe zone food
                    glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.4)');
                    glowGrad.addColorStop(0.5, 'rgba(100, 230, 130, 0.15)');
                    glowGrad.addColorStop(1, 'transparent');
                }
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2);
                ctx.fill();

                // Sparkle effect for rare food
                if (isRare) {
                    const sparkleCount = 4;
                    for (let i = 0; i < sparkleCount; i++) {
                        const angle = (Date.now() / 500 + i * Math.PI * 2 / sparkleCount) % (Math.PI * 2);
                        const sparkleR = r * 1.3;
                        const sx = Math.cos(angle) * sparkleR;
                        const sy = Math.sin(angle) * sparkleR;
                        const sparkleSize = 3 + Math.sin(Date.now() / 150 + i) * 1.5;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(sx, sy, sparkleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw emoji scaled to size
                const fontSize = Math.max(14, r * 2);
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);

                // Size indicator (units remaining)
                if (this.size > 1) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(r * 0.8, -r * 0.6, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px "DM Mono", monospace';
                    ctx.fillText(Math.floor(this.size), r * 0.8, -r * 0.6);
                }

                // "RARE!" indicator for rare food
                if (isRare) {
                    const bounce = Math.sin(Date.now() / 300) * 3;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 10px "DM Mono", monospace';
                    ctx.fillText('RARE!', 0, -r - 8 + bounce);
                }

                ctx.restore();
            }
        }

        // Food piece that an ant carries - tracks source food for spoilage and zone
        class CarriedFoodPiece {
            constructor(type, sourceFoodId, fromDangerZone, zoneMultiplier = 1, sourceFood = null) {
                this.type = type;
                this.emoji = CONFIG.foodTypes[type].emoji;
                this.sourceFoodId = sourceFoodId;  // Track which food this came from
                this.fromDangerZone = fromDangerZone;  // Track zone for glow color
                this.zoneMultiplier = zoneMultiplier;  // Zone multiplier (x1, x2, x3)
                this.sourceFood = sourceFood;  // Reference to source FoodItem for delivery tracking
            }
        }

        function addFood(x, y, type) {
            // Find the nearest food zone
            let nearestSpot = null;
            let nearestDist = Infinity;
            let spotIndex = -1;

            for (let i = 0; i < foodSpots.length; i++) {
                const spot = foodSpots[i];
                const dist = Math.hypot(x - spot.x, y - spot.y);
                if (dist < spot.radius && dist < nearestDist) {
                    nearestDist = dist;
                    nearestSpot = spot;
                    spotIndex = i;
                }
            }

            // Must be in a food zone
            if (!nearestSpot) return false;

            // Check if zone is already occupied
            if (zoneOccupied.has(spotIndex)) {
                spawnFloatingText(x, y, 'Zone occupied!', '#ff6b6b', 10);
                return false;
            }

            // Snap food to zone center (FREE - no cost!)
            const food = new FoodItem(nearestSpot.x, nearestSpot.y, type, spotIndex);
            foodItems.push(food);

            // Mark zone as occupied
            zoneOccupied.set(spotIndex, food);

            // Show level indicator
            const level = foodLevels[type] || 1;
            spawnFloatingText(nearestSpot.x, nearestSpot.y - 30, `Lv.${level}`, '#00ff88', 12);

            return true;
        }

        // Food types assigned to each zone (by zone index after sorting by distance)
        // Closest zones get simpler foods, farther zones get better foods
        const ZONE_FOOD_TYPES = ['sugar', 'protein', 'fruit', 'feast', 'nectar'];

        // Respawn food at a specific zone
        function respawnFoodAtZone(zoneIndex, foodType, x, y) {
            if (zoneOccupied.has(zoneIndex)) return;  // Already occupied

            const food = new FoodItem(x, y, foodType, zoneIndex);
            foodItems.push(food);
            zoneOccupied.set(zoneIndex, food);
        }

        // Initialize food in all zones at game start
        function initFoodInZones() {
            // Clear any existing food
            foodItems.length = 0;
            zoneOccupied.clear();

            // Sort food spots by distance from nest (closest first)
            const sortedSpots = foodSpots.map((spot, index) => ({
                spot: spot,
                index: index,
                distance: Math.hypot(spot.x - CONFIG.nestX, spot.y - CONFIG.nestY)
            })).sort((a, b) => a.distance - b.distance);

            // Spawn food in each zone with assigned type
            for (let i = 0; i < sortedSpots.length && i < ZONE_FOOD_TYPES.length; i++) {
                const { spot, index } = sortedSpots[i];
                const foodType = ZONE_FOOD_TYPES[i];

                // Store the food type assignment on the spot for reference
                spot.assignedFoodType = foodType;

                const food = new FoodItem(spot.x, spot.y, foodType, index);
                foodItems.push(food);
                zoneOccupied.set(index, food);
            }
        }

        // ===========================================
        // ANTS
        // ===========================================

        let ants = [];
        let antIdCounter = 0;
        let selectedAnt = null;  // Currently selected ant for character card
        let selectedPredator = null;  // Currently selected predator for character card
        let selectedPredatorKey = null;  // Key for the selected predator (spider/beetle)

        // Ant name generator - normal human names
        const ANT_NAMES = [
            'Gustav', 'Anja', 'Erik', 'Marta', 'Felix', 'Lena', 'Otto', 'Hilda',
            'Bruno', 'Ingrid', 'Karl', 'Freya', 'Hans', 'Greta', 'Fritz', 'Elsa',
            'Max', 'Anna', 'Klaus', 'Liesel', 'Hugo', 'Heidi', 'Emil', 'Rosa',
            'Theo', 'Klara', 'Oscar', 'Maja', 'Lars', 'Petra', 'Nils', 'Vera',
            'Axel', 'Ida', 'Sven', 'Tilda', 'Rolf', 'Britta', 'Lukas', 'Sonja',
            'Kasper', 'Astrid', 'Johan', 'Sigrid', 'Anders', 'Helga', 'Olaf', 'Inga',
            'Finn', 'Linnea', 'Magnus', 'Ylva', 'Bjorn', 'Saga', 'Leif', 'Freja',
            'Henrik', 'Ebba', 'Stefan', 'Alma', 'Viktor', 'Nova', 'Anton', 'Wilma'
        ];
        let usedNames = new Set();

        function generateAntName() {
            // Try to get an unused name
            const availableNames = ANT_NAMES.filter(n => !usedNames.has(n));
            if (availableNames.length > 0) {
                const name = availableNames[Math.floor(Math.random() * availableNames.length)];
                usedNames.add(name);
                return name;
            }
            // All names used, add a number suffix
            const baseName = ANT_NAMES[Math.floor(Math.random() * ANT_NAMES.length)];
            let suffix = 2;
            while (usedNames.has(`${baseName} ${suffix}`)) suffix++;
            const fullName = `${baseName} ${suffix}`;
            usedNames.add(fullName);
            return fullName;
        }

        // Trait quality levels based on roll
        function getTraitQuality(roll) {
            if (roll >= 0.95) return { label: 'Legendary', class: 'legendary', multiplier: 1.4 };
            if (roll >= 0.85) return { label: 'Exceptional', class: 'exceptional', multiplier: 1.25 };
            if (roll >= 0.65) return { label: 'Good', class: 'good', multiplier: 1.1 };
            if (roll >= 0.35) return { label: 'Average', class: '', multiplier: 1.0 };
            if (roll >= 0.15) return { label: 'Below Avg', class: 'weak', multiplier: 0.9 };
            return { label: 'Poor', class: 'poor', multiplier: 0.8 };
        }

        // Rank titles based on experience
        function getAntRank(experience) {
            if (experience >= 100) return { title: 'Legendary', class: 'legendary' };
            if (experience >= 50) return { title: 'Veteran', class: 'exceptional' };
            if (experience >= 25) return { title: 'Experienced', class: 'good' };
            if (experience >= 10) return { title: 'Skilled', class: '' };
            if (experience >= 5) return { title: 'Novice', class: 'weak' };
            return { title: 'Rookie', class: 'poor' };
        }

        class Ant {
            constructor(x, y, type = 'worker') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = ++antIdCounter;
                this.name = generateAntName();

                // Individual trait rolls (0-1, higher is better)
                this.traitRolls = {
                    speed: Math.random(),
                    efficiency: Math.random(),
                    detection: Math.random(),
                    resilience: Math.random(),
                    goldBonus: Math.random()  // 0-100% extra gold per delivery
                };

                // Experience tracking
                this.experience = {
                    totalDeliveries: 0,
                    dangerDeliveries: 0,
                    totalValue: 0,
                    predatorEncounters: 0,
                    predatorEscapes: 0,
                    foodDiscovered: 0,      // New: times this ant found food first
                    distanceTraveled: 0     // New: total distance moved
                };

                // Current level (1-5)
                this.level = 1;
                this.hasSkill = false;  // Unlocked at level 3

                // Store type config reference
                this.typeConfig = CONFIG.antTypes[type] || CONFIG.antTypes.worker;

                // Initialize stats (will be recalculated)
                this.recalculateStats();

                // Store starting stats for progress visualization
                this.startingStats = {
                    speed: this.speed,
                    carryCapacity: this.carryCapacity,
                    foodDetectRadius: this.foodDetectRadius,
                    carrySpeedBonus: this.carrySpeedBonus,
                    fightChance: this.fightChance || 0,
                    trailStrength: this.trailStrength || 1,
                    spawnInterval: this.spawnInterval || 900
                };

                this.angle = Math.random() * Math.PI * 2;
                this.state = 'exploring';
                this.targetFood = null;
                this.carriedFoodPiece = null;
                this.carriedFoodValue = 0;
                this.wanderBias = (Math.random() - 0.5) * 0.1;
                this.isScout = type === 'scout';
                this.wanderStrength = this.typeConfig.wanderStrength || CONFIG.wanderStrength;
                this.depositTimer = 0;
                this.foundFoodRecently = false;
                this.legPhase = Math.random() * Math.PI * 2;
                this.colorOffset = Math.floor(Math.random() * 15) - 7;
                this.panicTimer = 0;
                this.lastAttackTime = 0;  // Frame counter for 1 attack per second
                this.fightingTimer = 0;   // Timer for standing still during combat
                this.hiveRestTimer = 0;   // Timer for resting in hive after delivery

                // Soldier-specific properties
                this.targetPredator = null;
                this.escortTarget = null;

                // Queen-specific properties
                this.spawnTimer = 0;
                this.staysNearNest = this.typeConfig.staysNearNest || false;

                // Visual properties
                this.colorConfig = this.typeConfig.color;
                this.accentColor = this.typeConfig.accentColor || this.typeConfig.color;
                this.sizeMultiplier = this.typeConfig.size || 1;

                // Skill-specific state
                this.trailblazerBeacon = null;  // For scout skill
                this.royalAuraTimer = 0;        // For queen skill

                // Position history for glowing trail (level 3+)
                this.positionHistory = [];

                // Active buffs from food delivery effects
                // Each buff: { type, value, endTime, color }
                this.activeBuffs = [];
            }

            // Apply a food delivery buff to this ant
            applyFoodBuff(foodType) {
                const foodConfig = CONFIG.foodTypes[foodType];
                if (!foodConfig || !foodConfig.effect) return { xpBonus: 0, goldMultiplier: 1, rewardText: null };

                const effect = foodConfig.effect;
                let xpBonus = 0;
                let goldMultiplier = 1;
                let rewardText = null;

                switch (effect.type) {
                    case 'permAtkBoost':
                        // Permanent ATK boost
                        this.permAtkBonus = (this.permAtkBonus || 0) + effect.value;
                        rewardText = { text: `+${effect.value} ATK`, color: foodConfig.effectColor };
                        break;

                    case 'permDefBoost':
                        // Permanent DEF boost
                        this.permDefBonus = (this.permDefBonus || 0) + effect.value;
                        rewardText = { text: `+${effect.value} DEF`, color: foodConfig.effectColor };
                        break;

                    case 'permHpBoost':
                        // Permanent max HP boost
                        this.permHpBonus = (this.permHpBonus || 0) + effect.value;
                        this.maxHp += effect.value;
                        this.currentHp += effect.value; // Also heal the added HP
                        rewardText = { text: `+${effect.value} HP`, color: foodConfig.effectColor };
                        break;

                    case 'heal':
                        // Heal 1 HP if not at max
                        if (this.currentHp < this.maxHp) {
                            this.currentHp = Math.min(this.maxHp, this.currentHp + effect.value);
                            rewardText = { text: `+${effect.value} HEAL`, color: foodConfig.effectColor };
                        }
                        break;

                    case 'xpBoost':
                        // Return XP multiplier for this delivery
                        xpBonus = effect.value;
                        rewardText = { text: `+${Math.round(effect.value * 100)}% XP`, color: foodConfig.effectColor };
                        break;

                    case 'goldenBonus':
                        // Return gold multiplier for this delivery
                        goldMultiplier = effect.goldMultiplier;
                        rewardText = { text: `${goldMultiplier}x GOLD`, color: foodConfig.effectColor };
                        break;
                }

                return { xpBonus, goldMultiplier, rewardText };
            }

            // Update and clean up expired buffs
            updateBuffs() {
                const now = Date.now();
                this.activeBuffs = this.activeBuffs.filter(buff => buff.endTime > now);
            }

            // Check if ant has any active buffs
            hasActiveBuffs() {
                return this.activeBuffs.length > 0;
            }

            // Calculate current level from XP
            getLevel() {
                const xp = this.getTotalExp();
                const thresholds = CONFIG.levelThresholds;
                for (let i = thresholds.length - 1; i >= 0; i--) {
                    if (xp >= thresholds[i]) return i + 1;
                }
                return 1;
            }

            // Get XP needed for next level
            getXpToNextLevel() {
                const currentLevel = this.getLevel();
                if (currentLevel >= 5) return 0;
                const nextThreshold = CONFIG.levelThresholds[currentLevel];
                return nextThreshold - this.getTotalExp();
            }

            // Get XP progress percentage to next level
            getLevelProgress() {
                const currentLevel = this.getLevel();
                if (currentLevel >= 5) return 100;
                const currentThreshold = CONFIG.levelThresholds[currentLevel - 1];
                const nextThreshold = CONFIG.levelThresholds[currentLevel];
                const xp = this.getTotalExp();
                return ((xp - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
            }

            // Recalculate all stats based on level and traits
            recalculateStats() {
                const typeConfig = this.typeConfig;
                const level = this.getLevel();
                const levelBonus = level - 1;  // 0 at level 1, 4 at level 5

                // Get trait quality multipliers
                const speedQuality = getTraitQuality(this.traitRolls.speed);
                const detectionQuality = getTraitQuality(this.traitRolls.detection);
                const efficiencyQuality = getTraitQuality(this.traitRolls.efficiency);
                const resilienceQuality = getTraitQuality(this.traitRolls.resilience);

                // Calculate base stats with level bonuses
                const levelBonuses = typeConfig.levelBonuses || {};

                // Speed
                const baseSpeed = typeConfig.speed + (levelBonuses.speed || 0) * levelBonus;
                this.baseSpeed = baseSpeed * speedQuality.multiplier;
                this.speed = this.baseSpeed;

                // Detection
                const baseDetection = typeConfig.foodDetectRadius + (levelBonuses.foodDetectRadius || 0) * levelBonus;
                this.foodDetectRadius = baseDetection * detectionQuality.multiplier;

                // Carry efficiency
                const baseEfficiency = typeConfig.carrySpeedBonus + (levelBonuses.carrySpeedBonus || 0) * levelBonus;
                this.carrySpeedBonus = baseEfficiency * efficiencyQuality.multiplier;

                // Carry capacity
                this.carryCapacity = typeConfig.carryCapacity + (levelBonuses.carryCapacity || 0) * levelBonus;

                // Pokemon-style combat stats (with upgrade bonuses)
                const baseHp = typeConfig.hp + (levelBonuses.hp || 0) * levelBonus + upgradeMultipliers.hpBonus;
                const newMaxHp = Math.floor(baseHp * resilienceQuality.multiplier);
                if (this.currentHp === undefined) {
                    this.maxHp = newMaxHp;
                    this.currentHp = this.maxHp;  // Initialize HP on first calc
                } else {
                    // On stat change, heal proportionally
                    const oldMaxHp = this.maxHp || newMaxHp;
                    this.maxHp = newMaxHp;
                    this.currentHp = Math.min(this.maxHp, Math.ceil(this.currentHp * (this.maxHp / oldMaxHp)));
                }

                const baseAtk = typeConfig.atk + (levelBonuses.atk || 0) * levelBonus + upgradeMultipliers.atkBonus;
                this.atk = baseAtk;

                const baseDef = typeConfig.def + (levelBonuses.def || 0) * levelBonus + upgradeMultipliers.defBonus;
                this.def = baseDef * resilienceQuality.multiplier;

                // Pheromone strength
                const basePheromone = typeConfig.pheromoneStrength + (levelBonuses.pheromoneStrength || 0) * levelBonus;
                this.pheromoneStrength = basePheromone;

                // Queen spawn interval
                if (this.type === 'queen') {
                    const baseInterval = typeConfig.spawnInterval + (levelBonuses.spawnInterval || 0) * levelBonus;
                    this.spawnInterval = Math.max(300, baseInterval);  // Min 5 seconds
                }

                // Update level and skill status
                this.level = level;
                this.hasSkill = level >= (typeConfig.skillLevel || 3);
            }

            // Get total experience points
            getTotalExp() {
                return this.experience.totalDeliveries +
                       this.experience.dangerDeliveries * 2 +  // Danger zone worth double
                       this.experience.predatorEscapes * 3 +   // Escapes worth triple
                       Math.floor(this.experience.foodDiscovered * 0.5);  // Bonus for discovery
            }

            // Check if ant just leveled up and handle it
            checkLevelUp() {
                const newLevel = this.getLevel();
                if (newLevel > this.level) {
                    this.recalculateStats();
                    // Could add level-up visual effect here
                    return true;
                }
                return false;
            }

            // Record a successful delivery
            recordDelivery(value, fromDangerZone) {
                this.experience.totalDeliveries++;
                this.experience.totalValue += value;
                if (fromDangerZone) {
                    this.experience.dangerDeliveries++;
                }

                // Check for level up
                this.checkLevelUp();
            }

            // Record food discovery (when ant first finds a food source)
            recordFoodDiscovery() {
                this.experience.foodDiscovered++;
                this.checkLevelUp();
            }

            // Record predator encounter
            recordPredatorEncounter(escaped) {
                this.experience.predatorEncounters++;
                if (escaped) {
                    this.experience.predatorEscapes++;
                    this.checkLevelUp();
                }
            }

            // Check if ant has a harvest ability
            hasHarvestAbility(ability) {
                if (!this.harvestAbilities) return false;
                if (this.harvestAbilities.includes('champion')) return true;  // Champion has all abilities
                return this.harvestAbilities.includes(ability);
            }

            // Take damage from a predator attack
            takeDamage(attackPower, predator = null) {
                // Calculate effective defense including permanent bonuses and nest defense bonus
                let effectiveDef = this.getEffectiveDef();

                // Apply Fortified Nest bonus if near the nest
                if (upgradeMultipliers.nestDefenseBonus > 0) {
                    const distToNest = Math.hypot(this.x - CONFIG.nestX, this.y - CONFIG.nestY);
                    if (distToNest <= upgradeMultipliers.nestDefenseRadius) {
                        effectiveDef += upgradeMultipliers.nestDefenseBonus;
                    }
                }

                // Calculate damage: attacker's ATK minus defender's DEF (min 1 damage)
                const damage = Math.max(1, attackPower - effectiveDef);
                this.currentHp -= damage;

                // THORNS ABILITY: Reflect damage when hit
                if (predator && predator.currentHp !== undefined && this.hasHarvestAbility('thorns')) {
                    const thornsDamage = Math.ceil(damage * 0.3);  // Reflect 30% of damage taken
                    predator.currentHp -= thornsDamage;
                    spawnFloatingText(predator.x, predator.y - 25, `THORNS -${thornsDamage}`, '#ffa502', 10);
                    if (predator.currentHp <= 0) {
                        removePredator(predator);
                    }
                }

                // Both ant and predator stand still during combat - refresh timer on each hit
                if (predator) {
                    this.fightingTimer = 60;  // 1 second
                    predator.fightingTimer = 60;

                    // Face each other
                    this.angle = Math.atan2(predator.y - this.y, predator.x - this.x);
                    predator.angle = Math.atan2(this.y - predator.y, this.x - predator.x);
                }

                // Retaliation attack - ants always fight back when attacked (bypasses cooldown)
                if (predator && predator.currentHp !== undefined && this.currentHp > 0) {
                    const antAtk = this.getEffectiveAtk();
                    if (antAtk > 0) {
                        const retaliateDamage = Math.max(1, antAtk - (predator.def || 0));
                        predator.currentHp -= retaliateDamage;

                        // LIFESTEAL ABILITY: Heal when dealing damage
                        if (this.hasHarvestAbility('lifesteal')) {
                            const healAmount = Math.ceil(retaliateDamage * 0.25);  // Heal 25% of damage dealt
                            this.currentHp = Math.min(this.maxHp, this.currentHp + healAmount);
                            spawnFloatingText(this.x, this.y - 25, `+${healAmount} HP`, '#7bed9f', 10);
                        }

                        // Spawn combat effect with health indicators
                        const midX = (this.x + predator.x) / 2;
                        const midY = (this.y + predator.y) / 2;
                        spawnCombatEffect(midX, midY, this.currentHp, this.maxHp, Math.max(0, predator.currentHp), predator.maxHp);

                        // Spawn damage numbers
                        spawnFloatingText(this.x, this.y - 15, `-${damage}`, '#ff4444', 11);
                        spawnFloatingText(predator.x, predator.y - 15, `-${retaliateDamage}`, '#00ff88', 11);

                        // Check if predator is killed by retaliation
                        if (predator.currentHp <= 0) {
                            removePredator(predator);
                        }
                    }
                }

                // Return true if ant survives
                return this.currentHp > 0;
            }

            // Check if ant is alive
            isAlive() {
                return this.currentHp > 0;
            }

            // Get HP percentage for UI
            getHpPercent() {
                return (this.currentHp / this.maxHp) * 100;
            }

            // Get effective ATK (including Berserker skill and permanent food bonuses)
            getEffectiveAtk() {
                let atk = this.atk + (this.permAtkBonus || 0);

                // Berserker skill: doubles ATK when colony has recent deaths
                if (this.hasSkill && this.type === 'soldier' && CONFIG.recentDeaths > 0) {
                    atk *= 2;
                }

                // Apply temporary ATK buffs (if any still exist)
                for (const buff of this.activeBuffs) {
                    if (buff.type === 'atkBoost') {
                        atk *= (1 + buff.value);
                    }
                }

                return atk;
            }

            // Get effective DEF (including permanent food bonuses)
            getEffectiveDef() {
                return this.def + (this.permDefBonus || 0);
            }

            // Combat with predator - uses Pokemon-style stats (1 attack per second)
            attemptFight(predator) {
                // Check attack cooldown (1 attack per second = 60 frames)
                if (time - this.lastAttackTime < 60) return 'cooldown';

                // All ants can now take damage, but only soldiers fight back effectively
                const antAtk = this.getEffectiveAtk();

                // Deal damage to predator if we have attack power
                if (antAtk > 0 && predator.currentHp !== undefined) {
                    const damageDealt = Math.max(1, antAtk - (predator.def || 0));
                    predator.currentHp -= damageDealt;

                    // Record attack time for cooldown
                    this.lastAttackTime = time;

                    // Check if predator is killed - remove permanently
                    if (predator.currentHp <= 0) {
                        removePredator(predator);
                        return 'win';
                    }
                }

                // Soldier has chance to stun even if not killing
                if (this.type === 'soldier' && Math.random() < 0.3) {
                    predator.stun(120); // 2 second stun
                    return 'win';
                }

                return 'fought';  // Combat happened but no decisive result
            }

            // Check if this ant should follow pheromones (Worker skill affects this)
            shouldFollowPheromone() {
                // Efficient Forager skill: 95% accuracy instead of 70%
                if (this.hasSkill && this.type === 'worker') {
                    return Math.random() < 0.95;
                }
                return Math.random() < 0.7;
            }

            // Get carry speed (Carrier skill affects this)
            getCarrySpeed() {
                // Beast of Burden skill: no speed penalty
                if (this.hasSkill && this.type === 'carrier') {
                    return this.speed;
                }
                return this.speed * 0.6 * this.carrySpeedBonus;
            }

            // Check if within Queen's Royal Decree aura
            isInRoyalAura() {
                for (const ant of ants) {
                    if (ant.type === 'queen' && ant.hasSkill && ant !== this) {
                        const dist = Math.hypot(this.x - ant.x, this.y - ant.y);
                        if (dist < 120) {  // Royal aura radius
                            return true;
                        }
                    }
                }
                return false;
            }

            // Get effective speed (including Royal Decree bonus and upgrades)
            getEffectiveSpeed() {
                let speed = this.speed * upgradeMultipliers.antSpeed;
                if (this.isInRoyalAura()) {
                    speed *= 1.25;  // 25% boost from queen
                }
                return speed;
            }

            update() {
                this.legPhase += 0.25;

                // Record position for trail effect (every frame)
                this.positionHistory.push({ x: this.x, y: this.y });
                if (this.positionHistory.length > 20) {
                    this.positionHistory.shift();
                }

                // REGENERATION ABILITY: Heal 1 HP every 5 seconds (300 frames)
                if (this.hasHarvestAbility && this.hasHarvestAbility('regeneration')) {
                    this.regenTimer = (this.regenTimer || 0) + 1;
                    if (this.regenTimer >= 300 && this.currentHp < this.maxHp) {
                        this.currentHp = Math.min(this.maxHp, this.currentHp + 1);
                        this.regenTimer = 0;
                        spawnFloatingText(this.x, this.y - 15, '+1 REGEN', '#ff6b81', 9);
                    }
                }

                // If resting in hive, decrement timer and stay put
                if (this.hiveRestTimer > 0) {
                    this.hiveRestTimer--;
                    return;
                }

                // If fighting, stand still and decrement timer
                if (this.fightingTimer > 0) {
                    this.fightingTimer--;
                    return;
                }

                // Flee from nearby predators if in danger zone and not carrying
                // Soldiers don't flee - they fight!
                if (this.type !== 'soldier' && isInDangerZone(this.x, this.y) && this.state !== 'carrying') {
                    let nearestPredator = null;
                    let nearestDist = 60;

                    // Check all predators
                    for (const p of getAllPredators()) {
                        if (p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestPredator = p;
                        }
                    }

                    if (nearestPredator) {
                        this.panicTimer = 30;
                        const fleeAngle = Math.atan2(this.y - nearestPredator.y, this.x - nearestPredator.x);
                        this.angle = fleeAngle + (Math.random() - 0.5) * 0.5;
                        this.x += Math.cos(this.angle) * this.speed * 2.5;
                        this.y += Math.sin(this.angle) * this.speed * 2.5;
                        this.bounceOffWalls();
                        return;
                    }
                }

                // Soldiers actively engage predators when nearby
                if (this.type === 'soldier' && this.state !== 'hunting' && this.state !== 'escorting') {
                    for (const p of getAllPredators()) {
                        if (p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < 40) {
                            this.targetPredator = p;
                            this.state = 'hunting';
                            break;
                        }
                    }
                }

                if (this.panicTimer > 0) this.panicTimer--;

                // Queen behavior - spawn workers over time
                if (this.type === 'queen') {
                    this.spawnTimer++;
                    const typeConfig = CONFIG.antTypes.queen;
                    const effectiveInterval = typeConfig.spawnInterval * upgradeMultipliers.queenSpawnRate;
                    if (this.spawnTimer >= effectiveInterval && ants.length < CONFIG.maxAnts) {
                        this.spawnTimer = 0;
                        const angle = Math.random() * Math.PI * 2;
                        const spawnDist = 15;
                        const newAnt = new Ant(
                            this.x + Math.cos(angle) * spawnDist,
                            this.y + Math.sin(angle) * spawnDist,
                            'worker'
                        );
                        ants.push(newAnt);
                        addSpawnNotification('worker');
                    }
                    // Queen stays near nest
                    if (this.staysNearNest && this.distanceToNest() > getColonySize() * 1.5) {
                        const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                        this.angle = angleToNest;
                    }
                }

                switch (this.state) {
                    case 'exploring': this.explore(); break;
                    case 'returning': this.returnToNest(); break;
                    case 'carrying': this.carryFood(); break;
                    case 'hunting': this.huntPredator(); break;
                    case 'escorting': this.escortAnt(); break;
                }

                this.bounceOffWalls();
            }

            // Soldiers: Find a predator to hunt or ant to escort
            findSoldierTask() {
                // Priority 1: Hunt predators in danger zones
                let nearestPredator = null;
                let nearestPredatorDist = 200;

                for (const p of getAllPredators()) {
                    if (p.state === 'stunned') continue;
                    const dist = Math.hypot(p.x - this.x, p.y - this.y);
                    if (dist < nearestPredatorDist) {
                        nearestPredatorDist = dist;
                        nearestPredator = p;
                    }
                }

                if (nearestPredator && nearestPredatorDist < 150) {
                    this.targetPredator = nearestPredator;
                    this.state = 'hunting';
                    return true;
                }

                // Priority 2: Escort non-soldier ants heading into danger zones
                let nearestVulnerable = null;
                let nearestVulnerableDist = 80;

                for (const ant of ants) {
                    if (ant === this || ant.type === 'soldier') continue;
                    if (ant.state !== 'carrying') continue; // Only escort carriers

                    // Check if ant is near or heading toward danger
                    if (isInDangerZone(ant.x, ant.y)) {
                        const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                        if (dist < nearestVulnerableDist) {
                            nearestVulnerableDist = dist;
                            nearestVulnerable = ant;
                        }
                    }
                }

                if (nearestVulnerable) {
                    this.escortTarget = nearestVulnerable;
                    this.state = 'escorting';
                    return true;
                }

                return false;
            }

            // Soldier behavior: Hunt predators
            huntPredator() {
                const predator = this.targetPredator;

                // Check if predator is still valid target
                if (!predator || predator.state === 'stunned') {
                    this.targetPredator = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(predator.x - this.x, predator.y - this.y);

                // If close enough, attempt to stun
                if (dist < 15) {
                    const result = this.attemptFight(predator);
                    if (result === 'win') {
                        // Soldier survived and stunned predator
                        this.targetPredator = null;
                        this.state = 'exploring';
                    } else if (result === 'mutual') {
                        // Both affected - soldier dies
                        spawnDeathEffect(this.x, this.y, 'ant', this.color);
                        const idx = ants.indexOf(this);
                        if (idx !== -1) ants.splice(idx, 1);
                    } else {
                        // Soldier lost - dies
                        spawnDeathEffect(this.x, this.y, 'ant', this.color);
                        const idx = ants.indexOf(this);
                        if (idx !== -1) ants.splice(idx, 1);
                    }
                    return;
                }

                // Move toward predator
                const angleToTarget = Math.atan2(predator.y - this.y, predator.x - this.x);
                this.angle = angleToTarget + (Math.random() - 0.5) * 0.2;
                this.move();

                // Give up if too far
                if (dist > 250) {
                    this.targetPredator = null;
                    this.state = 'exploring';
                }
            }

            // Soldier behavior: Escort vulnerable ants
            escortAnt() {
                const target = this.escortTarget;

                // Check if target is still valid
                if (!target || !ants.includes(target) || target.state !== 'carrying') {
                    this.escortTarget = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(target.x - this.x, target.y - this.y);

                // Stay close to the target
                if (dist > 25) {
                    const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                    this.angle = angleToTarget + (Math.random() - 0.5) * 0.3;
                    this.move();
                } else {
                    // Circle around the target protectively
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x) + Math.PI / 2;
                    this.x += Math.cos(this.angle) * this.speed * 0.5;
                    this.y += Math.sin(this.angle) * this.speed * 0.5;
                }

                // If predator gets close, intercept it
                for (const p of getAllPredators()) {
                    if (p.state === 'stunned') continue;
                    const predatorDist = Math.hypot(p.x - target.x, p.y - target.y);
                    if (predatorDist < 50) {
                        this.targetPredator = p;
                        this.escortTarget = null;
                        this.state = 'hunting';
                        return;
                    }
                }

                // Stop escorting if target leaves danger zone
                if (!isInDangerZone(target.x, target.y)) {
                    this.escortTarget = null;
                    this.state = 'exploring';
                }
            }

            explore() {
                // If ant has spotted food, head toward it
                if (this.targetFood && !this.targetFood.isEmpty()) {
                    const dist = Math.hypot(this.targetFood.x - this.x, this.targetFood.y - this.y);
                    // Keep heading toward food with slight wobble
                    this.angle = Math.atan2(this.targetFood.y - this.y, this.targetFood.x - this.x);
                    this.angle += (Math.random() - 0.5) * 0.2;  // Small wobble
                } else {
                    // Clear invalid target
                    this.targetFood = null;

                    // Soldiers look for tasks instead of food
                    if (this.type === 'soldier') {
                        // Check for tasks more frequently
                        if (Math.random() < 0.1) {
                            if (this.findSoldierTask()) return;
                        }

                        // Soldiers patrol toward danger zones - much more focused
                        let nearestPred = null;
                        let nearestDist = Infinity;
                        for (const p of getAllPredators()) {
                            if (p.state === 'stunned') continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestPred = p;
                            }
                        }
                        if (nearestPred) {
                            const angleToTarget = Math.atan2(nearestPred.y - this.y, nearestPred.x - this.x);
                            // Strong bias toward predator (80% follow, 20% wander)
                            if (Math.random() < 0.8) {
                                this.angle = angleToTarget + (Math.random() - 0.5) * 0.3;
                            } else {
                                this.angle += (Math.random() - 0.5) * this.wanderStrength;
                            }
                        } else {
                            this.angle += (Math.random() - 0.5) * this.wanderStrength;
                        }
                    } else if (this.isScout || !this.shouldFollowPheromone()) {
                        // Scouts wander, workers sometimes do too (unless they have Efficient Forager)
                        this.angle += (Math.random() - 0.5) * this.wanderStrength + this.wanderBias;
                    } else {
                        // Follow pheromone trails
                        const turn = samplePheromoneDirection(this.x, this.y, this.angle, 'food');
                        this.angle += turn + (Math.random() - 0.5) * CONFIG.wanderStrength * 0.4;
                    }
                }

                this.depositTimer++;
                if (this.depositTimer > 6) {
                    const distToNest = this.distanceToNest();
                    depositPheromone(this.x, this.y, 'home', CONFIG.pheromoneDeposit * this.pheromoneStrength * Math.max(0.15, 1 - distToNest / 350));
                    this.depositTimer = 0;
                }

                this.move();

                // Soldiers still pick up food if they find it, but less eagerly
                if (this.type !== 'soldier' || Math.random() < 0.3) {
                    this.checkForFood();
                }

                if (Math.random() < 0.0004) {
                    this.state = 'returning';
                    this.foundFoodRecently = false;
                }
            }

            checkForFood() {
                // Detection radius is how far the ant can SEE food
                // Detection trait gives up to 20% bonus, plus upgrade bonus
                const detectionBonus = 1 + (this.traitRolls.detection - 0.5) * 0.4;  // 0.8x to 1.2x
                const baseDetectionRange = this.foodDetectRadius * detectionBonus * upgradeMultipliers.detectionRadius;

                // Pickup radius is small - ant must actually reach the food
                const pickupRadius = 8;

                for (const food of foodItems) {
                    const dist = Math.hypot(this.x - food.x, this.y - food.y);
                    const foodRadius = food.getRadius();

                    // Check for food attraction effect (feast food has 2x detection range)
                    const foodConfig = CONFIG.foodTypes[food.type];
                    const attractMultiplier = (foodConfig.effect && foodConfig.effect.type === 'attract')
                        ? foodConfig.effect.detectMultiplier : 1;
                    const effectiveDetectionRange = baseDetectionRange * attractMultiplier;

                    // Close enough to pick up?
                    if (dist < pickupRadius + foodRadius) {
                        if (food.canTakeUnit()) {
                            this.pickUpFoodUnit(food);
                        } else {
                            // Food is depleted, leave pheromone and mark as found
                            depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 6);
                            this.state = 'returning';
                            this.foundFoodRecently = true;
                        }
                        break;
                    }
                    // Can detect food from far away? Move toward it!
                    else if (dist < effectiveDetectionRange + foodRadius && !this.targetFood) {
                        // Spotted food - head toward it
                        this.targetFood = food;
                        this.angle = Math.atan2(food.y - this.y, food.x - this.x);
                        // Leave a food pheromone to help others
                        depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 2);
                        break;
                    }
                }
            }

            pickUpFoodUnit(food) {
                // Capacity determines how many units ant can carry at once (1 = 1 unit, 2 = 2 units, etc)
                // Include upgrade bonus for carry capacity
                const capacity = Math.max(1, Math.floor(this.carryCapacity + upgradeMultipliers.carryCapacity));
                const unitsToTake = Math.min(capacity, Math.floor(food.size));

                // Take units from the food
                let unitsTaken = 0;
                for (let i = 0; i < unitsToTake; i++) {
                    if (food.takeUnit() > 0) {
                        unitsTaken++;
                    } else {
                        break;
                    }
                }

                if (unitsTaken > 0) {
                    // Record food discovery for XP
                    this.recordFoodDiscovery();

                    // Scout Trailblazer skill: create beacon when finding food
                    if (this.hasSkill && this.type === 'scout') {
                        addTrailblazerBeacon(food.x, food.y, food);
                    }

                    this.carriedFoodPiece = new CarriedFoodPiece(food.type, food.id, food.inDangerZone, food.zoneMultiplier, food);
                    this.carriedFoodPiece.units = unitsTaken;  // Track how many units carried
                    this.carriedFoodValue = 0;  // No gold value in new system
                    this.targetFood = food;
                    this.state = 'carrying';
                    this.angle = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);

                    // Remove food if empty
                    if (food.isEmpty()) {
                        const idx = foodItems.indexOf(food);
                        if (idx !== -1) foodItems.splice(idx, 1);
                    }
                }
            }

            carryFood() {
                // Ant is carrying a food piece back to nest
                if (!this.carriedFoodPiece) {
                    this.state = 'exploring';
                    return;
                }

                // Move toward nest
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const turnRate = 0.1;
                const angleDiff = this.angleDiff(angleToNest, this.angle);
                this.angle += angleDiff * turnRate;

                // Carriers move slower when carrying, adjusted by carrySpeedBonus (and skills)
                const carrySpeed = this.getCarrySpeed();
                this.x += Math.cos(this.angle) * carrySpeed;
                this.y += Math.sin(this.angle) * carrySpeed;

                // Deposit pheromones
                this.depositTimer++;
                if (this.depositTimer > 4) {
                    depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 3);
                    this.depositTimer = 0;
                }

                // Check if reached nest
                const distToNest = this.distanceToNest();
                if (distToNest < getColonySize()) {
                    // Count units delivered
                    const unitsDelivered = this.carriedFoodPiece.units || 1;
                    const deliveredFoodType = this.carriedFoodPiece.type;
                    const zoneMultiplier = this.carriedFoodPiece.zoneMultiplier || 1;
                    const foodConfig = CONFIG.foodTypes[deliveredFoodType];

                    // Record experience for the delivering ant
                    for (let i = 0; i < unitsDelivered; i++) {
                        this.recordDelivery(1, this.carriedFoodPiece.fromDangerZone);
                    }

                    // FOOD REWORK: Accumulate bonuses for next ant spawn
                    const bonus = FOOD_BONUSES[deliveredFoodType];
                    if (bonus) {
                        const totalBonus = unitsDelivered * bonus.perUnit * zoneMultiplier;

                        if (bonus.stat === 'all') {
                            // Golden Apple gives +1 to ALL stats per unit
                            accumulatedBonuses.hp += totalBonus;
                            accumulatedBonuses.atk += totalBonus;
                            accumulatedBonuses.def += totalBonus;
                            accumulatedBonuses.carry += totalBonus;
                        } else {
                            accumulatedBonuses[bonus.stat] += totalBonus;
                        }

                        // Check if this food type is Lv.10 for ability
                        if (foodLevels[deliveredFoodType] >= 10) {
                            if (!accumulatedBonuses.abilities.includes(bonus.ability)) {
                                accumulatedBonuses.abilities.push(bonus.ability);
                            }
                        }
                    }

                    // Track delivery for harvest summary
                    cycleDeliveries.push({
                        foodType: deliveredFoodType,
                        units: unitsDelivered,
                        zoneMultiplier: zoneMultiplier,
                        emoji: foodConfig.emoji
                    });

                    // Update food item's delivered count
                    if (this.carriedFoodPiece.sourceFood) {
                        this.carriedFoodPiece.sourceFood.unitsDelivered += unitsDelivered;

                        // Check if food is fully delivered
                        if (this.carriedFoodPiece.sourceFood.unitsDelivered >= this.carriedFoodPiece.sourceFood.maxSize) {
                            this.carriedFoodPiece.sourceFood.onFullyDelivered();
                        }
                    }

                    foodCollected += unitsDelivered;

                    // Show bonus gained floating text
                    const bonusText = bonus ?
                        (bonus.stat === 'all' ? `+${unitsDelivered * zoneMultiplier} ALL` :
                        `+${unitsDelivered * bonus.perUnit * zoneMultiplier} ${bonus.stat.toUpperCase()}`) :
                        '+Food';
                    spawnFloatingText(CONFIG.nestX + (Math.random() - 0.5) * 30, CONFIG.nestY - 20, bonusText, foodConfig.effectColor || '#00ff88', 12);

                    // Reset state
                    this.carriedFoodPiece = null;
                    this.carriedFoodValue = 0;
                    this.targetFood = null;
                    this.foundFoodRecently = true;

                    // Ant rests in hive briefly after delivering food
                    this.hiveRestTimer = 120;  // 2 seconds at 60fps
                    this.state = 'exploring';

                    // Move ant to center of nest while resting
                    const restAngle = Math.random() * Math.PI * 2;
                    const restDist = Math.random() * 15;
                    this.x = CONFIG.nestX + Math.cos(restAngle) * restDist;
                    this.y = CONFIG.nestY + Math.sin(restAngle) * restDist;
                    this.angle = Math.random() * Math.PI * 2;
                }
            }

            returnToNest() {
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const pheromoneTurn = samplePheromoneDirection(this.x, this.y, this.angle, 'home');
                const directTurn = this.angleDiff(angleToNest, this.angle) * 0.12;

                this.angle += directTurn + pheromoneTurn * 0.4 + (Math.random() - 0.5) * 0.08;

                if (this.foundFoodRecently) {
                    this.depositTimer++;
                    if (this.depositTimer > 4) {
                        depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 2.5);
                        this.depositTimer = 0;
                    }
                }

                this.move();

                if (this.distanceToNest() < getColonySize()) {
                    this.state = 'exploring';
                    this.foundFoodRecently = false;
                    this.targetFood = null;  // Clear so ant can spot new food
                    this.angle += Math.PI + (Math.random() - 0.5) * 1.2;
                }
            }

            move() {
                const effectiveSpeed = this.getEffectiveSpeed();
                const dx = Math.cos(this.angle) * effectiveSpeed;
                const dy = Math.sin(this.angle) * effectiveSpeed;
                this.x += dx;
                this.y += dy;

                // Track distance traveled for stats
                this.experience.distanceTraveled += Math.abs(dx) + Math.abs(dy);
            }

            bounceOffWalls() {
                const margin = 15;
                if (this.x < margin) { this.x = margin; this.angle = Math.PI - this.angle; }
                if (this.x > width - margin) { this.x = width - margin; this.angle = Math.PI - this.angle; }
                if (this.y < margin) { this.y = margin; this.angle = -this.angle; }
                if (this.y > height - margin) { this.y = height - margin; this.angle = -this.angle; }
            }

            distanceToNest() {
                return Math.hypot(this.x - CONFIG.nestX, this.y - CONFIG.nestY);
            }

            angleDiff(target, current) {
                let diff = target - current;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                return diff;
            }

            draw() {
                const antLevel = this.getLevel();

                // Draw sci-fi energy trail for level 2+ only
                if (antLevel >= 2 && this.positionHistory.length > 3) {
                    // Bright neon color palette
                    const trailThemes = {
                        2: { core: [0, 255, 200], glow: [0, 255, 255] },    // Cyan
                        3: { core: [100, 180, 255], glow: [150, 220, 255] }, // Electric blue
                        4: { core: [200, 100, 255], glow: [230, 150, 255] }, // Violet
                        5: { core: [255, 220, 100], glow: [255, 255, 180] }  // Golden
                    };

                    const theme = trailThemes[antLevel];
                    const time = Date.now() * 0.005;
                    const len = this.positionHistory.length;

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Outer glow layer - BRIGHT
                    for (let i = 1; i < len; i++) {
                        const progress = i / len;
                        const glowAlpha = progress * (0.15 + antLevel * 0.08);
                        const glowWidth = progress * (4 + antLevel * 2);

                        ctx.strokeStyle = `rgba(${theme.glow[0]}, ${theme.glow[1]}, ${theme.glow[2]}, ${glowAlpha})`;
                        ctx.lineWidth = glowWidth;
                        ctx.beginPath();
                        ctx.moveTo(this.positionHistory[i - 1].x, this.positionHistory[i - 1].y);
                        ctx.lineTo(this.positionHistory[i].x, this.positionHistory[i].y);
                        ctx.stroke();
                    }

                    // Core energy line - bright white/color center
                    for (let i = 1; i < len; i++) {
                        const progress = i / len;
                        const coreAlpha = progress * (0.5 + antLevel * 0.1);
                        const coreWidth = progress * (1.5 + antLevel * 0.5);

                        ctx.strokeStyle = `rgba(${theme.core[0]}, ${theme.core[1]}, ${theme.core[2]}, ${coreAlpha})`;
                        ctx.lineWidth = coreWidth;
                        ctx.beginPath();
                        ctx.moveTo(this.positionHistory[i - 1].x, this.positionHistory[i - 1].y);
                        ctx.lineTo(this.positionHistory[i].x, this.positionHistory[i].y);
                        ctx.stroke();
                    }

                    // Energy nodes for level 3+
                    if (antLevel >= 3) {
                        const nodeInterval = 4;
                        for (let i = nodeInterval; i < len; i += nodeInterval) {
                            const pos = this.positionHistory[i];
                            const progress = i / len;
                            const pulse = 0.7 + Math.sin(time + i) * 0.3;
                            const nodeSize = (2 + antLevel) * progress * pulse;

                            // Glowing node
                            ctx.fillStyle = `rgba(${theme.glow[0]}, ${theme.glow[1]}, ${theme.glow[2]}, ${0.6 * progress})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
                            ctx.fill();

                            // White hot center
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * progress})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, nodeSize * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Size increases with level (35% per level above 1) - level 5 is 140% bigger!
                const levelSizeBonus = 1 + (antLevel - 1) * 0.35;
                const size = CONFIG.antSize * this.sizeMultiplier * levelSizeBonus;
                const legWave = Math.sin(this.legPhase) * 0.35;

                // Type-based colors - use accent for highlights
                const baseColor = this.colorConfig || CONFIG.antTypes.worker.color;
                const accent = this.accentColor || baseColor;
                const r = baseColor.r;
                const g = baseColor.g;
                const b = baseColor.b;
                const bodyColor = `rgb(${r}, ${g}, ${b})`;
                const darkColor = `rgb(${Math.max(0, r - 20)}, ${Math.max(0, g - 15)}, ${Math.max(0, b - 10)})`;
                const accentColorStr = `rgb(${accent.r}, ${accent.g}, ${accent.b})`;
                const legColor = `rgb(${Math.min(255, r + 30)}, ${Math.min(255, g + 25)}, ${Math.min(255, b + 20)})`;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 2, size * 1.2, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs - use accent color for visibility
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.12;
                ctx.lineCap = 'round';

                const legPositions = [-0.15, 0.05, 0.25];
                for (let i = 0; i < 3; i++) {
                    const attachX = legPositions[i] * size;
                    const phase = (i === 1) ? -legWave : legWave;

                    ctx.beginPath();
                    ctx.moveTo(attachX, -size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, -size * 0.45 - phase * size * 0.15, attachX - size * 0.1, -size * 0.7 - phase * size * 0.1);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(attachX, size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, size * 0.45 + phase * size * 0.15, attachX - size * 0.1, size * 0.7 + phase * size * 0.1);
                    ctx.stroke();
                }

                // Gaster (abdomen) - main body color
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.5, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Gaster stripe/marking for visibility
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.35, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = darkColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.7, 0, size * 0.15, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Petiole
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.1, 0, size * 0.1, size * 0.07, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax - with accent highlight
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.28, size * 0.18, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax accent stripe
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.18, size * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.55, 0, size * 0.22, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes - white with black pupil for visibility
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(size * 0.62, -size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.arc(size * 0.62, size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(size * 0.64, -size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.arc(size * 0.64, size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.fill();

                // Antennae - use accent color
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.07;
                const antennaWave = Math.sin(this.legPhase * 0.6) * 0.12;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, -size * 0.12);
                ctx.lineTo(size * 0.88, -size * 0.25);
                ctx.lineTo(size * 1.05, -size * 0.2 + antennaWave * size);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(size * 0.7, size * 0.12);
                ctx.lineTo(size * 0.88, size * 0.25);
                ctx.lineTo(size * 1.05, size * 0.2 - antennaWave * size);
                ctx.stroke();

                // Draw carried food piece with zone-based glow
                if (this.carriedFoodPiece && this.state === 'carrying') {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    const pieceSize = 10;
                    const pieceX = size * 0.8;
                    const pieceY = -size * 0.3;

                    // Zone-based glow
                    const glowGrad = ctx.createRadialGradient(pieceX, pieceY, 0, pieceX, pieceY, pieceSize * 0.8);
                    if (this.carriedFoodPiece.fromDangerZone) {
                        glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.6)');
                        glowGrad.addColorStop(1, 'transparent');
                    } else {
                        glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.5)');
                        glowGrad.addColorStop(1, 'transparent');
                    }
                    ctx.fillStyle = glowGrad;
                    ctx.beginPath();
                    ctx.arc(pieceX, pieceY, pieceSize * 0.8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = `${pieceSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.carriedFoodPiece.emoji, pieceX, pieceY);
                    ctx.restore();
                }

                // Queen crown indicator only
                if (this.type === 'queen') {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    ctx.font = `${size * 0.7}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', 0, -size * 0.7);
                    ctx.restore();
                }

                // Food buff indicator - show active buff icons above ant
                if (this.activeBuffs && this.activeBuffs.length > 0) {
                    ctx.save();
                    ctx.rotate(-this.angle);

                    const buffStartY = -size * 1.5;
                    let buffIndex = 0;

                    for (const buff of this.activeBuffs) {
                        // Calculate time remaining for the buff
                        const timeRemaining = buff.endTime - Date.now();
                        const pulse = Math.sin(Date.now() / 200) * 0.2 + 0.8;

                        // Position buffs in a row above the ant
                        const buffX = (buffIndex - (this.activeBuffs.length - 1) / 2) * size * 0.8;
                        const buffY = buffStartY;

                        // Draw colored glow behind buff
                        const glowGrad = ctx.createRadialGradient(buffX, buffY, 0, buffX, buffY, size * 0.5);
                        glowGrad.addColorStop(0, buff.color || 'rgba(255, 200, 100, 0.6)');
                        glowGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = glowGrad;
                        ctx.globalAlpha = pulse;
                        ctx.beginPath();
                        ctx.arc(buffX, buffY, size * 0.5, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw buff emoji
                        ctx.globalAlpha = 1;
                        ctx.font = `${size * 0.5}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(buff.emoji || '', buffX, buffY);

                        // Draw time remaining indicator bar below
                        const barWidth = size * 0.6;
                        const barHeight = 2;
                        const barY = buffY + size * 0.35;
                        const remainingPercent = Math.max(0, timeRemaining / (buff.endTime - (buff.endTime - 30000)));

                        // Background bar
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.fillRect(buffX - barWidth / 2, barY, barWidth, barHeight);

                        // Progress bar
                        ctx.fillStyle = buff.color || '#ffd700';
                        ctx.fillRect(buffX - barWidth / 2, barY, barWidth * Math.min(1, timeRemaining / 30000), barHeight);

                        buffIndex++;
                    }

                    ctx.restore();
                }

                // Selection indicator - large triangle above selected ant
                if (selectedAnt === this) {
                    ctx.save();
                    ctx.rotate(-this.angle);

                    // Detection radius visualization (shows exact current range)
                    const detectionBonus = 1 + (this.traitRolls.detection - 0.5) * 0.4;
                    const detectionRadius = this.foodDetectRadius * detectionBonus;

                    // Detection ring - dashed outline
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.4)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, detectionRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Subtle inner fill
                    const detectGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, detectionRadius);
                    detectGrad.addColorStop(0, 'rgba(0, 200, 255, 0.03)');
                    detectGrad.addColorStop(0.8, 'rgba(0, 200, 255, 0.06)');
                    detectGrad.addColorStop(1, 'rgba(0, 200, 255, 0)');
                    ctx.setLineDash([]);
                    ctx.fillStyle = detectGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, detectionRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Animated bounce
                    const bounce = Math.sin(Date.now() / 150) * 4;
                    const triangleY = -size * 2.2 - bounce;
                    const triSize = size * 1.2;  // Much bigger triangle

                    // Strong glow effect
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 20;

                    // Outer glow ring
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();

                    // Draw main triangle (pointing down)
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.7);
                    ctx.lineTo(-triSize * 0.5, triangleY);
                    ctx.lineTo(triSize * 0.5, triangleY);
                    ctx.closePath();
                    ctx.fill();

                    // Inner lighter triangle
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#80ffbb';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.5);
                    ctx.lineTo(-triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.lineTo(triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }

                ctx.restore();
            }
        }

        function initAnts() {
            ants = [];
            for (let i = 0; i < CONFIG.initialAnts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * CONFIG.nestRadius * 0.7;
                // Start with all workers
                ants.push(new Ant(CONFIG.nestX + Math.cos(angle) * dist, CONFIG.nestY + Math.sin(angle) * dist, 'worker'));
            }
        }

        // ===========================================
        // RENDERING
        // ===========================================

        function drawGround() {
            // Brighter, greener forest floor
            const gradient = ctx.createRadialGradient(width * 0.4, height * 0.35, 0, width * 0.5, height * 0.5, Math.max(width, height) * 0.8);
            gradient.addColorStop(0, '#3a4a30');
            gradient.addColorStop(0.3, '#2e3d28');
            gradient.addColorStop(0.6, '#243320');
            gradient.addColorStop(1, '#1a2818');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Warm light beam
            const beamGradient = ctx.createRadialGradient(width * 0.3, height * 0.2, 0, width * 0.3, height * 0.2, height * 0.8);
            beamGradient.addColorStop(0, 'rgba(255, 250, 220, 0.08)');
            beamGradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.04)');
            beamGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = beamGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw forest elements
            for (const el of forestElements) drawForestElement(el);

            // Draw grass
            drawGrass();

            // Subtle vignette
            const vignetteGradient = ctx.createRadialGradient(width / 2, height / 2, Math.min(width, height) * 0.35, width / 2, height / 2, Math.max(width, height) * 0.85);
            vignetteGradient.addColorStop(0, 'transparent');
            vignetteGradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.1)');
            vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            ctx.fillStyle = vignetteGradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawPheromones() {
            const cellSize = CONFIG.pheromoneGridSize;

            // Use soft blending for smooth trails
            ctx.globalCompositeOperation = 'lighter';

            for (let row = 0; row < pheromoneGrid.rows; row++) {
                for (let col = 0; col < pheromoneGrid.cols; col++) {
                    const idx = row * pheromoneGrid.cols + col;
                    const foodPh = pheromoneGrid.food[idx];

                    if (foodPh > 0.5) {
                        const x = col * cellSize + cellSize / 2;
                        const y = row * cellSize + cellSize / 2;

                        // Normalize strength (0-1 range, where 1 = very strong trail)
                        const strength = Math.min(1, foodPh / 15);

                        // Smaller base size, blends together into continuous trail
                        const size = cellSize * (0.5 + strength * 0.3);

                        // Alpha scales with strength but kept low for smooth blending
                        const alpha = 0.08 + strength * 0.25;

                        // Color shifts from pale green to bright cyan-green for strong trails
                        const r = Math.round(50 - strength * 30);
                        const g = Math.round(150 + strength * 105);
                        const b = Math.round(80 + strength * 120);

                        // Soft radial gradient for each point - creates smooth blending
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`);
                        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';
        }

        function getColonySize() {
            // Colony grows slightly based on ant population
            return CONFIG.nestRadius * Math.min(2.5, 1 + ants.length / 100);
        }

        function drawNest() {
            const currentRadius = getColonySize();
            const cx = CONFIG.nestX;
            const cy = CONFIG.nestY;
            const antCount = ants.length;

            // Draw defense radius if Fortified Nest is active
            if (upgradeMultipliers.nestDefenseBonus > 0) {
                const defRadius = upgradeMultipliers.nestDefenseRadius;
                const pulse = Math.sin(Date.now() / 600) * 0.15 + 0.85;

                // Outer glow
                const glowGrad = ctx.createRadialGradient(cx, cy, defRadius * 0.7, cx, cy, defRadius * 1.1);
                glowGrad.addColorStop(0, 'transparent');
                glowGrad.addColorStop(0.5, `rgba(100, 180, 255, ${0.08 * pulse})`);
                glowGrad.addColorStop(0.8, `rgba(100, 180, 255, ${0.15 * pulse})`);
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, defRadius * 1.1, 0, Math.PI * 2);
                ctx.fill();

                // Defense circle border
                ctx.strokeStyle = `rgba(100, 180, 255, ${0.4 * pulse})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.arc(cx, cy, defRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Shield icon at top of circle
                ctx.save();
                ctx.translate(cx, cy - defRadius - 10);
                ctx.font = '14px serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(100, 180, 255, ${0.8 * pulse})`;
                ctx.fillText('', 0, 0);
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * pulse})`;
                ctx.fillText(`+${upgradeMultipliers.nestDefenseBonus}`, 0, 14);
                ctx.restore();
            }

            // Excavated dirt
            ctx.fillStyle = '#4a4030';
            const dirtPiles = 20 + Math.min(antCount, 100) * 0.3;
            for (let i = 0; i < dirtPiles; i++) {
                const angle = (i / dirtPiles) * Math.PI * 2 + Math.sin(i * 1.7) * 0.4;
                const dist = currentRadius * (1.1 + Math.sin(i * 2.9) * 0.2);
                const blobSize = currentRadius * (0.06 + Math.sin(i * 4.1) * 0.03);
                ctx.beginPath();
                ctx.ellipse(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.5, blobSize * 1.2, blobSize * 0.4, angle * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Shadow
            const shadowGrad = ctx.createRadialGradient(cx + currentRadius * 0.1, cy + currentRadius * 0.15, 0, cx, cy, currentRadius * 1.3);
            shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            shadowGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.12)');
            shadowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = shadowGrad;
            ctx.beginPath();
            ctx.ellipse(cx + currentRadius * 0.1, cy + currentRadius * 0.12, currentRadius * 1.2, currentRadius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main mound
            const baseGrad = ctx.createRadialGradient(cx - currentRadius * 0.2, cy - currentRadius * 0.25, 0, cx, cy, currentRadius * 1.2);
            baseGrad.addColorStop(0, '#6a5a45');
            baseGrad.addColorStop(0.3, '#5a4a38');
            baseGrad.addColorStop(0.6, '#4a3a2a');
            baseGrad.addColorStop(1, '#3a2a1f');

            ctx.fillStyle = baseGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius, currentRadius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Texture (using deterministic positions based on index to avoid flickering)
            const textureDots = 25 + Math.min(antCount, 100) * 0.4;
            for (let i = 0; i < textureDots; i++) {
                // Use deterministic pseudo-random based on index
                const seed1 = Math.sin(i * 12.9898) * 43758.5453;
                const seed2 = Math.sin(i * 78.233) * 43758.5453;
                const seed3 = Math.sin(i * 45.164) * 43758.5453;
                const angle = (seed1 - Math.floor(seed1)) * Math.PI * 2;
                const dist = (seed2 - Math.floor(seed2)) * currentRadius * 0.9;
                const brightness = 40 + (seed3 - Math.floor(seed3)) * 25;
                ctx.fillStyle = `rgb(${brightness + 25}, ${brightness + 15}, ${brightness})`;
                const dotSize = 1 + (Math.sin(i * 23.14) * 0.5 + 0.5) * 2;
                ctx.beginPath();
                ctx.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.55, dotSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Entrance
            const entranceGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, currentRadius * 0.25);
            entranceGrad.addColorStop(0, '#080604');
            entranceGrad.addColorStop(0.6, '#100e0a');
            entranceGrad.addColorStop(1, '#2a2218');

            ctx.fillStyle = entranceGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.22, currentRadius * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Entrance rim
            ctx.strokeStyle = '#6a5838';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.25, currentRadius * 0.17, 0, Math.PI * 0.8, Math.PI * 0.2);
            ctx.stroke();
        }

        function drawFood() {
            for (const food of foodItems) food.draw();
        }

        function drawAnts() {
            for (const ant of ants) ant.draw();
        }

        function updateUI() {
            document.getElementById('coins').textContent = coins;
            document.getElementById('ant-count').textContent = ants.length;
            document.getElementById('food-collected').textContent = foodCollected;
            document.getElementById('survival-timer').textContent = formatTime(getElapsedSeconds());

            // Count ant types
            let workerCount = 0, soldierCount = 0, scoutCount = 0, carrierCount = 0, queenCount = 0;
            for (const ant of ants) {
                if (ant.type === 'worker') workerCount++;
                else if (ant.type === 'soldier') soldierCount++;
                else if (ant.type === 'scout') scoutCount++;
                else if (ant.type === 'carrier') carrierCount++;
                else if (ant.type === 'queen') queenCount++;
            }
            document.getElementById('worker-count').textContent = workerCount;
            document.getElementById('soldier-count').textContent = soldierCount;
            document.getElementById('scout-count').textContent = scoutCount;
            document.getElementById('carrier-count').textContent = carrierCount;
            document.getElementById('queen-count').textContent = queenCount;

            // Food buttons are always available (food is free in new system)
            // Disabled state is only set by cooldown system

            // Update ant button states and costs
            document.querySelectorAll('.ant-btn').forEach(btn => {
                const antType = btn.dataset.ant;
                const cost = getAntSpawnCost(antType);
                btn.classList.toggle('disabled', coins < cost || ants.length >= CONFIG.maxAnts);
            });

            // Update displayed costs
            updateAntCosts();
        }

        // ===========================================
        // INPUT HANDLING
        // ===========================================

        let selectedFoodType = null;
        let isPlacing = false;
        let lastPlaceTime = 0;
        let showHint = false;  // Disabled - no longer showing "click to drop food" hint
        let foodPlacementActive = false;
        let foodPlacementTimeout = null;

        // Food cooldown tracking - stores end timestamps for each food type
        const foodCooldowns = {
            sugar: 0,
            protein: 0,
            fruit: 0,
            feast: 0,
            nectar: 0
        };
        const FOOD_COOLDOWN_DURATION = 30000; // 30 seconds in milliseconds

        // Initialize cooldown overlays on food buttons
        function initFoodCooldownOverlays() {
            document.querySelectorAll('.food-btn').forEach(btn => {
                // Add position relative for overlay positioning
                btn.style.position = 'relative';

                // Create cooldown overlay element
                const overlay = document.createElement('div');
                overlay.className = 'cooldown-overlay';
                overlay.innerHTML = '<span class="cooldown-timer">30</span>';
                btn.appendChild(overlay);

                // Create progress bar
                const progress = document.createElement('div');
                progress.className = 'cooldown-progress';
                progress.style.width = '0%';
                btn.appendChild(progress);
            });
        }

        // Start cooldown for a specific food type
        function startFoodCooldown(foodType) {
            const endTime = Date.now() + FOOD_COOLDOWN_DURATION;
            foodCooldowns[foodType] = endTime;

            const btn = document.querySelector(`.food-btn[data-food="${foodType}"]`);
            if (btn) {
                btn.classList.add('on-cooldown');
            }
        }

        // Check if a food type is on cooldown
        function isFoodOnCooldown(foodType) {
            return Date.now() < foodCooldowns[foodType];
        }

        // Update all food cooldown timers
        function updateFoodCooldowns() {
            const now = Date.now();

            for (const foodType of Object.keys(foodCooldowns)) {
                const btn = document.querySelector(`.food-btn[data-food="${foodType}"]`);
                if (!btn) continue;

                const endTime = foodCooldowns[foodType];
                const remaining = endTime - now;

                if (remaining > 0) {
                    // Still on cooldown
                    const seconds = Math.ceil(remaining / 1000);
                    const timerEl = btn.querySelector('.cooldown-timer');
                    const progressEl = btn.querySelector('.cooldown-progress');

                    if (timerEl) {
                        timerEl.textContent = seconds;
                    }
                    if (progressEl) {
                        const progressPercent = (remaining / FOOD_COOLDOWN_DURATION) * 100;
                        progressEl.style.width = progressPercent + '%';
                    }

                    btn.classList.add('on-cooldown');
                } else {
                    // Cooldown finished
                    btn.classList.remove('on-cooldown');
                    const progressEl = btn.querySelector('.cooldown-progress');
                    if (progressEl) {
                        progressEl.style.width = '0%';
                    }
                }
            }
        }

        // Drag selection state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragCurrentX = 0;
        let dragCurrentY = 0;
        let dragThreshold = 10; // Minimum pixels to trigger drag vs click

        // Food placement functions removed - food auto-spawns in zones now
        function activateFoodPlacement(foodType) { }
        function deactivateFoodPlacement() { }

        // Food levels panel doesn't need click handlers

        // ===========================================
        // CHARACTER CARD SYSTEM
        // ===========================================

        let characterCardOpen = false;

        const ANT_CARD_DATA = {
            worker: {
                icon: '',
                title: 'Worker',
                subtitle: 'Colony Backbone',
                description: 'The reliable workhorse of the colony. Balanced stats make them versatile foragers that can survive a few hits.',
                stats: [
                    { name: 'HP', value: '10', class: '' },
                    { name: 'ATK', value: '2', class: '' },
                    { name: 'DEF', value: '2', class: '' },
                    { name: 'SPD', value: 'Normal', class: '' }
                ],
                traits: [
                    { text: 'Balanced', class: '' },
                    { text: 'Efficient Carrier', class: 'positive' },
                    { text: 'Common', class: '' }
                ]
            },
            soldier: {
                icon: '',
                title: 'Soldier',
                subtitle: 'Colony Defender',
                description: 'Fearless protectors with high HP and ATK. They deal real damage to predators and can take several hits before falling.',
                stats: [
                    { name: 'HP', value: '20', class: 'good' },
                    { name: 'ATK', value: '8', class: 'good' },
                    { name: 'DEF', value: '5', class: 'good' },
                    { name: 'SPD', value: 'Normal', class: '' }
                ],
                traits: [
                    { text: 'Brave', class: 'positive' },
                    { text: 'Damages Predators', class: 'special' },
                    { text: 'Combat Focus', class: 'positive' }
                ]
            },
            scout: {
                icon: '',
                title: 'Scout',
                subtitle: 'Swift Explorer',
                description: 'Fast but fragile! Scouts have low HP and DEF but excel at finding food and leaving strong pheromone trails.',
                stats: [
                    { name: 'HP', value: '6', class: 'bad' },
                    { name: 'ATK', value: '1', class: 'bad' },
                    { name: 'DEF', value: '1', class: 'bad' },
                    { name: 'SPD', value: 'Fast', class: 'good' }
                ],
                traits: [
                    { text: 'Swift', class: 'positive' },
                    { text: 'Trail Blazer', class: 'special' },
                    { text: 'Glass Cannon', class: 'negative' }
                ]
            },
            carrier: {
                icon: '',
                title: 'Carrier',
                subtitle: 'Heavy Lifter',
                description: 'Tank-like ants with the highest HP and DEF. Slow but incredibly durable, they can survive many predator attacks.',
                stats: [
                    { name: 'HP', value: '25', class: 'good' },
                    { name: 'ATK', value: '1', class: 'bad' },
                    { name: 'DEF', value: '6', class: 'good' },
                    { name: 'SPD', value: 'Slow', class: 'bad' }
                ],
                traits: [
                    { text: 'Tanky', class: 'positive' },
                    { text: 'Efficient Hauler', class: 'special' },
                    { text: 'Slow Walker', class: 'negative' }
                ]
            },
            queen: {
                icon: '',
                title: 'Queen',
                subtitle: 'Colony Mother',
                description: 'High HP makes the Queen a valuable asset to protect. She spawns workers and provides inspiration to nearby ants.',
                stats: [
                    { name: 'HP', value: '30', class: 'good' },
                    { name: 'ATK', value: '3', class: '' },
                    { name: 'DEF', value: '4', class: '' },
                    { name: 'SPD', value: 'Very Slow', class: 'bad' }
                ],
                traits: [
                    { text: 'Royal', class: 'special' },
                    { text: 'Spawns Workers', class: 'positive' },
                    { text: 'High Value Target', class: 'negative' }
                ]
            }
        };

        const PREDATOR_CARD_DATA = {
            spider: {
                icon: '',
                title: 'Spider',
                subtitle: 'Glass Cannon',
                description: 'A fast but fragile hunter. Low defense makes it easy to kill, but watch out for its speed!',
                stats: [
                    { name: 'HP', value: '40', class: 'neutral' },
                    { name: 'ATK', value: '4', class: 'neutral' },
                    { name: 'DEF', value: '1', class: 'good' },
                    { name: 'SPD', value: '1.8', class: 'bad' }
                ],
                traits: [
                    { text: 'Fast', class: 'negative' },
                    { text: 'Fragile', class: 'positive' },
                    { text: 'Respawns', class: 'negative' }
                ]
            },
            beetle: {
                icon: '',
                title: 'Beetle',
                subtitle: 'Armored Tank',
                description: 'A tanky predator with high HP and DEF but very low damage. Hard to kill but not very threatening.',
                stats: [
                    { name: 'HP', value: '60', class: 'bad' },
                    { name: 'ATK', value: '1', class: 'good' },
                    { name: 'DEF', value: '4', class: 'bad' },
                    { name: 'SPD', value: '0.5', class: 'good' }
                ],
                traits: [
                    { text: 'Armored', class: 'negative' },
                    { text: 'Weak Attack', class: 'positive' },
                    { text: 'Slow Patrol', class: 'positive' }
                ]
            }
        };

        // Helper to get stat class based on value comparison
        function getStatClass(value, baseline) {
            const ratio = value / baseline;
            if (ratio >= 1.35) return 'legendary';
            if (ratio >= 1.2) return 'exceptional';
            if (ratio >= 1.05) return 'good';
            if (ratio >= 0.95) return '';
            if (ratio >= 0.85) return 'weak';
            return 'poor';
        }

        // Generate dynamic card data for an individual ant
        function generateAntCardData(ant) {
            const baseData = ANT_CARD_DATA[ant.type];
            const typeConfig = CONFIG.antTypes[ant.type];
            const level = ant.getLevel();
            const xpTotal = ant.getTotalExp();
            const xpProgress = ant.getLevelProgress();
            const xpToNext = ant.getXpToNextLevel();

            // Calculate Pokemon-style stats
            const currentHp = ant.currentHp || ant.maxHp;
            const maxHp = ant.maxHp || typeConfig.hp;
            const atk = ant.atk || typeConfig.atk;
            const def = ant.def || typeConfig.def;
            const hpPercent = Math.round((currentHp / maxHp) * 100);

            // HP class based on current health
            const hpClass = hpPercent >= 75 ? 'good' : hpPercent >= 40 ? '' : hpPercent >= 20 ? 'weak' : 'bad';

            // Calculate effective ATK and DEF including permanent food bonuses
            const permAtkBonus = ant.permAtkBonus || 0;
            const permDefBonus = ant.permDefBonus || 0;
            const effectiveAtk = atk + permAtkBonus;

            // Calculate effective DEF including nest defense bonus
            let effectiveDef = def + permDefBonus;
            let hasNestBonus = false;
            if (upgradeMultipliers.nestDefenseBonus > 0) {
                const distToNest = Math.hypot(ant.x - CONFIG.nestX, ant.y - CONFIG.nestY);
                if (distToNest <= upgradeMultipliers.nestDefenseRadius) {
                    effectiveDef += upgradeMultipliers.nestDefenseBonus;
                    hasNestBonus = true;
                }
            }

            // Build ATK display string
            let atkDisplay = Math.round(effectiveAtk);
            if (permAtkBonus > 0) {
                atkDisplay = `${Math.round(effectiveAtk)} (+${permAtkBonus})`;
            }

            // Build DEF display string
            let defDisplay = Math.round(effectiveDef);
            const totalDefBonus = permDefBonus + (hasNestBonus ? upgradeMultipliers.nestDefenseBonus : 0);
            if (totalDefBonus > 0) {
                defDisplay = `${Math.round(effectiveDef)} (+${totalDefBonus})`;
            }

            // Build dynamic stats with Pokemon-style format
            const stats = [
                {
                    name: 'HP',
                    value: `${Math.round(currentHp)}/${Math.round(maxHp)}`,
                    class: hpClass,
                    hpData: { current: currentHp, max: maxHp }
                },
                {
                    name: 'ATK',
                    value: atkDisplay,
                    class: effectiveAtk >= 6 ? 'good' : effectiveAtk >= 3 ? '' : 'weak'
                },
                {
                    name: 'DEF',
                    value: defDisplay,
                    class: effectiveDef >= 5 ? 'good' : effectiveDef >= 3 ? '' : 'weak'
                },
                {
                    name: 'SPD',
                    value: (ant.speed * upgradeMultipliers.antSpeed).toFixed(2),
                    class: (ant.speed * upgradeMultipliers.antSpeed) >= 0.6 ? 'good' : (ant.speed * upgradeMultipliers.antSpeed) >= 0.4 ? '' : 'weak'
                },
                {
                    name: 'DET',
                    value: Math.round(ant.foodDetectRadius * upgradeMultipliers.detectionRadius),
                    class: (ant.foodDetectRadius * upgradeMultipliers.detectionRadius) >= 20 ? 'good' : (ant.foodDetectRadius * upgradeMultipliers.detectionRadius) >= 12 ? '' : 'weak'
                },
                {
                    name: 'CAP',
                    value: Math.round(ant.carryCapacity + upgradeMultipliers.carryCapacity),
                    class: (ant.carryCapacity + upgradeMultipliers.carryCapacity) >= 3 ? 'good' : (ant.carryCapacity + upgradeMultipliers.carryCapacity) >= 2 ? '' : 'weak'
                },
                {
                    name: 'PHER',
                    value: ant.pheromoneStrength.toFixed(1),
                    class: ant.pheromoneStrength >= 1.0 ? 'good' : ant.pheromoneStrength >= 0.7 ? '' : 'weak'
                }
            ];

            // Build dynamic traits
            const traits = [];

            // Level indicator first
            const levelClass = level >= 5 ? 'legendary' : level >= 4 ? 'exceptional' : level >= 3 ? 'good' : level >= 2 ? '' : 'weak';
            traits.push({ text: `Level ${level}`, class: levelClass });

            // Skill indicator if unlocked
            if (ant.hasSkill) {
                traits.push({ text: typeConfig.skillName, class: 'skill' });
            }

            // Add experience-based traits
            if (ant.experience.dangerDeliveries >= 10) {
                traits.push({ text: 'Daredevil', class: 'exceptional' });
            } else if (ant.experience.dangerDeliveries >= 5) {
                traits.push({ text: 'Risk Taker', class: 'good' });
            }

            if (ant.experience.totalDeliveries >= 30) {
                traits.push({ text: 'Veteran', class: 'exceptional' });
            } else if (ant.experience.totalDeliveries >= 15) {
                traits.push({ text: 'Hardworker', class: 'positive' });
            }

            if (ant.experience.predatorEscapes >= 5) {
                traits.push({ text: 'Survivor', class: 'legendary' });
            } else if (ant.experience.predatorEscapes >= 2) {
                traits.push({ text: 'Escapist', class: 'good' });
            }

            if (ant.experience.foodDiscovered >= 10) {
                traits.push({ text: 'Explorer', class: 'good' });
            }

            // Add trait-based special labels
            if (ant.traitRolls.speed >= 0.95) {
                traits.push({ text: 'Swift', class: 'legendary' });
            }
            if (ant.traitRolls.detection >= 0.95) {
                traits.push({ text: 'Sharp Eyes', class: 'legendary' });
            }
            if (ant.traitRolls.goldBonus >= 0.95) {
                traits.push({ text: 'Midas', class: 'legendary' });
            }

            // Type indicator at end
            traits.push({ text: baseData.title, class: '' });

            // Build description with experience info and skill details
            let desc = baseData.description;

            // Add skill description if unlocked
            if (ant.hasSkill) {
                desc += ` [${typeConfig.skillName}]: ${typeConfig.skillDesc}`;
            } else if (level < 3) {
                desc += ` Unlocks "${typeConfig.skillName}" at Level 3.`;
            }

            return {
                icon: baseData.icon,
                title: ant.name,
                subtitle: `Lv.${level} ${baseData.title}`,
                description: desc,
                stats: stats,
                traits: traits,
                // Additional data for enhanced card
                level: level,
                xpTotal: xpTotal,
                xpProgress: xpProgress,
                xpToNext: xpToNext,
                hasSkill: ant.hasSkill,
                skillName: typeConfig.skillName,
                deliveries: ant.experience.totalDeliveries,
                dangerDeliveries: ant.experience.dangerDeliveries,
                discoveries: ant.experience.foodDiscovered
            };
        }

        // Generate dynamic card data for a predator (spider or beetle)
        function generatePredatorCardData(predator, key) {
            const baseData = PREDATOR_CARD_DATA[key];
            const cfg = CONFIG.predators[key];

            // Calculate HP percentage for class
            const hpPercent = Math.round((predator.currentHp / predator.maxHp) * 100);
            const hpClass = hpPercent >= 75 ? 'bad' : hpPercent >= 40 ? 'neutral' : hpPercent >= 20 ? 'good' : 'weak';

            // Get speed value from predator or config
            const speedValue = predator.speed || cfg.speed || cfg.patrolSpeed || 1.0;
            const speedClass = speedValue >= 1.5 ? 'bad' : speedValue >= 1.0 ? 'neutral' : 'good';

            // Build dynamic stats
            const stats = [
                {
                    name: 'HP',
                    value: `${Math.round(predator.currentHp)}/${predator.maxHp}`,
                    class: hpClass
                },
                {
                    name: 'ATK',
                    value: Math.round(predator.atk),
                    class: predator.atk >= 12 ? 'bad' : predator.atk >= 8 ? 'neutral' : 'good'
                },
                {
                    name: 'DEF',
                    value: Math.round(predator.def),
                    class: predator.def >= 6 ? 'bad' : predator.def >= 3 ? 'neutral' : 'good'
                },
                {
                    name: 'SPD',
                    value: speedValue.toFixed(1),
                    class: speedClass
                }
            ];

            // Build dynamic traits based on current state
            const traits = [...baseData.traits];

            // Add health-based trait
            if (hpPercent <= 25) {
                traits.unshift({ text: 'Near Death', class: 'good' });
            } else if (hpPercent <= 50) {
                traits.unshift({ text: 'Wounded', class: 'positive' });
            }

            // Add state-based trait
            if (predator.state === 'stunned') {
                traits.unshift({ text: 'Stunned', class: 'positive' });
            } else if (predator.state === 'eating') {
                traits.unshift({ text: 'Feeding', class: 'negative' });
            } else if (predator.state === 'hunting') {
                traits.unshift({ text: 'Hunting', class: 'negative' });
            }

            return {
                icon: baseData.icon,
                title: baseData.title,
                subtitle: baseData.subtitle,
                description: baseData.description,
                stats: stats,
                traits: traits
            };
        }

        // Track update interval for real-time character card updates
        let cardUpdateInterval = null;

        // Stat tooltips explaining what each stat does
        const STAT_TOOLTIPS = {
            'HP': 'Health points. When HP reaches 0, the ant dies. Regenerates slowly over time.',
            'ATK': 'Attack power. Higher ATK deals more damage to predators in combat.',
            'DEF': 'Defense rating. Reduces damage taken from predator attacks.',
            'SPD': 'Movement speed while exploring. Improves with level and upgrades. Queen aura grants +25% bonus.',
            'DET': 'Detection radius for spotting food sources. Higher = spots food from further away.',
            'CAP': 'Carry capacity. Units of food carried per trip. Higher = more food delivered at once.',
            'PHER': 'Pheromone trail strength. Scouts leave stronger trails for others to follow.'
        };

        // Trait tooltips explaining what each trait means
        const TRAIT_TOOLTIPS = {
            // Level traits
            'Level 1': 'Novice ant, just starting out',
            'Level 2': 'Experienced ant with improved stats',
            'Level 3': 'Skilled ant - special ability unlocked!',
            'Level 4': 'Expert ant with significantly boosted stats',
            'Level 5': 'Master ant - maximum power achieved',
            // Experience-based traits
            'Daredevil': '10+ deliveries from danger zones - fearless!',
            'Risk Taker': '5+ deliveries from danger zones',
            'Veteran': '30+ total food deliveries',
            'Hardworker': '15+ total food deliveries',
            'Survivor': 'Escaped predators 5+ times - unkillable!',
            'Escapist': 'Escaped predators 2+ times',
            'Explorer': 'Discovered 10+ food sources',
            // Genetic traits
            'Swift': 'Born with exceptional speed (95%+ roll)',
            'Sharp Eyes': 'Born with exceptional detection (95%+ roll)',
            'Midas': 'Born with exceptional gold bonus (95%+ roll) - +95-100% gold per delivery!',
            // Skill traits (descriptions come from typeConfig)
            'Efficient Forager': 'Follows pheromone trails with 95% accuracy instead of 70%',
            'Berserker': '2x fight chance when colony suffered recent losses',
            'Trailblazer': 'Creates glowing beacon when discovering food',
            'Beast of Burden': 'No speed penalty when carrying food',
            'Royal Decree': 'Grants +25% speed to nearby ants',
            // Type traits
            'Worker': 'Standard colony worker - balanced stats',
            'Soldier': 'Combat specialist - fights predators',
            'Scout': 'Fast explorer - leaves strong trails',
            'Carrier': 'Heavy hauler - carries more food',
            'Queen': 'Colony leader - spawns new workers',
            // Ant type base traits
            'Balanced': 'Average stats across the board',
            'Efficient Carrier': 'Good at transporting food',
            'Common': 'Standard worker type',
            'Brave': 'Will fight instead of flee',
            'Patrols Danger': 'Actively seeks out predators',
            'May Die Fighting': 'Risk of death in combat',
            'Trail Blazer': 'Leaves extra strong pheromone trails',
            'Wide Explorer': 'Covers more ground while searching',
            'Strong': 'Can carry heavy loads',
            'Efficient Hauler': 'Minimal speed loss when loaded',
            'Slow Walker': 'Below average movement speed',
            'Royal': 'Leader of the colony',
            'Spawns Workers': 'Periodically creates new ants',
            'Stays Near Nest': 'Remains close to colony center',
            // Predator traits
            'Territorial': 'Guards a specific area',
            'Can Be Stunned': 'Soldiers can temporarily disable',
            'Deadly Strike': 'Instant kill on contact',
            'Fast': 'High movement speed',
            'Unpredictable': 'Erratic movement patterns',
            'Armored': 'Resistant to damage',
            'Slow Moving': 'Easy to outrun'
        };

        // Stat ranges for bar percentage calculation
        // Each stat has a min and max defining the expected range
        // Bar fills based on where the value falls in this range
        const STAT_RANGES = {
            'HP': { min: 0, max: 50 },      // 10 is typical worker, 50 is high
            'ATK': { min: 0, max: 15 },     // 2 is typical, 10+ is high
            'DEF': { min: 0, max: 10 },     // 2 is typical, 8+ is high
            'SPD': { min: 0.2, max: 1.0 },  // 0.5 is typical, 0.8+ is fast
            'DET': { min: 5, max: 40 },     // 15 is typical, 30+ is high
            'CAP': { min: 1, max: 10 },     // 1-2 is typical, 5+ is high
            'PHER': { min: 0.3, max: 2.0 }  // 0.8 is typical, 1.5+ is high
        };

        // Calculate bar percentage for a stat
        function getStatBarPercent(statName, value, antType) {
            // Check if we have a defined range for this stat
            const range = STAT_RANGES[statName];
            if (range) {
                // Parse the value - for HP, extract first number from "x/y" format
                let numValue;
                if (statName === 'HP' && typeof value === 'string' && value.includes('/')) {
                    // For HP bar, use max HP (second value) to show the stat quality
                    numValue = parseFloat(value.split('/')[1]) || 0;
                } else {
                    numValue = parseFloat(value) || 0;
                }

                // Calculate percentage: ((value - min) / (max - min)) * 100, clamped to 0-100
                const percent = ((numValue - range.min) / (range.max - range.min)) * 100;
                return Math.max(0, Math.min(100, percent));
            }

            // Fallback for legacy stat names (for compatibility)
            const typeConfig = CONFIG.antTypes[antType] || CONFIG.antTypes.worker;
            const levelBonuses = typeConfig.levelBonuses || {};
            let baseline, max;

            switch(statName) {
                case 'Speed':
                    baseline = typeConfig.speed;
                    max = baseline + (levelBonuses.speed || 0) * 4 * 1.4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Capacity':
                    baseline = typeConfig.carryCapacity;
                    max = baseline + (levelBonuses.carryCapacity || 0) * 4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Detection':
                    baseline = typeConfig.foodDetectRadius;
                    max = baseline + (levelBonuses.foodDetectRadius || 0) * 4 * 1.4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Combat':
                    const fightChance = parseInt(value.split('/')[0]) || 0;
                    return Math.min(100, fightChance * 1.25);
                case 'Trail':
                    return Math.min(100, parseFloat(value) / 2.3);
                case 'Spawn':
                    const secs = parseInt(value) || 15;
                    return Math.min(100, (20 - secs) * 10);
                case 'Haul':
                    return Math.min(100, parseFloat(value));
                case 'Gold':
                    return parseFloat(value.replace(/[+%]/g, ''));
                default:
                    return 50;
            }
        }

        // Generate dynamic HP tooltip showing current/max HP
        function getHpTooltip(currentHp, maxHp) {
            const hpPercent = Math.round((currentHp / maxHp) * 100);
            let status, statusClass;

            if (hpPercent >= 90) {
                status = 'Healthy';
                statusClass = 'good';
            } else if (hpPercent >= 75) {
                status = 'Minor wounds';
                statusClass = 'good';
            } else if (hpPercent >= 50) {
                status = 'Injured';
                statusClass = '';
            } else if (hpPercent >= 25) {
                status = 'Badly hurt';
                statusClass = 'weak';
            } else {
                status = 'Critical!';
                statusClass = 'bad';
            }

            return `<span class="hp-current">${currentHp}</span>/<span class="hp-max">${maxHp}</span> HP (${hpPercent}%)<br><span class="hp-status ${statusClass}">${status}</span><br><small>Regenerates slowly over time</small>`;
        }

        function showCharacterCard(data, ant = null, predator = null, predatorKey = null) {
            selectedAnt = ant;
            selectedPredator = predator;
            selectedPredatorKey = predatorKey;
            const card = document.getElementById('character-card');

            // Update basic info
            document.getElementById('card-icon').textContent = data.icon;
            document.getElementById('card-title').textContent = data.title;
            document.getElementById('card-subtitle').textContent = data.subtitle;
            document.getElementById('card-description').textContent = data.description;

            // Update experience section (only for ants)
            const expSection = document.getElementById('card-exp-section');
            if (ant && ant.experience) {
                expSection.style.display = 'block';

                const level = ant.getLevel();
                const xpProgress = ant.getLevelProgress();
                const xpToNext = ant.getXpToNextLevel();
                const xpTotal = ant.getTotalExp();

                // Level progress bar
                const levelBarHtml = level >= 5
                    ? `<div class="level-bar-container">
                        <div class="level-bar max" style="width: 100%"></div>
                        <span class="level-text">MAX LEVEL</span>
                       </div>`
                    : `<div class="level-bar-container">
                        <div class="level-bar" style="width: ${xpProgress}%"></div>
                        <span class="level-text">${xpToNext} XP to Lv.${level + 1}</span>
                       </div>`;

                document.getElementById('exp-value').innerHTML = `
                    <div class="level-display">
                        <span class="level-number">Lv.${level}</span>
                        <span class="xp-total">${xpTotal} XP</span>
                    </div>
                    ${levelBarHtml}
                `;

                document.getElementById('exp-details').innerHTML = `
                    <div class="exp-detail">
                        <span class="count">${ant.experience.totalDeliveries}</span> deliveries
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.dangerDeliveries}</span> danger
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.foodDiscovered}</span> found
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.predatorEscapes}</span> escapes
                    </div>
                `;
                document.getElementById('card-id').textContent = `ID: #${String(ant.id).padStart(3, '0')}`;
            } else {
                expSection.style.display = 'none';
                document.getElementById('card-id').textContent = 'PREDATOR';
            }

            // Build stats HTML with bars, tooltips, and starting markers
            let statsHtml = '';
            for (const stat of data.stats) {
                // Use dynamic HP tooltip if available, otherwise use static tooltip
                let tooltip;
                if (stat.name === 'HP' && stat.hpData) {
                    tooltip = getHpTooltip(stat.hpData.current, stat.hpData.max);
                } else {
                    tooltip = STAT_TOOLTIPS[stat.name] || '';
                }
                const barPercent = ant ? getStatBarPercent(stat.name, stat.value, ant.type) : 50;
                const barClass = stat.class || 'default';

                // Calculate starting stat marker position
                let startMarkerHtml = '';
                if (ant && stat.startValue !== undefined) {
                    const startPercent = getStatBarPercent(stat.name, stat.startValue, ant.type);
                    // Only show marker if there's been progress (current > start by more than 1%)
                    if (barPercent > startPercent + 1) {
                        startMarkerHtml = `<div class="stat-start-marker" style="left: ${startPercent}%"></div>`;
                    }
                }

                statsHtml += `<div class="stat-item" data-stat="${stat.name}">
                    <div class="stat-header">
                        <span class="stat-name">${stat.name}</span>
                        <span class="stat-val ${stat.class}">${stat.value}</span>
                    </div>
                    <div class="stat-bar-container">
                        ${startMarkerHtml}
                        <div class="stat-bar ${barClass}" style="width: ${barPercent}%"></div>
                    </div>
                    ${tooltip ? `<div class="stat-tooltip">${tooltip}</div>` : ''}
                </div>`;
            }
            document.getElementById('card-stats').innerHTML = statsHtml;

            // Build traits HTML with tooltips
            let traitsHtml = '';
            for (const trait of data.traits) {
                const tooltip = TRAIT_TOOLTIPS[trait.text] || '';
                const tooltipHtml = tooltip ? `<span class="trait-tooltip">${tooltip}</span>` : '';
                traitsHtml += `<span class="trait-tag ${trait.class}">${trait.text}${tooltipHtml}</span>`;
            }
            document.getElementById('card-traits').innerHTML = traitsHtml;

            card.classList.remove('hidden');
            characterCardOpen = true;

            // Start real-time updates for ants or predators
            if (cardUpdateInterval) clearInterval(cardUpdateInterval);
            cardUpdateInterval = setInterval(() => {
                if (characterCardOpen) {
                    if (selectedAnt) {
                        updateCardRealTime();
                    } else if (selectedPredator) {
                        updatePredatorCardRealTime();
                    }
                }
            }, 200);  // Faster updates for smoother HP display
        }

        // Real-time update function for the card
        function updateCardRealTime() {
            if (!selectedAnt || !characterCardOpen) return;

            // Check if ant still exists
            if (!ants.includes(selectedAnt)) {
                closeCharacterCard();
                return;
            }

            const ant = selectedAnt;
            const level = ant.getLevel();
            const xpProgress = ant.getLevelProgress();
            const xpToNext = ant.getXpToNextLevel();
            const xpTotal = ant.getTotalExp();

            // Update level number and XP - use querySelector to update specific elements
            const levelNum = document.querySelector('.level-number');
            const xpTotalEl = document.querySelector('.xp-total');
            const levelBar = document.querySelector('.level-bar');
            const levelText = document.querySelector('.level-text');

            if (levelNum) levelNum.textContent = `Lv.${level}`;
            if (xpTotalEl) xpTotalEl.textContent = `${xpTotal} XP`;
            if (levelBar) {
                levelBar.style.width = level >= 5 ? '100%' : `${xpProgress}%`;
                if (level >= 5 && !levelBar.classList.contains('max')) {
                    levelBar.classList.add('max');
                }
            }
            if (levelText) {
                levelText.textContent = level >= 5 ? 'MAX LEVEL' : `${xpToNext} XP to Lv.${level + 1}`;
            }

            // Update exp detail counts only (not full rebuild)
            const expDetails = document.querySelectorAll('.exp-detail .count');
            if (expDetails.length >= 4) {
                expDetails[0].textContent = ant.experience.totalDeliveries;
                expDetails[1].textContent = ant.experience.dangerDeliveries;
                expDetails[2].textContent = ant.experience.foodDiscovered;
                expDetails[3].textContent = ant.experience.predatorEscapes;
            }

            // Update subtitle with current level
            const baseData = ANT_CARD_DATA[ant.type];
            document.getElementById('card-subtitle').textContent = `Lv.${level} ${baseData.title}`;

            // Update stat values and bars without rebuilding (preserves hover state)
            const cardData = generateAntCardData(ant);
            const statItems = document.querySelectorAll('.stat-item');

            cardData.stats.forEach((stat, index) => {
                if (statItems[index]) {
                    const valEl = statItems[index].querySelector('.stat-val');
                    const barEl = statItems[index].querySelector('.stat-bar');
                    const tooltipEl = statItems[index].querySelector('.stat-tooltip');

                    if (valEl) {
                        valEl.textContent = stat.value;
                        valEl.className = `stat-val ${stat.class || ''}`;
                    }
                    if (barEl) {
                        const barPercent = getStatBarPercent(stat.name, stat.value, ant.type);
                        barEl.style.width = `${barPercent}%`;
                        barEl.className = `stat-bar ${stat.class || 'default'}`;
                    }
                    // Update HP tooltip dynamically
                    if (stat.name === 'HP' && stat.hpData && tooltipEl) {
                        tooltipEl.innerHTML = getHpTooltip(stat.hpData.current, stat.hpData.max);
                    }
                }
            });

            // Only rebuild traits if skill status changed (rare)
            const currentTraitCount = document.querySelectorAll('.trait-tag').length;
            if (currentTraitCount !== cardData.traits.length) {
                let traitsHtml = '';
                for (const trait of cardData.traits) {
                    const tooltip = TRAIT_TOOLTIPS[trait.text] || '';
                    const tooltipHtml = tooltip ? `<span class="trait-tooltip">${tooltip}</span>` : '';
                    traitsHtml += `<span class="trait-tag ${trait.class}">${trait.text}${tooltipHtml}</span>`;
                }
                document.getElementById('card-traits').innerHTML = traitsHtml;
            }
        }

        function closeCharacterCard() {
            document.getElementById('character-card').classList.add('hidden');
            characterCardOpen = false;
            selectedAnt = null;
            selectedPredator = null;
            selectedPredatorKey = null;
            if (cardUpdateInterval) {
                clearInterval(cardUpdateInterval);
                cardUpdateInterval = null;
            }
        }

        // Real-time update function for predator cards
        function updatePredatorCardRealTime() {
            if (!selectedPredator || !selectedPredatorKey || !characterCardOpen) return;

            // Check if predator still exists
            const predatorArray = selectedPredatorKey === 'spider' ? spiderPredators : beetlePredators;
            if (!predatorArray.includes(selectedPredator)) {
                closeCharacterCard();
                return;
            }

            const predator = selectedPredator;
            const cardData = generatePredatorCardData(predator, selectedPredatorKey);

            // Update stat values and bars without rebuilding
            const statItems = document.querySelectorAll('.stat-item');
            cardData.stats.forEach((stat, index) => {
                if (statItems[index]) {
                    const valEl = statItems[index].querySelector('.stat-val');
                    const barEl = statItems[index].querySelector('.stat-bar');

                    if (valEl) {
                        valEl.textContent = stat.value;
                        valEl.className = `stat-val ${stat.class || ''}`;
                    }
                    if (barEl) {
                        const barPercent = getPredatorStatBarPercent(stat.name, stat.value, selectedPredatorKey);
                        barEl.style.width = `${barPercent}%`;
                        barEl.className = `stat-bar ${stat.class || 'default'}`;
                    }
                }
            });

            // Update traits if they changed
            const currentTraitCount = document.querySelectorAll('.trait-tag').length;
            if (currentTraitCount !== cardData.traits.length) {
                let traitsHtml = '';
                for (const trait of cardData.traits) {
                    const tooltip = TRAIT_TOOLTIPS[trait.text] || '';
                    const tooltipHtml = tooltip ? `<span class="trait-tooltip">${tooltip}</span>` : '';
                    traitsHtml += `<span class="trait-tag ${trait.class}">${trait.text}${tooltipHtml}</span>`;
                }
                document.getElementById('card-traits').innerHTML = traitsHtml;
            }
        }

        // Helper to get predator stat bar percentage
        function getPredatorStatBarPercent(statName, value, predatorKey) {
            const cfg = CONFIG.predators[predatorKey];
            switch (statName) {
                case 'HP':
                    const [current, max] = String(value).split('/').map(Number);
                    return (current / max) * 100;
                case 'ATK':
                    return Math.min((parseFloat(value) / 20) * 100, 100);
                case 'DEF':
                    return Math.min((parseFloat(value) / 10) * 100, 100);
                case 'SPD':
                    return Math.min((parseFloat(value) / 3) * 100, 100);
                default:
                    return 50;
            }
        }

        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            panel.classList.toggle('collapsed');
        }

        function findClickedEntity(x, y) {
            // Check predators first (larger click targets)
            for (const { predator, key } of getAllPredatorsWithKeys()) {
                const dist = Math.hypot(predator.x - x, predator.y - y);
                if (dist < 30) {
                    return { type: 'predator', key: key, predator: predator };
                }
            }

            // Check ants
            for (const ant of ants) {
                const dist = Math.hypot(ant.x - x, ant.y - y);
                if (dist < 15) {
                    return { type: 'ant', ant: ant };
                }
            }

            return null;
        }

        function findAntsInRect(x1, y1, x2, y2) {
            // Normalize rectangle coordinates
            const left = Math.min(x1, x2);
            const right = Math.max(x1, x2);
            const top = Math.min(y1, y2);
            const bottom = Math.max(y1, y2);

            const foundAnts = [];
            for (const ant of ants) {
                if (ant.x >= left && ant.x <= right && ant.y >= top && ant.y <= bottom) {
                    foundAnts.push(ant);
                }
            }
            return foundAnts;
        }

        function findEntitiesInRect(x1, y1, x2, y2) {
            // Normalize rectangle coordinates
            const left = Math.min(x1, x2);
            const right = Math.max(x1, x2);
            const top = Math.min(y1, y2);
            const bottom = Math.max(y1, y2);

            const entities = [];

            // Check predators
            for (const { predator, key } of getAllPredatorsWithKeys()) {
                if (predator.x >= left && predator.x <= right && predator.y >= top && predator.y <= bottom) {
                    entities.push({ type: 'predator', key: key, predator: predator });
                }
            }

            // Check ants
            for (const ant of ants) {
                if (ant.x >= left && ant.x <= right && ant.y >= top && ant.y <= bottom) {
                    entities.push({ type: 'ant', ant: ant });
                }
            }

            return entities;
        }

        function drawSelectionRect() {
            if (!isDragging) return;

            const left = Math.min(dragStartX, dragCurrentX);
            const top = Math.min(dragStartY, dragCurrentY);
            const right = Math.max(dragStartX, dragCurrentX);
            const bottom = Math.max(dragStartY, dragCurrentY);
            const w = right - left;
            const h = bottom - top;

            if (w < dragThreshold && h < dragThreshold) return;

            ctx.save();

            // Semi-transparent fill
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(left, top, w, h);

            // Animated dashed border
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.lineDashOffset = -Date.now() / 50;
            ctx.strokeRect(left, top, w, h);

            // Corner accents
            const cornerSize = 12;
            ctx.setLineDash([]);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 8;

            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(left, top + cornerSize);
            ctx.lineTo(left, top);
            ctx.lineTo(left + cornerSize, top);
            ctx.stroke();

            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, top);
            ctx.lineTo(right, top);
            ctx.lineTo(right, top + cornerSize);
            ctx.stroke();

            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(left, bottom - cornerSize);
            ctx.lineTo(left, bottom);
            ctx.lineTo(left + cornerSize, bottom);
            ctx.stroke();

            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, bottom);
            ctx.lineTo(right, bottom);
            ctx.lineTo(right, bottom - cornerSize);
            ctx.stroke();

            // Show count of entities in selection
            const entitiesInRect = findEntitiesInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
            if (entitiesInRect.length > 0) {
                const antCount = entitiesInRect.filter(e => e.type === 'ant').length;
                const predatorCount = entitiesInRect.filter(e => e.type === 'predator').length;

                ctx.shadowBlur = 12;
                ctx.font = 'bold 14px "Orbitron", monospace';

                // Build text based on what's selected
                let text = '';
                if (antCount > 0 && predatorCount > 0) {
                    text = `${antCount} ANT${antCount > 1 ? 'S' : ''} + ${predatorCount} PREDATOR${predatorCount > 1 ? 'S' : ''}`;
                } else if (antCount > 0) {
                    text = `${antCount} ANT${antCount > 1 ? 'S' : ''}`;
                } else if (predatorCount > 0) {
                    text = `${predatorCount} PREDATOR${predatorCount > 1 ? 'S' : ''}`;
                }

                const metrics = ctx.measureText(text);
                const padding = 8;
                const boxWidth = metrics.width + padding * 2;
                const boxHeight = 24;
                const boxX = left + w / 2 - boxWidth / 2;
                const boxY = top - boxHeight - 8;

                // Background
                ctx.fillStyle = 'rgba(0, 20, 10, 0.95)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = predatorCount > 0 ? '#ff6666' : '#00ff88';
                ctx.lineWidth = 1;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // Text
                ctx.fillStyle = predatorCount > 0 ? '#ff6666' : '#00ff88';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, left + w / 2, boxY + boxHeight / 2);
            }

            ctx.restore();
        }

        function placeFood(x, y) {
            // Only place food if placement mode is active
            if (!foodPlacementActive || !selectedFoodType) return false;

            const now = Date.now();
            const minInterval = selectedFoodType === 'sugar' ? 100 : 200;
            if (now - lastPlaceTime < minInterval) return false;
            lastPlaceTime = now;

            // Check if position is within a food spot
            let inFoodSpot = false;
            for (const spot of foodSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius) {
                    inFoodSpot = true;
                    break;
                }
            }
            if (!inFoodSpot) return false;

            if (addFood(x, y, selectedFoodType)) {
                showHint = false;

                // Start cooldown for this food type
                const placedFoodType = selectedFoodType;
                startFoodCooldown(placedFoodType);

                // Deactivate placement mode since food is now on cooldown
                deactivateFoodPlacement();

                return true;
            }
            return false;
        }

        let wasDragging = false; // Track if we just finished a drag

        // Assign food zone multipliers based on distance from hive
        // Nearest = x1, Middle = x2, Furthest = x3
        function assignFoodZoneMultipliers() {
            if (foodSpots.length === 0) return;

            // Calculate distance from each food spot to the nest
            const spotsWithDistance = foodSpots.map((spot, index) => ({
                spot: spot,
                index: index,
                distance: Math.hypot(spot.x - CONFIG.nestX, spot.y - CONFIG.nestY)
            }));

            // Sort by distance (nearest first)
            spotsWithDistance.sort((a, b) => a.distance - b.distance);

            // Assign multipliers: x1 for nearest, x2 for middle, x3 for furthest
            const multipliers = [1, 2, 3];
            spotsWithDistance.forEach((item, i) => {
                item.spot.multiplier = multipliers[Math.min(i, multipliers.length - 1)];
            });
        }

        // Get the food zone multiplier for a given position
        function getFoodZoneMultiplier(x, y) {
            for (const spot of foodSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius) {
                    return spot.multiplier || 1;
                }
            }
            return 1; // Default multiplier outside food zones
        }

        // Preview multipliers during hive placement (temporary, not saved to spots)
        let previewMultipliers = new Map();
        let isPreviewingHivePlacement = false;

        // Calculate preview multipliers based on hypothetical hive position
        function calculatePreviewMultipliers(hiveX, hiveY) {
            if (foodSpots.length === 0) return;

            // Calculate distance from each food spot to the hypothetical hive position
            const spotsWithDistance = foodSpots.map((spot, index) => ({
                spot: spot,
                index: index,
                distance: Math.hypot(spot.x - hiveX, spot.y - hiveY)
            }));

            // Sort by distance (nearest first)
            spotsWithDistance.sort((a, b) => a.distance - b.distance);

            // Assign preview multipliers: x1 for nearest, x2 for middle, x3 for furthest
            const multipliers = [1, 2, 3];
            previewMultipliers.clear();
            spotsWithDistance.forEach((item, i) => {
                previewMultipliers.set(item.spot, multipliers[Math.min(i, multipliers.length - 1)]);
            });
        }

        // Get the multiplier to display (preview during placement, actual otherwise)
        function getDisplayMultiplier(spot) {
            if (isPreviewingHivePlacement && previewMultipliers.has(spot)) {
                return previewMultipliers.get(spot);
            }
            return spot.multiplier || 1;
        }

        // Hive placement function - called when player clicks to place hive at game start
        function placeHive(x, y) {
            if (gameStarted) return;

            // Set the nest position to where the player clicked
            CONFIG.nestX = x;
            CONFIG.nestY = y;

            // Assign food zone multipliers based on distance from hive
            // Sort food spots by distance and assign x1, x2, x3 multipliers
            assignFoodZoneMultipliers();

            // Initialize food in all zones (auto-spawned, no manual placement)
            initFoodInZones();

            // Initialize ants at the new hive location
            ants = [];
            for (let i = 0; i < CONFIG.initialAnts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * CONFIG.nestRadius * 0.7;
                ants.push(new Ant(CONFIG.nestX + Math.cos(angle) * dist, CONFIG.nestY + Math.sin(angle) * dist, 'worker'));
            }
            totalAntsSpawned = ants.length;

            // Start the game
            gameStarted = true;
            gameStartTime = Date.now();
            pausedTime = 0;
            pauseStartTime = null;

            // Initialize cycle timer for food rework
            initCycleTimer();

            // Hide the placement overlay and hive cursor
            document.getElementById('hive-placement-overlay').classList.add('hidden');
            document.getElementById('hive-cursor').classList.add('hidden');
            isPreviewingHivePlacement = false;
            previewMultipliers.clear();
        }

        // Add click handler to hive placement overlay
        document.getElementById('hive-placement-overlay').addEventListener('click', (e) => {
            placeHive(e.clientX, e.clientY);
        });

        // Add touch handler to hive placement overlay
        document.getElementById('hive-placement-overlay').addEventListener('touchend', (e) => {
            if (e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                placeHive(touch.clientX, touch.clientY);
            }
        });

        // Add mousemove handler for hive cursor and multiplier preview
        document.getElementById('hive-placement-overlay').addEventListener('mousemove', (e) => {
            const hiveCursor = document.getElementById('hive-cursor');

            // Update hive cursor position
            hiveCursor.style.left = e.clientX + 'px';
            hiveCursor.style.top = e.clientY + 'px';
            hiveCursor.classList.remove('hidden');

            // Calculate and update preview multipliers
            isPreviewingHivePlacement = true;
            calculatePreviewMultipliers(e.clientX, e.clientY);
        });

        // Show hive cursor when mouse enters overlay
        document.getElementById('hive-placement-overlay').addEventListener('mouseenter', (e) => {
            const hiveCursor = document.getElementById('hive-cursor');
            hiveCursor.classList.remove('hidden');
            isPreviewingHivePlacement = true;
        });

        // Hide hive cursor when mouse leaves overlay
        document.getElementById('hive-placement-overlay').addEventListener('mouseleave', (e) => {
            const hiveCursor = document.getElementById('hive-cursor');
            hiveCursor.classList.add('hidden');
            isPreviewingHivePlacement = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // Handle hive placement at game start
            if (!gameStarted) {
                placeHive(e.clientX, e.clientY);
                return;
            }

            // If card is open, close it and don't start drag
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            // Start potential drag selection
            isDragging = true;
            wasDragging = false;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragCurrentX = e.clientX;
            dragCurrentY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            // Handle selection drag
            if (isDragging) {
                dragCurrentX = e.clientX;
                dragCurrentY = e.clientY;

                // Check if we've exceeded the threshold to be considered a drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                if (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold) {
                    wasDragging = true;
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isPlacing = false;

            if (isDragging) {
                isDragging = false;

                // Check if this was a significant drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                const wasDragSelection = Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold;

                if (wasDragSelection) {
                    // Find all entities (ants and predators) in selection rectangle
                    const selectedEntities = findEntitiesInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
                    if (selectedEntities.length > 0) {
                        // Select a random entity from the selection
                        const randomEntity = selectedEntities[Math.floor(Math.random() * selectedEntities.length)];
                        if (randomEntity.type === 'ant') {
                            showCharacterCard(generateAntCardData(randomEntity.ant), randomEntity.ant);
                        } else if (randomEntity.type === 'predator') {
                            showCharacterCard(generatePredatorCardData(randomEntity.predator, randomEntity.key), null, randomEntity.predator, randomEntity.key);
                        }
                    }
                    wasDragging = false;
                    return;
                }
            }

            // Only process click if we weren't dragging
            if (!wasDragging && !foodPlacementActive) {
                const entity = findClickedEntity(e.clientX, e.clientY);
                if (entity) {
                    if (entity.type === 'ant') {
                        showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                    } else if (entity.type === 'predator') {
                        showCharacterCard(generatePredatorCardData(entity.predator, entity.key), null, entity.predator, entity.key);
                    }
                }
            }
            wasDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isPlacing = false;
            isDragging = false;
            wasDragging = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            // Handle hive placement at game start
            if (!gameStarted) {
                placeHive(touchX, touchY);
                return;
            }

            // If card is open, close it on any touch
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            // Check if touching an entity
            const entity = findClickedEntity(touchX, touchY);
            if (entity) {
                if (entity.type === 'ant') {
                    showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                } else if (entity.type === 'predator') {
                    showCharacterCard(generatePredatorCardData(entity.predator, entity.key), null, entity.predator, entity.key);
                }
                return;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            // Food placement removed - auto-spawns now
        });

        canvas.addEventListener('touchend', () => isPlacing = false);

        // ===========================================
        // HARVEST CYCLE SYSTEM
        // ===========================================

        let harvestModalOpen = false;

        // Initialize cycle timer when game starts
        function initCycleTimer() {
            cycleStartTime = Date.now();
            lastCycleTime = Date.now();
        }

        // Update cycle timer UI based on upgrade time (no longer triggers anything)
        function updateCycleTimerUI() {
            if (harvestModalOpen) return;

            // Calculate time remaining until next upgrade/harvest
            const elapsed = getElapsedSeconds();
            const timeSinceLastUpgrade = elapsed - lastUpgradeTime;
            const remaining = Math.max(0, UPGRADE_INTERVAL - timeSinceLastUpgrade);
            const seconds = Math.ceil(remaining);

            // Update UI
            const countdownEl = document.getElementById('cycle-countdown');
            const barFillEl = document.getElementById('cycle-bar-fill');
            if (countdownEl) countdownEl.textContent = seconds + 's';
            if (barFillEl) barFillEl.style.width = (remaining / UPGRADE_INTERVAL * 100) + '%';

            // Update preview stats
            updatePreviewStats();

            // Update food level displays
            updateFoodLevelDisplays();
        }

        // Update the preview stats display
        function updatePreviewStats() {
            const previewEl = document.getElementById('preview-stats');
            if (!previewEl) return;

            const parts = [];
            if (accumulatedBonuses.hp > 0) parts.push(`HP+${accumulatedBonuses.hp}`);
            if (accumulatedBonuses.atk > 0) parts.push(`ATK+${accumulatedBonuses.atk}`);
            if (accumulatedBonuses.def > 0) parts.push(`DEF+${accumulatedBonuses.def}`);
            if (accumulatedBonuses.carry > 0) parts.push(`CARRY+${accumulatedBonuses.carry}`);

            previewEl.textContent = parts.length > 0 ? parts.join(' ') : '--';
        }

        // Update food level displays in the UI
        function updateFoodLevelDisplays() {
            for (const foodType of Object.keys(foodLevels)) {
                const levelEl = document.getElementById(`${foodType}-level`);
                if (levelEl) {
                    const level = foodLevels[foodType];
                    levelEl.textContent = level;  // Just the number
                    if (level >= 10) {
                        levelEl.classList.add('max-level');
                    } else {
                        levelEl.classList.remove('max-level');
                    }
                }
            }
        }

        // Trigger harvest summary modal
        function triggerHarvestSummary() {
            harvestModalOpen = true;

            // Populate the modal
            const deliveriesEl = document.getElementById('harvest-deliveries');
            const hpEl = document.getElementById('harvest-hp');
            const atkEl = document.getElementById('harvest-atk');
            const defEl = document.getElementById('harvest-def');
            const carryEl = document.getElementById('harvest-carry');
            const abilitiesEl = document.getElementById('harvest-abilities');

            // Show delivered food icons
            if (deliveriesEl) {
                if (cycleDeliveries.length > 0) {
                    deliveriesEl.innerHTML = cycleDeliveries.map((d, i) =>
                        `<span class="harvest-food-icon" style="animation-delay: ${i * 0.1}s">${d.emoji}</span>`
                    ).join('');
                } else {
                    deliveriesEl.innerHTML = '<div class="harvest-no-deliveries">No food delivered this cycle</div>';
                }
            }

            // Show accumulated stats
            if (hpEl) {
                hpEl.textContent = `+${accumulatedBonuses.hp}`;
                hpEl.classList.toggle('has-bonus', accumulatedBonuses.hp > 0);
            }
            if (atkEl) {
                atkEl.textContent = `+${accumulatedBonuses.atk}`;
                atkEl.classList.toggle('has-bonus', accumulatedBonuses.atk > 0);
            }
            if (defEl) {
                defEl.textContent = `+${accumulatedBonuses.def}`;
                defEl.classList.toggle('has-bonus', accumulatedBonuses.def > 0);
            }
            if (carryEl) {
                carryEl.textContent = `+${accumulatedBonuses.carry}`;
                carryEl.classList.toggle('has-bonus', accumulatedBonuses.carry > 0);
            }

            // Show abilities
            if (abilitiesEl) {
                if (accumulatedBonuses.abilities.length > 0) {
                    abilitiesEl.innerHTML = accumulatedBonuses.abilities.map(ability => {
                        const bonus = Object.values(FOOD_BONUSES).find(b => b.ability === ability);
                        const name = bonus ? bonus.abilityName : ability;
                        return `<span class="harvest-ability">${name}</span>`;
                    }).join('');
                } else {
                    abilitiesEl.innerHTML = '';
                }
            }

            // Show modal
            const modal = document.getElementById('harvest-modal');
            if (modal) modal.classList.add('visible');
        }

        // Spawn ant with accumulated bonuses
        function spawnHarvestAnt() {
            if (gameOver) return;

            // Only spawn if there are any bonuses accumulated or we have deliveries
            const hasAnyBonus = accumulatedBonuses.hp > 0 || accumulatedBonuses.atk > 0 ||
                               accumulatedBonuses.def > 0 || accumulatedBonuses.carry > 0 ||
                               cycleDeliveries.length > 0;

            if (hasAnyBonus && ants.length < CONFIG.maxAnts) {
                // Create new ant at hive
                const angle = Math.random() * Math.PI * 2;
                const spawnDist = getColonySize() * 0.3;
                const newAnt = new Ant(
                    CONFIG.nestX + Math.cos(angle) * spawnDist,
                    CONFIG.nestY + Math.sin(angle) * spawnDist,
                    'worker'
                );

                // Apply accumulated bonuses
                newAnt.permHpBonus = (newAnt.permHpBonus || 0) + accumulatedBonuses.hp;
                newAnt.maxHp += accumulatedBonuses.hp;
                newAnt.currentHp = newAnt.maxHp;
                newAnt.permAtkBonus = (newAnt.permAtkBonus || 0) + accumulatedBonuses.atk;
                newAnt.permDefBonus = (newAnt.permDefBonus || 0) + accumulatedBonuses.def;
                newAnt.carryCapacity += accumulatedBonuses.carry;

                // Apply abilities
                newAnt.harvestAbilities = [...accumulatedBonuses.abilities];

                ants.push(newAnt);
                totalAntsSpawned++;
                addSpawnNotification('worker');

                // Show birth effect
                spawnFloatingText(CONFIG.nestX, CONFIG.nestY - 30, 'NEW ANT!', '#00ff88', 16);
            }

            // Reset cycle
            resetCycle();
        }

        // Reset cycle for next harvest
        function resetCycle() {
            cycleStartTime = Date.now();
            accumulatedBonuses.hp = 0;
            accumulatedBonuses.atk = 0;
            accumulatedBonuses.def = 0;
            accumulatedBonuses.carry = 0;
            accumulatedBonuses.abilities = [];
            cycleDeliveries = [];
            harvestModalOpen = false;

            // Hide modal
            const modal = document.getElementById('harvest-modal');
            if (modal) modal.classList.remove('visible');
        }

        // Handle harvest continue button click
        document.getElementById('harvest-continue-btn')?.addEventListener('click', () => {
            spawnHarvestAnt();
            // Now show upgrade selection after ant spawns
            showUpgradeSelection();
        });

        // ===========================================
        // MAIN LOOP
        // ===========================================

        function update() {
            // Don't update if game hasn't started (waiting for hive placement)
            if (!gameStarted || gameOver || upgradesPaused) return;

            time++;

            // Check if it's time for harvest + upgrades (combined)
            checkUpgradeTime();

            // Check if we should spawn more predators (every minute)
            checkPredatorSpawn();

            // Check for rare food spawns (golden apples)
            checkRareFoodSpawn();

            for (const ant of ants) {
                ant.update();
                ant.updateBuffs();  // Clean up expired food buffs
            }

            // Update all predators from arrays
            for (const spider of spiderPredators) spider.update();
            for (const beetle of beetlePredators) beetle.update();

            decayPheromones();
            updateAmbientParticles();
            updateSpawnNotifications();
            updateRareFoodNotifications();  // Golden apple notifications
            updateFoodTimers();
            updateDeathCounter();  // For Berserker skill
            updateTrailblazerBeacons();  // For Scout skill
            checkAntPredatorCombat();  // All ants fight nearby predators
            updateFloatingTexts();  // Reward and damage floating text
            updateCombatEffects();  // Combat clash animations
            updateDeathEffects();   // Death particle animations

            // Check for game over
            checkGameOver();
        }

        // Food no longer spoils - just update food items
        function updateFoodTimers() {
            for (const food of foodItems) {
                food.update();
            }
        }

        function drawHint() {
            if (!showHint) return;

            ctx.save();
            ctx.fillStyle = 'rgba(240, 235, 224, 0.5)';
            ctx.font = 'italic 16px "Playfair Display", Georgia, serif';
            ctx.textAlign = 'center';
            ctx.fillText('click to drop food', width / 2, height * 0.18);

            ctx.strokeStyle = 'rgba(240, 235, 224, 0.3)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(width / 2, height * 0.21);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.moveTo(width / 2 - 6, height * 0.26);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.lineTo(width / 2 + 6, height * 0.26);
            ctx.stroke();
            ctx.restore();
        }

        function render() {
            drawGround();
            drawSpots();
            drawPheromones();
            if (gameStarted) drawNest();  // Only draw nest after hive is placed
            drawFood();
            drawTrailblazerBeacons();  // Scout skill beacons
            drawRoyalAuras();          // Queen skill auras
            drawAnts();
            // Draw all predators from arrays
            for (const spider of spiderPredators) spider.draw();
            for (const beetle of beetlePredators) beetle.draw();
            drawAmbientParticles();
            drawSpawnNotifications();
            drawRareFoodNotifications();  // Golden apple spawn notifications
            drawCombatEffects();  // Combat clash animations
            drawDeathEffects();   // Death particle animations
            drawFloatingTexts();  // Reward and damage floating text
            drawHint();
            drawSelectionRect(); // Draw selection rectangle on top
        }

        // Draw Queen's Royal Decree aura
        function drawRoyalAuras() {
            for (const ant of ants) {
                if (ant.type === 'queen' && ant.hasSkill) {
                    const pulse = Math.sin(Date.now() / 400) * 0.15 + 0.85;

                    ctx.save();

                    // Outer soft glow
                    const gradient = ctx.createRadialGradient(ant.x, ant.y, 0, ant.x, ant.y, 120);
                    gradient.addColorStop(0, `rgba(150, 80, 180, ${0.15 * pulse})`);
                    gradient.addColorStop(0.5, `rgba(150, 80, 180, ${0.08 * pulse})`);
                    gradient.addColorStop(1, 'rgba(150, 80, 180, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(ant.x, ant.y, 120, 0, Math.PI * 2);
                    ctx.fill();

                    // Animated ring
                    ctx.strokeStyle = `rgba(180, 100, 200, ${0.3 * pulse})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 12]);
                    ctx.lineDashOffset = -Date.now() / 30;
                    ctx.beginPath();
                    ctx.arc(ant.x, ant.y, 115, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                }
            }
        }

        function gameLoop() {
            update();
            render();
            updateUI();
            updateUpgradeCountdown();
            updateCycleTimerUI();  // Update cycle timer display based on upgrade time
            requestAnimationFrame(gameLoop);
        }

        function resize() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);

            initPheromoneGrid();
            CONFIG.nestX = width * 0.5;
            CONFIG.nestY = height * 0.55;

            generateForestElements();
            generateGrass();
            initAmbientParticles();
        }

        function initPredators() {
            // Generate random spots first
            generateMapSpots();

            // Update CONFIG.predators positions from the spots
            for (const spot of predatorSpots) {
                if (spot.type === 'spider') {
                    CONFIG.predators.spider.x = spot.x;
                    CONFIG.predators.spider.y = spot.y;
                } else if (spot.type === 'beetle') {
                    CONFIG.predators.beetle.x = spot.x;
                    CONFIG.predators.beetle.y = spot.y;
                }
            }

            // Don't spawn predators at game start - they spawn from dens over time
            spiderPredators = [];
            beetlePredators = [];
        }

        // Initialize
        resize();
        // Don't call initAnts() here - ants will be spawned when player places the hive
        ants = [];  // Start with empty ant array
        initPredators();

        // Track initial ants as spawned (will be updated when hive is placed)
        totalAntsSpawned = 0;

        // Initialize food cooldown system
        initFoodCooldownOverlays();
        setInterval(updateFoodCooldowns, 100);

        gameLoop();

        window.addEventListener('resize', resize);

        // Check if running on localhost - if so, hide WIP overlay and show game
        // On public site, show WIP overlay and hide game
        (function checkAccess() {
            const hostname = window.location.hostname;
            const isLocal = hostname === 'localhost' ||
                           hostname === '127.0.0.1' ||
                           hostname === '' ||  // file:// protocol
                           hostname.endsWith('.local');

            const wipOverlay = document.getElementById('wip-overlay');
            const canvas = document.getElementById('canvas');
            const uiElements = document.querySelectorAll('.ui-overlay, .upgrade-modal, .game-over-modal, .harvest-modal, .hive-placement-overlay');

            if (isLocal) {
                // On localhost - hide WIP, show game
                wipOverlay.classList.add('hidden');
            } else {
                // On public site - show WIP, hide game
                wipOverlay.classList.remove('hidden');
                canvas.style.display = 'none';
                uiElements.forEach(el => el.style.display = 'none');
            }
        })();
    </script>
</body>
</html>
