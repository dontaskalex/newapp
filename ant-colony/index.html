<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ant Colony - hafnr</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #1a2418;
            --surface: rgba(28, 32, 26, 0.92);
            --border: rgba(100, 120, 80, 0.3);
            --text: #f0ebe0;
            --text-muted: #a8b0a0;
            --accent: #b8d468;
            --accent-glow: rgba(184, 212, 104, 0.15);
            --gold: #f4d03f;
        }

        body {
            background: var(--bg);
            min-height: 100vh;
            min-height: 100dvh;
            font-family: 'Playfair Display', Georgia, serif;
            color: var(--text);
            overflow: hidden;
            touch-action: none;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            cursor: crosshair;
            z-index: 1;
        }

        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 13px;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            backdrop-filter: blur(16px);
            transition: all 0.25s ease;
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.5px;
        }

        .back-link:hover {
            color: var(--text);
            background: rgba(35, 40, 32, 0.95);
            border-color: rgba(120, 160, 80, 0.4);
            transform: translateX(-2px);
        }

        .info-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 12px;
            padding: 20px 22px;
            font-size: 14px;
            color: var(--text-muted);
            max-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .info-panel h3 {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: var(--accent);
            margin-bottom: 16px;
            letter-spacing: 3px;
            text-transform: uppercase;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .stat-label {
            opacity: 0.7;
        }

        .stat-value {
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-weight: 500;
            font-size: 14px;
        }

        .stat-value.coins {
            color: var(--gold);
        }

        .ant-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 12px;
            font-family: 'DM Mono', monospace;
            font-size: 11px;
        }

        .ant-type {
            padding: 2px 8px;
            border-radius: 4px;
            opacity: 0.9;
        }

        .ant-type.worker {
            background: rgba(70, 50, 35, 0.5);
            color: #a08060;
        }

        .ant-type.soldier {
            background: rgba(180, 50, 50, 0.5);
            color: #ff9080;
        }

        .ant-type.scout {
            background: rgba(200, 160, 50, 0.5);
            color: #ffe080;
        }

        .ant-type.carrier {
            background: rgba(70, 90, 120, 0.5);
            color: #a0c0e0;
        }

        .ant-type.queen {
            background: rgba(130, 60, 150, 0.5);
            color: #e0a0f0;
        }

        /* Character Card Styles - Tactical Dossier Theme */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&display=swap');

        .character-card {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 420px;
            background: linear-gradient(165deg, rgba(12, 14, 18, 0.97), rgba(8, 10, 12, 0.99));
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 4px;
            box-shadow:
                0 0 40px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(0, 255, 136, 0.1),
                inset 0 0 60px rgba(0, 255, 136, 0.02);
            z-index: 1000;
            overflow: hidden;
            animation: cardAppear 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            font-family: 'Share Tech Mono', monospace;
        }

        .character-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 136, 0.015) 2px,
                    rgba(0, 255, 136, 0.015) 4px
                );
            pointer-events: none;
            z-index: 1;
        }

        .character-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 40%,
                rgba(0, 255, 136, 0.03) 50%,
                transparent 60%
            );
            animation: holographicSweep 4s linear infinite;
            pointer-events: none;
            z-index: 2;
        }

        @keyframes holographicSweep {
            from { transform: translateX(-30%) translateY(-30%) rotate(0deg); }
            to { transform: translateX(30%) translateY(30%) rotate(0deg); }
        }

        @keyframes cardAppear {
            from {
                opacity: 0;
                transform: translateX(30px) scale(0.95);
                filter: blur(10px);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
                filter: blur(0);
            }
        }

        .character-card.hidden {
            display: none;
        }

        .card-header {
            position: relative;
            display: flex;
            align-items: center;
            padding: 14px 16px;
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.08), transparent);
            border-bottom: 1px solid rgba(0, 255, 136, 0.15);
            gap: 12px;
            z-index: 3;
        }

        .card-header::before {
            content: 'UNIT DOSSIER';
            position: absolute;
            top: 4px;
            right: 40px;
            font-size: 8px;
            color: rgba(0, 255, 136, 0.4);
            letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif;
        }

        .card-icon {
            font-size: 48px;
            filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.4));
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.4)); }
            50% { filter: drop-shadow(0 0 12px rgba(0, 255, 136, 0.6)); }
        }

        .card-title-section {
            flex: 1;
        }

        .card-title-section h3 {
            margin: 0;
            font-size: 26px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            letter-spacing: 1px;
        }

        .card-subtitle {
            font-size: 13px;
            color: rgba(0, 255, 136, 0.6);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-top: 4px;
        }

        .card-close {
            background: rgba(255, 60, 60, 0.1);
            border: 1px solid rgba(255, 60, 60, 0.3);
            color: #ff4444;
            font-size: 18px;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 2px;
            transition: all 0.2s;
            font-family: 'Orbitron', sans-serif;
            z-index: 10;
        }

        .card-close:hover {
            background: rgba(255, 60, 60, 0.2);
            border-color: rgba(255, 60, 60, 0.6);
            box-shadow: 0 0 15px rgba(255, 60, 60, 0.3);
        }

        .card-body {
            padding: 20px 24px;
            position: relative;
            z-index: 3;
        }

        .card-stats {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 255, 136, 0.1);
            border-radius: 2px;
            padding: 12px 14px;
            position: relative;
            cursor: help;
            transition: all 0.2s;
        }

        .stat-item:hover {
            border-color: rgba(0, 255, 136, 0.4);
            background: rgba(0, 255, 136, 0.05);
        }

        .stat-item:hover .stat-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .stat-item .stat-name {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.7);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }

        .stat-item .stat-val {
            font-size: 18px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
        }

        .stat-bar-container {
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .stat-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
        }

        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: barShine 2s ease-in-out infinite;
        }

        @keyframes barShine {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar.good { background: linear-gradient(90deg, #00ff88, #00cc6a); box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
        .stat-bar.exceptional { background: linear-gradient(90deg, #a78bfa, #8b5cf6); box-shadow: 0 0 10px rgba(167, 139, 250, 0.5); }
        .stat-bar.legendary { background: linear-gradient(90deg, #ffd700, #ffaa00); box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        .stat-bar.neutral, .stat-bar.default { background: linear-gradient(90deg, #4a9eff, #2d7dd2); box-shadow: 0 0 10px rgba(74, 158, 255, 0.3); }
        .stat-bar.weak { background: linear-gradient(90deg, #9ca3af, #6b7280); }
        .stat-bar.poor { background: linear-gradient(90deg, #ef4444, #dc2626); box-shadow: 0 0 10px rgba(239, 68, 68, 0.3); }

        .stat-item .stat-val.good { color: #00ff88; }
        .stat-item .stat-val.exceptional { color: #a78bfa; }
        .stat-item .stat-val.legendary { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.6); }
        .stat-item .stat-val.weak { color: #9ca3af; }
        .stat-item .stat-val.poor { color: #ef4444; }

        .stat-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(8px);
            background: rgba(8, 12, 16, 0.98);
            border: 1px solid rgba(0, 255, 136, 0.4);
            border-radius: 4px;
            padding: 12px 14px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.95);
            width: 220px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.2s ease-out;
            z-index: 1000;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 255, 136, 0.15);
            text-align: center;
        }

        .stat-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: rgba(0, 255, 136, 0.4);
        }

        .card-exp-section {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.15);
            border-radius: 2px;
            padding: 14px 16px;
            margin-bottom: 18px;
        }

        .exp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .exp-label {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.6);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }

        .exp-value {
            font-size: 24px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
        }

        .exp-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
        }

        .exp-detail {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .exp-detail .count {
            color: #00ff88;
            font-weight: 600;
        }

        .card-description {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            margin-bottom: 18px;
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid rgba(0, 255, 136, 0.3);
        }

        .card-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .trait-tag {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 3px;
            padding: 6px 14px;
            font-size: 11px;
            color: rgba(0, 255, 136, 0.8);
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }

        .trait-tag:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .trait-tag.positive { border-color: rgba(125, 206, 160, 0.4); color: #7dcea0; }
        .trait-tag.negative { border-color: rgba(239, 68, 68, 0.4); color: #ef4444; }
        .trait-tag.special { border-color: rgba(255, 215, 0, 0.4); color: #ffd700; }
        .trait-tag.legendary {
            border-color: rgba(255, 215, 0, 0.6);
            color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 170, 0, 0.1));
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
            animation: legendaryPulse 2s ease-in-out infinite;
        }
        .trait-tag.exceptional {
            border-color: rgba(167, 139, 250, 0.5);
            color: #a78bfa;
            background: rgba(167, 139, 250, 0.1);
        }
        .trait-tag.good { border-color: rgba(0, 255, 136, 0.4); color: #00ff88; }
        .trait-tag.weak { border-color: rgba(156, 163, 175, 0.3); color: #9ca3af; }
        .trait-tag.poor { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }

        @keyframes legendaryPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        }

        .card-footer {
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(0, 255, 136, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 9px;
            color: rgba(0, 255, 136, 0.4);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            z-index: 3;
            position: relative;
        }

        .card-id {
            opacity: 0.6;
        }

        .card-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00ff88;
            animation: statusBlink 1.5s ease-in-out infinite;
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .instructions {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
            line-height: 1.7;
            font-size: 12px;
            font-style: italic;
            color: rgba(168, 176, 160, 0.75);
        }

        .bottom-ui {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .food-selector, .ant-selector {
            display: flex;
            gap: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 14px;
            padding: 12px 18px;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .food-label, .ant-label {
            color: var(--text-muted);
            font-size: 11px;
            margin-right: 10px;
            font-family: 'DM Mono', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.6;
            min-width: 45px;
        }

        .food-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(50, 60, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .food-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .food-btn:hover::before {
            opacity: 1;
        }

        .food-btn:hover {
            background: rgba(70, 80, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .food-btn.active {
            border-color: var(--accent);
            background: rgba(80, 100, 60, 0.45);
            box-shadow: 0 0 24px var(--accent-glow), inset 0 0 20px var(--accent-glow);
        }

        .food-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .food-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        .food-btn span.cost, .ant-btn span.cost {
            font-size: 9px;
            font-family: 'DM Mono', monospace;
            color: var(--gold);
            opacity: 0.9;
        }

        .ant-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(60, 50, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .ant-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .ant-btn:hover::before {
            opacity: 1;
        }

        .ant-btn:hover {
            background: rgba(80, 70, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .ant-btn:active {
            transform: translateY(-1px) scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .ant-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ant-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        @media (max-width: 600px) {
            .info-panel {
                max-width: 180px;
                padding: 14px 16px;
            }

            .ui-overlay {
                top: 12px;
                left: 12px;
            }

            .bottom-ui {
                bottom: 12px;
                gap: 6px;
            }

            .food-selector, .ant-selector {
                padding: 8px 12px;
                gap: 6px;
            }

            .food-btn, .ant-btn {
                width: 42px;
                height: 42px;
            }

            .food-btn span.emoji, .ant-btn span.emoji {
                font-size: 16px;
            }

            .food-btn span.cost, .ant-btn span.cost {
                font-size: 8px;
            }

            .food-label, .ant-label {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui-overlay">
        <a href="/" class="back-link">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            back
        </a>
        <div class="info-panel">
            <h3>Ant Colony</h3>
            <div class="stat-row">
                <span class="stat-label">Coins</span>
                <span class="stat-value coins" id="coins">50</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-value" id="ant-count">0</span>
            </div>
            <div class="ant-breakdown">
                <span class="ant-type worker" id="worker-count" title="Workers">0</span>
                <span class="ant-type soldier" id="soldier-count" title="Soldiers">0</span>
                <span class="ant-type scout" id="scout-count" title="Scouts">0</span>
                <span class="ant-type carrier" id="carrier-count" title="Carriers">0</span>
                <span class="ant-type queen" id="queen-count" title="Queens">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Food stored</span>
                <span class="stat-value" id="food-collected">0</span>
            </div>
            <div class="instructions">
                Drop food to earn coins when ants bring it back. Spawn different ant types using the bottom panel!
            </div>
        </div>
    </div>

    <!-- Character Card Modal -->
    <div id="character-card" class="character-card hidden">
        <div class="card-header">
            <span class="card-icon" id="card-icon"></span>
            <div class="card-title-section">
                <h3 id="card-title">Worker</h3>
                <span class="card-subtitle" id="card-subtitle">Ant</span>
            </div>
            <button class="card-close" onclick="closeCharacterCard()">√ó</button>
        </div>
        <div class="card-body">
            <div class="card-exp-section" id="card-exp-section">
                <div class="exp-header">
                    <span class="exp-label">Experience</span>
                    <span class="exp-value" id="exp-value">0</span>
                </div>
                <div class="exp-details" id="exp-details"></div>
            </div>
            <div class="card-stats" id="card-stats"></div>
            <div class="card-description" id="card-description"></div>
            <div class="card-traits" id="card-traits"></div>
        </div>
        <div class="card-footer">
            <span class="card-id" id="card-id">ID: #000</span>
            <div class="card-status">
                <span class="status-dot"></span>
                <span>ACTIVE</span>
            </div>
        </div>
    </div>

    <div class="bottom-ui">
        <div class="food-selector">
            <span class="food-label">drop</span>
            <button class="food-btn active" data-food="sugar" data-cost="1" title="Sugar - 1 gold per unit">
                <span class="emoji">üç¨</span>
                <span class="cost">1</span>
            </button>
            <button class="food-btn" data-food="protein" data-cost="5" title="Protein - 1 gold per unit">
                <span class="emoji">üçñ</span>
                <span class="cost">5</span>
            </button>
            <button class="food-btn" data-food="fruit" data-cost="15" title="Fruit - 1 gold per unit">
                <span class="emoji">üçá</span>
                <span class="cost">15</span>
            </button>
            <button class="food-btn" data-food="feast" data-cost="40" title="Feast - 1 gold per unit">
                <span class="emoji">üçØ</span>
                <span class="cost">40</span>
            </button>
            <button class="food-btn" data-food="nectar" data-cost="100" title="Nectar - 1 gold per unit">
                <span class="emoji">üå∏</span>
                <span class="cost">100</span>
            </button>
        </div>
        <div class="ant-selector">
            <span class="ant-label">spawn</span>
            <button class="ant-btn" data-ant="worker" title="WORKER - Click ant for details">
                <span class="emoji">üêú</span>
                <span class="cost" id="worker-cost">5</span>
            </button>
            <button class="ant-btn" data-ant="soldier" title="SOLDIER - Click ant for details">
                <span class="emoji">‚öîÔ∏è</span>
                <span class="cost" id="soldier-cost">15</span>
            </button>
            <button class="ant-btn" data-ant="scout" title="SCOUT - Click ant for details">
                <span class="emoji">üîç</span>
                <span class="cost" id="scout-cost">25</span>
            </button>
            <button class="ant-btn" data-ant="carrier" title="CARRIER - Click ant for details">
                <span class="emoji">üí™</span>
                <span class="cost" id="carrier-cost">40</span>
            </button>
            <button class="ant-btn" data-ant="queen" title="QUEEN - Click ant for details">
                <span class="emoji">üëë</span>
                <span class="cost" id="queen-cost">80</span>
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let dpr = window.devicePixelRatio || 1;
        let width = window.innerWidth;
        let height = window.innerHeight;
        let time = 0;

        // ===========================================
        // CONFIGURATION
        // ===========================================

        const CONFIG = {
            nestX: 0,
            nestY: 0,
            nestRadius: 40,
            initialAnts: 50,
            maxAnts: 300,

            antSpeed: 0.7,
            antSize: 6,
            carryCapacity: 8,
            turnRate: 0.15,
            wanderStrength: 0.25,

            pheromoneGridSize: 10,
            pheromoneDecay: 0.996,
            pheromoneDeposit: 1.2,
            pheromoneMax: 255,
            pheromoneFollowStrength: 0.35,

            // Food types with costs and rewards (no ant spawning - ants are bought separately)
            foodTypes: {
                sugar:   { size: 1, baseRadius: 12, value: 1, cost: 1, name: 'sugar', emoji: 'üç¨' },
                protein: { size: 5, baseRadius: 16, value: 1, cost: 5, name: 'protein', emoji: 'üçñ' },
                fruit:   { size: 15, baseRadius: 20, value: 1, cost: 15, name: 'fruit', emoji: 'üçá' },
                feast:   { size: 40, baseRadius: 26, value: 1, cost: 40, name: 'feast', emoji: 'üçØ' },
                nectar:  { size: 100, baseRadius: 32, value: 1, cost: 100, name: 'nectar', emoji: 'üå∏' }
            },

            // Ant types that can be spawned (costs scale up)
            antSpawnCosts: {
                worker:   { baseCost: 5, emoji: 'üêú', description: 'Balanced worker ant' },
                soldier:  { baseCost: 15, emoji: '‚öîÔ∏è', description: 'Fights predators' },
                scout:    { baseCost: 25, emoji: 'üîç', description: 'Fast explorer' },
                carrier:  { baseCost: 40, emoji: 'üí™', description: 'High carry capacity' },
                queen:    { baseCost: 80, emoji: 'üëë', description: 'Spawns workers over time' }
            },

            // Ant types with their stats - distinct colors for easy recognition
            antTypes: {
                worker: {
                    // Classic dark brown ant
                    color: { r: 45, g: 30, b: 20 },
                    accentColor: { r: 70, g: 50, b: 35 },
                    speed: 0.7,
                    carryCapacity: 10,
                    carrySpeedBonus: 1.2,
                    fightChance: 0,
                    pheromoneStrength: 1,
                    foodDetectRadius: 8
                },
                soldier: {
                    // Deep red/crimson - aggressive looking
                    color: { r: 120, g: 25, b: 25 },
                    accentColor: { r: 180, g: 50, b: 50 },
                    speed: 0.6,
                    carryCapacity: 6,
                    carrySpeedBonus: 1,
                    fightChance: 0.4,
                    fightDeathChance: 0.3,
                    pheromoneStrength: 0.8,
                    foodDetectRadius: 8
                },
                scout: {
                    // Bright golden/yellow - fast and visible
                    color: { r: 180, g: 140, b: 40 },
                    accentColor: { r: 220, g: 180, b: 60 },
                    speed: 1.0,
                    carryCapacity: 4,
                    carrySpeedBonus: 1,
                    fightChance: 0,
                    pheromoneStrength: 2,
                    foodDetectRadius: 15,
                    wanderStrength: 0.4
                },
                carrier: {
                    // Steel blue/gray - sturdy looking
                    color: { r: 50, g: 65, b: 85 },
                    accentColor: { r: 80, g: 100, b: 130 },
                    speed: 0.5,
                    carryCapacity: 25,
                    carrySpeedBonus: 1.5,
                    fightChance: 0,
                    pheromoneStrength: 0.6,
                    foodDetectRadius: 10,
                    size: 1.35
                },
                queen: {
                    // Royal purple/magenta - regal
                    color: { r: 100, g: 45, b: 120 },
                    accentColor: { r: 150, g: 80, b: 170 },
                    speed: 0.3,
                    carryCapacity: 2,
                    carrySpeedBonus: 1,
                    fightChance: 0,
                    pheromoneStrength: 1.5,
                    foodDetectRadius: 6,
                    size: 1.6,
                    spawnInterval: 600,
                    staysNearNest: true
                }
            },

            // Predator territories
            predators: {
                spider: {
                    x: 0, y: 0, radius: 120,
                    multiplier: 3,
                    color: { r: 80, g: 20, b: 20 },
                    label: 'SPIDER ZONE',
                    huntRadius: 100,
                    killRadius: 12,
                    speed: 1.8
                },
                bird: {
                    x: 0, y: 0, radius: 100,
                    multiplier: 5,
                    color: { r: 70, g: 40, b: 90 },
                    label: 'BIRD ZONE',
                    swoopInterval: [240, 420],
                    swoopSpeed: 12,
                    killRadius: 25,
                    warningTime: 90
                },
                beetle: {
                    x: 0, y: 0, radius: 90,
                    multiplier: 2,
                    color: { r: 50, g: 70, b: 35 },
                    label: 'BEETLE ZONE',
                    patrolSpeed: 0.5,
                    killRadius: 20,
                    blockRadius: 35
                }
            }
        };

        // ===========================================
        // CURRENCY SYSTEM
        // ===========================================

        let coins = 50;

        function canAfford(cost) {
            return coins >= cost;
        }

        function spendCoins(amount) {
            if (coins >= amount) {
                coins -= amount;
                updateUI();
                return true;
            }
            return false;
        }

        function earnCoins(amount) {
            coins += amount;
            updateUI();
        }

        function isInDangerZone(x, y) {
            for (const key in CONFIG.predators) {
                const p = CONFIG.predators[key];
                if (Math.hypot(x - p.x, y - p.y) < p.radius) {
                    return true;
                }
            }
            return false;
        }

        function getDangerZoneMultiplier(x, y) {
            let maxMultiplier = 1;
            for (const key in CONFIG.predators) {
                const p = CONFIG.predators[key];
                if (Math.hypot(x - p.x, y - p.y) < p.radius) {
                    maxMultiplier = Math.max(maxMultiplier, p.multiplier);
                }
            }
            return maxMultiplier;
        }

        function isNearBeetle(x, y) {
            const beetle = predators.beetle;
            if (!beetle) return false;
            return Math.hypot(x - beetle.x, y - beetle.y) < CONFIG.predators.beetle.blockRadius;
        }

        // ===========================================
        // SPAWN NOTIFICATIONS
        // ===========================================

        let spawnNotifications = [];

        function addSpawnNotification(antType) {
            const typeNames = {
                worker: 'Worker',
                soldier: 'Soldier',
                scout: 'Scout',
                carrier: 'Carrier',
                queen: 'Queen'
            };
            const typeColors = {
                worker: 'rgba(139, 90, 43, 0.9)',
                soldier: 'rgba(170, 60, 50, 0.9)',
                scout: 'rgba(180, 140, 60, 0.9)',
                carrier: 'rgba(100, 80, 60, 0.9)',
                queen: 'rgba(200, 150, 100, 0.9)'
            };
            spawnNotifications.push({
                text: `${typeNames[antType]} spawned!`,
                color: typeColors[antType],
                x: CONFIG.nestX,
                y: CONFIG.nestY - getColonySize() - 20,
                alpha: 1,
                life: 90
            });
        }

        function updateSpawnNotifications() {
            for (let i = spawnNotifications.length - 1; i >= 0; i--) {
                const notif = spawnNotifications[i];
                notif.y -= 0.5;
                notif.life--;
                notif.alpha = notif.life / 90;
                if (notif.life <= 0) {
                    spawnNotifications.splice(i, 1);
                }
            }
        }

        function drawSpawnNotifications() {
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px "DM Mono", monospace';
            for (const notif of spawnNotifications) {
                ctx.fillStyle = notif.color.replace('0.9', notif.alpha.toFixed(2));
                ctx.fillText(notif.text, notif.x, notif.y);
            }
        }

        // ===========================================
        // AMBIENT PARTICLES
        // ===========================================

        let dustMotes = [];

        function initAmbientParticles() {
            dustMotes = [];
            const numDust = Math.floor((width * height) / 25000);
            for (let i = 0; i < numDust; i++) {
                dustMotes.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: 0.5 + Math.random() * 1.5,
                    alpha: 0.08 + Math.random() * 0.15,
                    speed: 0.08 + Math.random() * 0.15,
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.008 + Math.random() * 0.015
                });
            }
        }

        function updateAmbientParticles() {
            for (const dust of dustMotes) {
                dust.wobble += dust.wobbleSpeed;
                dust.y -= dust.speed * 0.3;
                dust.x += Math.sin(dust.wobble) * 0.25;
                if (dust.y < -10) {
                    dust.y = height + 10;
                    dust.x = Math.random() * width;
                }
            }
        }

        function drawAmbientParticles() {
            for (const dust of dustMotes) {
                const gradient = ctx.createRadialGradient(dust.x, dust.y, 0, dust.x, dust.y, dust.size * 2);
                gradient.addColorStop(0, `rgba(255, 250, 220, ${dust.alpha})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ===========================================
        // GRASS SYSTEM - Reduced density
        // ===========================================

        let grassClusters = [];

        function generateGrass() {
            grassClusters = [];
            const numClusters = Math.floor((width * height) / 50000); // Reduced from 25000

            for (let i = 0; i < numClusters; i++) {
                const clusterX = Math.random() * width;
                const clusterY = Math.random() * height;

                const distToNest = Math.hypot(clusterX - CONFIG.nestX, clusterY - CONFIG.nestY);
                if (distToNest < CONFIG.nestRadius * 3) continue;

                const cluster = {
                    x: clusterX,
                    y: clusterY,
                    blades: []
                };

                const numBlades = 4 + Math.floor(Math.random() * 5); // Reduced blades per cluster
                for (let j = 0; j < numBlades; j++) {
                    cluster.blades.push({
                        offsetX: (Math.random() - 0.5) * 15,
                        offsetY: (Math.random() - 0.5) * 6,
                        height: 12 + Math.random() * 20,
                        width: 1.5 + Math.random() * 1,
                        curve: (Math.random() - 0.5) * 0.5,
                        phase: Math.random() * Math.PI * 2,
                        swaySpeed: 0.012 + Math.random() * 0.008,
                        swayAmount: 0.015 + Math.random() * 0.02,
                        color: `hsl(${95 + Math.random() * 25}, ${35 + Math.random() * 20}%, ${28 + Math.random() * 15}%)`
                    });
                }

                grassClusters.push(cluster);
            }
        }

        function drawGrass() {
            for (const cluster of grassClusters) {
                for (const blade of cluster.blades) {
                    const x = cluster.x + blade.offsetX;
                    const y = cluster.y + blade.offsetY;
                    const sway = Math.sin(time * blade.swaySpeed + blade.phase) * blade.swayAmount * blade.height;

                    ctx.save();
                    ctx.strokeStyle = blade.color;
                    ctx.lineWidth = blade.width;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    const cp1x = x + blade.curve * blade.height * 0.5 + sway * 0.3;
                    const cp1y = y - blade.height * 0.5;
                    const cp2x = x + blade.curve * blade.height + sway;
                    const cp2y = y - blade.height * 0.85;
                    const endX = x + blade.curve * blade.height * 1.2 + sway * 1.2;
                    const endY = y - blade.height;

                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        // ===========================================
        // FOREST FLOOR - Reduced clutter
        // ===========================================

        let forestElements = [];

        function generateForestElements() {
            forestElements = [];
            const numElements = Math.floor((width * height) / 30000); // Reduced from 12000

            for (let i = 0; i < numElements; i++) {
                const type = Math.random();
                let element;

                if (type < 0.4) {
                    // Fallen leaf
                    element = {
                        type: 'leaf',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 8 + Math.random() * 12,
                        rotation: Math.random() * Math.PI * 2,
                        color: ['#5a6040', '#6b7050', '#4a5535', '#7a8560'][Math.floor(Math.random() * 4)],
                        alpha: 0.3 + Math.random() * 0.25
                    };
                } else if (type < 0.7) {
                    // Pebble
                    element = {
                        type: 'pebble',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 2 + Math.random() * 4,
                        color: ['#4a4840', '#5a5850', '#3a3835', '#6a6860'][Math.floor(Math.random() * 4)],
                        alpha: 0.4 + Math.random() * 0.25
                    };
                } else {
                    // Twig
                    element = {
                        type: 'twig',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        length: 15 + Math.random() * 25,
                        rotation: Math.random() * Math.PI,
                        thickness: 1 + Math.random() * 1.5,
                        color: '#4d3a2a',
                        alpha: 0.35 + Math.random() * 0.2
                    };
                }

                const distToNest = Math.hypot(element.x - CONFIG.nestX, element.y - CONFIG.nestY);
                if (distToNest > CONFIG.nestRadius * 2.5) {
                    forestElements.push(element);
                }
            }
        }

        function drawForestElement(el) {
            ctx.save();
            ctx.globalAlpha = el.alpha;

            switch (el.type) {
                case 'leaf':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, el.size * 0.35, el.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -el.size * 0.4);
                    ctx.lineTo(0, el.size * 0.4);
                    ctx.stroke();
                    break;

                case 'pebble':
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(el.x, el.y, el.size, el.size * 0.65, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'twig':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.strokeStyle = el.color;
                    ctx.lineWidth = el.thickness;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-el.length / 2, 0);
                    ctx.lineTo(el.length / 2, 0);
                    ctx.stroke();
                    break;
            }

            ctx.restore();
        }

        // ===========================================
        // PHEROMONE GRID
        // ===========================================

        let pheromoneGrid = { food: null, home: null, cols: 0, rows: 0 };

        function initPheromoneGrid() {
            const cellSize = CONFIG.pheromoneGridSize;
            pheromoneGrid.cols = Math.ceil(width / cellSize);
            pheromoneGrid.rows = Math.ceil(height / cellSize);
            const size = pheromoneGrid.cols * pheromoneGrid.rows;
            pheromoneGrid.food = new Float32Array(size);
            pheromoneGrid.home = new Float32Array(size);
        }

        function getPheromoneIndex(x, y) {
            const col = Math.floor(x / CONFIG.pheromoneGridSize);
            const row = Math.floor(y / CONFIG.pheromoneGridSize);
            if (col < 0 || col >= pheromoneGrid.cols || row < 0 || row >= pheromoneGrid.rows) return -1;
            return row * pheromoneGrid.cols + col;
        }

        function depositPheromone(x, y, type, amount) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return;
            const grid = type === 'food' ? pheromoneGrid.food : pheromoneGrid.home;
            grid[idx] = Math.min(grid[idx] + amount, CONFIG.pheromoneMax);
        }

        function getPheromone(x, y, type) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return 0;
            return (type === 'food' ? pheromoneGrid.food : pheromoneGrid.home)[idx];
        }

        function samplePheromoneDirection(x, y, currentAngle, type) {
            const sampleDist = 15;
            const sampleAngle = 0.5;
            const left = getPheromone(x + Math.cos(currentAngle - sampleAngle) * sampleDist, y + Math.sin(currentAngle - sampleAngle) * sampleDist, type);
            const center = getPheromone(x + Math.cos(currentAngle) * sampleDist, y + Math.sin(currentAngle) * sampleDist, type);
            const right = getPheromone(x + Math.cos(currentAngle + sampleAngle) * sampleDist, y + Math.sin(currentAngle + sampleAngle) * sampleDist, type);

            if (center >= left && center >= right) return 0;
            return (left > right ? -1 : 1) * sampleAngle * CONFIG.pheromoneFollowStrength;
        }

        function decayPheromones() {
            const decay = CONFIG.pheromoneDecay;
            for (let i = 0; i < pheromoneGrid.food.length; i++) {
                pheromoneGrid.food[i] *= decay;
                pheromoneGrid.home[i] *= decay;
                if (pheromoneGrid.food[i] < 0.01) pheromoneGrid.food[i] = 0;
                if (pheromoneGrid.home[i] < 0.01) pheromoneGrid.home[i] = 0;
            }
        }

        // ===========================================
        // PREDATORS (Spider, Bird, Beetle)
        // ===========================================

        let predators = { spider: null, bird: null, beetle: null };

        // Helper to kill an ant (handles food release)
        function killAnt(ant, predator) {
            // Soldiers can fight back
            if (ant.type === 'soldier') {
                const result = ant.attemptFight(predator);
                if (result === 'win') {
                    return false; // Ant survives, predator stunned
                }
                // 'mutual' or 'lose' - ant dies
            }

            // With new mechanic, the carried food piece is simply lost when ant dies
            // (no need to return it to source)
            const idx = ants.indexOf(ant);
            if (idx !== -1) ants.splice(idx, 1);
            return true;
        }

        class Spider {
            constructor() {
                const cfg = CONFIG.predators.spider;
                this.x = cfg.x;
                this.y = cfg.y;
                this.targetX = this.x;
                this.targetY = this.y;
                this.angle = Math.random() * Math.PI * 2;
                this.size = 18;
                this.speed = cfg.speed;
                this.legPhase = 0;
                this.state = 'hunting';
                this.eatTimer = 0;
                this.stunTimer = 0;
            }

            stun(duration) {
                this.stunTimer = duration;
                this.state = 'stunned';
            }

            update() {
                const cfg = CONFIG.predators.spider;
                this.legPhase += 0.2;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) this.state = 'hunting';
                    return;
                }

                if (this.state === 'eating') {
                    this.eatTimer--;
                    if (this.eatTimer <= 0) this.state = 'hunting';
                    return;
                }

                // Find nearest ant within territory
                let nearestAnt = null;
                let nearestDist = cfg.huntRadius;

                for (const ant of ants) {
                    const distToCenter = Math.hypot(ant.x - cfg.x, ant.y - cfg.y);
                    if (distToCenter > cfg.radius) continue;
                    const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestAnt = ant;
                    }
                }

                if (nearestAnt) {
                    this.targetX = nearestAnt.x;
                    this.targetY = nearestAnt.y;

                    if (nearestDist < cfg.killRadius) {
                        if (killAnt(nearestAnt, this)) {
                            this.state = 'eating';
                            this.eatTimer = 60;
                        }
                    }
                } else {
                    // Wander within territory
                    if (Math.random() < 0.02) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * cfg.radius * 0.7;
                        this.targetX = cfg.x + Math.cos(angle) * dist;
                        this.targetY = cfg.y + Math.sin(angle) * dist;
                    }
                }

                // Move toward target but stay in territory
                const angleToTarget = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                this.angle = angleToTarget;

                let newX = this.x + Math.cos(this.angle) * this.speed;
                let newY = this.y + Math.sin(this.angle) * this.speed;

                // Constrain to territory
                const distFromCenter = Math.hypot(newX - cfg.x, newY - cfg.y);
                if (distFromCenter > cfg.radius - 10) {
                    const angleFromCenter = Math.atan2(newY - cfg.y, newX - cfg.x);
                    newX = cfg.x + Math.cos(angleFromCenter) * (cfg.radius - 10);
                    newY = cfg.y + Math.sin(angleFromCenter) * (cfg.radius - 10);
                }

                const dist = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                if (dist > 5) {
                    this.x = newX;
                    this.y = newY;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.3;

                // Stun effect
                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(3, 3, s * 0.8, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.strokeStyle = '#1a1008';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 4; i++) {
                        const attachY = -s * 0.3 + i * s * 0.2;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.2, attachY);
                        ctx.lineTo(side * s * 0.7, attachY - s * 0.2 + phase * s * 0.15);
                        ctx.lineTo(side * s * 0.9, attachY + s * 0.3 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Abdomen
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.3, s * 0.45, s * 0.55, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#3a2a18';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.2, s * 0.2, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.25, s * 0.3, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#400808';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 80, 80, 0.5)';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.fill();

                if (this.state === 'eating') {
                    ctx.fillStyle = 'rgba(200, 50, 50, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, -s * 0.55, s * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.6;
                        const y = Math.sin(angle) * s * 0.6 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        class Bird {
            constructor() {
                const cfg = CONFIG.predators.bird;
                this.x = cfg.x;
                this.y = -100; // Start off-screen
                this.shadowX = cfg.x;
                this.shadowY = cfg.y;
                this.state = 'circling';
                this.swoopTimer = cfg.swoopInterval[0] + Math.random() * (cfg.swoopInterval[1] - cfg.swoopInterval[0]);
                this.targetX = cfg.x;
                this.targetY = cfg.y;
                this.warningTimer = 0;
                this.angle = 0;
                this.circleAngle = Math.random() * Math.PI * 2;
                this.stunTimer = 0;
            }

            stun(duration) {
                this.stunTimer = duration;
                this.state = 'returning';
                this.y = -100;
            }

            update() {
                const cfg = CONFIG.predators.bird;

                if (this.stunTimer > 0) {
                    this.stunTimer--;
                    return;
                }

                switch (this.state) {
                    case 'circling':
                        // Shadow circles around territory
                        this.circleAngle += 0.015;
                        this.shadowX = cfg.x + Math.cos(this.circleAngle) * cfg.radius * 0.5;
                        this.shadowY = cfg.y + Math.sin(this.circleAngle) * cfg.radius * 0.5;

                        this.swoopTimer--;
                        if (this.swoopTimer <= 0) {
                            // Pick a target - prefer areas with ants
                            let targetAnt = null;
                            for (const ant of ants) {
                                if (Math.hypot(ant.x - cfg.x, ant.y - cfg.y) < cfg.radius) {
                                    targetAnt = ant;
                                    break;
                                }
                            }
                            if (targetAnt) {
                                this.targetX = targetAnt.x;
                                this.targetY = targetAnt.y;
                            } else {
                                this.targetX = cfg.x + (Math.random() - 0.5) * cfg.radius;
                                this.targetY = cfg.y + (Math.random() - 0.5) * cfg.radius;
                            }
                            this.state = 'warning';
                            this.warningTimer = cfg.warningTime;
                        }
                        break;

                    case 'warning':
                        // Shadow moves to target, warning indicator
                        this.shadowX += (this.targetX - this.shadowX) * 0.08;
                        this.shadowY += (this.targetY - this.shadowY) * 0.08;
                        this.warningTimer--;
                        if (this.warningTimer <= 0) {
                            this.state = 'swooping';
                            this.x = this.targetX;
                            this.y = -50;
                        }
                        break;

                    case 'swooping':
                        // Fast dive
                        this.y += cfg.swoopSpeed;
                        if (this.y >= this.targetY) {
                            // Kill ants in radius
                            for (let i = ants.length - 1; i >= 0; i--) {
                                const ant = ants[i];
                                if (Math.hypot(ant.x - this.x, ant.y - this.y) < cfg.killRadius) {
                                    killAnt(ant, this);
                                }
                            }
                            this.state = 'returning';
                        }
                        break;

                    case 'returning':
                        this.y -= cfg.swoopSpeed * 0.7;
                        if (this.y < -80) {
                            this.state = 'circling';
                            this.swoopTimer = cfg.swoopInterval[0] + Math.random() * (cfg.swoopInterval[1] - cfg.swoopInterval[0]);
                        }
                        break;
                }
            }

            draw() {
                const cfg = CONFIG.predators.bird;

                // Always draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(this.shadowX, this.shadowY, 25, 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Warning indicator
                if (this.state === 'warning') {
                    const pulse = Math.sin(this.warningTimer * 0.3) * 0.3 + 0.5;
                    ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.arc(this.targetX, this.targetY, cfg.killRadius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Target crosshair
                    ctx.strokeStyle = `rgba(255, 50, 50, ${pulse})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.targetX - 15, this.targetY);
                    ctx.lineTo(this.targetX + 15, this.targetY);
                    ctx.moveTo(this.targetX, this.targetY - 15);
                    ctx.lineTo(this.targetX, this.targetY + 15);
                    ctx.stroke();
                }

                // Draw bird when swooping/returning
                if (this.state === 'swooping' || this.state === 'returning') {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    const wingPhase = Math.sin(Date.now() * 0.02) * 0.4;

                    // Body
                    ctx.fillStyle = '#2a2030';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Wings
                    ctx.fillStyle = '#3a3040';
                    ctx.beginPath();
                    ctx.ellipse(-20, 0, 18, 5 + wingPhase * 8, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(20, 0, 18, 5 + wingPhase * 8, 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    // Head
                    ctx.fillStyle = '#2a2030';
                    ctx.beginPath();
                    ctx.arc(0, -10, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Beak
                    ctx.fillStyle = '#d4a040';
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(-3, -18);
                    ctx.lineTo(3, -18);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }
            }
        }

        class Beetle {
            constructor() {
                const cfg = CONFIG.predators.beetle;
                this.x = cfg.x;
                this.y = cfg.y;
                this.angle = Math.random() * Math.PI * 2;
                this.patrolAngle = 0;
                this.size = 22;
                this.legPhase = 0;
                this.state = 'patrolling';
                this.stunTimer = 0;
            }

            stun(duration) {
                this.stunTimer = duration;
                this.state = 'stunned';
            }

            update() {
                const cfg = CONFIG.predators.beetle;
                this.legPhase += 0.12;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) this.state = 'patrolling';
                    return;
                }

                // Slow circular patrol
                this.patrolAngle += 0.008;
                const targetX = cfg.x + Math.cos(this.patrolAngle) * cfg.radius * 0.5;
                const targetY = cfg.y + Math.sin(this.patrolAngle) * cfg.radius * 0.5;

                const angleToTarget = Math.atan2(targetY - this.y, targetX - this.x);
                this.angle = angleToTarget;

                this.x += Math.cos(this.angle) * cfg.patrolSpeed;
                this.y += Math.sin(this.angle) * cfg.patrolSpeed;

                // Kill ants in radius
                for (let i = ants.length - 1; i >= 0; i--) {
                    const ant = ants[i];
                    if (Math.hypot(ant.x - this.x, ant.y - this.y) < cfg.killRadius) {
                        killAnt(ant, this);
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.2;

                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(4, 4, s * 0.7, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs (6 legs, 3 per side)
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 3; i++) {
                        const attachY = -s * 0.2 + i * s * 0.25;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.3, attachY);
                        ctx.lineTo(side * s * 0.6, attachY - s * 0.1 + phase * s * 0.1);
                        ctx.lineTo(side * s * 0.75, attachY + s * 0.15 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Shell (elytra)
                ctx.fillStyle = '#2a3520';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.1, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Shell line
                ctx.strokeStyle = '#1a2510';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.4);
                ctx.lineTo(0, s * 0.6);
                ctx.stroke();

                // Shell highlights
                ctx.fillStyle = '#3a4530';
                ctx.beginPath();
                ctx.ellipse(-s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#1a2010';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.55, s * 0.3, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mandibles
                ctx.strokeStyle = '#2a1010';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s * 0.15, -s * 0.7);
                ctx.lineTo(-s * 0.25, -s * 0.85);
                ctx.moveTo(s * 0.15, -s * 0.7);
                ctx.lineTo(s * 0.25, -s * 0.85);
                ctx.stroke();

                // Antennae
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-s * 0.1, -s * 0.65);
                ctx.lineTo(-s * 0.2, -s * 0.9);
                ctx.lineTo(-s * 0.15, -s * 1.0);
                ctx.moveTo(s * 0.1, -s * 0.65);
                ctx.lineTo(s * 0.2, -s * 0.9);
                ctx.lineTo(s * 0.15, -s * 1.0);
                ctx.stroke();

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.5;
                        const y = Math.sin(angle) * s * 0.5 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        function drawDangerZones() {
            for (const key in CONFIG.predators) {
                const cfg = CONFIG.predators[key];
                const cx = cfg.x;
                const cy = cfg.y;
                const r = cfg.radius;
                const c = cfg.color;

                // Danger zone background
                const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, 0.15)`);
                gradient.addColorStop(0.7, `rgba(${c.r * 0.75}, ${c.g * 0.75}, ${c.b * 0.75}, 0.1)`);
                gradient.addColorStop(1, `rgba(${c.r * 0.5}, ${c.g * 0.5}, ${c.b * 0.5}, 0.05)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                // Danger zone border
                ctx.strokeStyle = `rgba(${Math.min(255, c.r * 2)}, ${Math.min(255, c.g * 2)}, ${Math.min(255, c.b * 2)}, 0.4)`;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = `rgba(${Math.min(255, c.r * 2.5)}, ${Math.min(255, c.g * 2.5)}, ${Math.min(255, c.b * 2.5)}, 0.6)`;
                ctx.font = 'bold 12px "DM Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(cfg.label, cx, cy - r + 18);
                ctx.fillStyle = 'rgba(244, 208, 63, 0.8)';
                ctx.font = 'bold 16px "DM Mono", monospace';
                ctx.fillText(`${cfg.multiplier}x REWARD`, cx, cy - r + 36);
            }
        }

        // ===========================================
        // FOOD ITEMS
        // ===========================================

        let foodItems = [];
        let foodCollected = 0;

        // Track ant spawn counts for scaling costs
        let antSpawnCounts = { worker: 0, soldier: 0, scout: 0, carrier: 0, queen: 0 };

        function getAntSpawnCost(antType) {
            const base = CONFIG.antSpawnCosts[antType].baseCost;
            const count = antSpawnCounts[antType];
            // Cost increases by 20% for each ant of that type spawned
            return Math.floor(base * Math.pow(1.2, count));
        }

        function spawnAnt(antType) {
            const cost = getAntSpawnCost(antType);
            if (!canAfford(cost)) return false;
            if (ants.length >= CONFIG.maxAnts) return false;

            spendCoins(cost);
            antSpawnCounts[antType]++;

            const angle = Math.random() * Math.PI * 2;
            const spawnDist = getColonySize() * 0.3;
            const newAnt = new Ant(
                CONFIG.nestX + Math.cos(angle) * spawnDist,
                CONFIG.nestY + Math.sin(angle) * spawnDist,
                antType
            );
            ants.push(newAnt);
            addSpawnNotification(antType);
            updateAntCosts();
            return true;
        }

        function updateAntCosts() {
            for (const antType in CONFIG.antSpawnCosts) {
                const costEl = document.getElementById(`${antType}-cost`);
                if (costEl) {
                    costEl.textContent = getAntSpawnCost(antType);
                }
            }
        }

        const FOOD_LIFETIME_SECONDS = 60;  // 60 seconds until food spoils

        class FoodItem {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = Math.random().toString(36).substr(2, 9);  // Unique ID for tracking
                const config = CONFIG.foodTypes[type];
                this.size = config.size;  // Current size (units of food remaining)
                this.maxSize = config.size;  // Original size
                this.baseRadius = config.baseRadius;
                this.valuePerUnit = config.value;  // Gold per unit of food
                this.name = config.name;
                this.emoji = config.emoji;
                this.carriers = [];
                this.inDangerZone = isInDangerZone(x, y);
                this.spawnTime = Date.now();  // Real timestamp when food was created
                this.spoiled = false;
            }

            update() {
                if (this.getTimeRemaining() <= 0 && !this.spoiled) {
                    this.spoiled = true;
                }
            }

            getTimeRemaining() {
                const elapsed = (Date.now() - this.spawnTime) / 1000;  // Seconds elapsed
                return Math.max(0, Math.ceil(FOOD_LIFETIME_SECONDS - elapsed));
            }

            getRadius() {
                // Radius scales with sqrt of remaining size
                return this.baseRadius * Math.sqrt(this.size / this.maxSize);
            }

            getValue() {
                // Value per unit times danger zone multiplier
                const multiplier = getDangerZoneMultiplier(this.x, this.y);
                return this.valuePerUnit * multiplier;
            }

            // Single ant can always carry 1 unit
            canTakeUnit() {
                return this.size >= 1;
            }

            takeUnit() {
                if (this.size < 1) return 0;
                this.size -= 1;
                return 1;
            }

            isEmpty() {
                return this.size < 1;
            }

            addCarrier(ant) {
                if (!this.carriers.includes(ant)) this.carriers.push(ant);
            }

            removeCarrier(ant) {
                const idx = this.carriers.indexOf(ant);
                if (idx !== -1) this.carriers.splice(idx, 1);
            }

            draw() {
                const r = this.getRadius();
                if (r < 3) return;  // Too small to draw

                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow (offset more so it doesn't darken the emoji)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(3, 5, r * 0.9, r * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Zone-based glow behind emoji
                const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.2);
                if (this.inDangerZone) {
                    // Golden/amber glow for danger zone food
                    glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.5)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 180, 50, 0.2)');
                    glowGrad.addColorStop(1, 'transparent');
                } else {
                    // Green glow for safe zone food
                    glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.4)');
                    glowGrad.addColorStop(0.5, 'rgba(100, 230, 130, 0.15)');
                    glowGrad.addColorStop(1, 'transparent');
                }
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2);
                ctx.fill();

                // Draw emoji scaled to size
                const fontSize = Math.max(14, r * 2);
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);

                // Size indicator
                if (this.size > 1) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(r * 0.8, -r * 0.6, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px "DM Mono", monospace';
                    ctx.fillText(Math.floor(this.size), r * 0.8, -r * 0.6);
                }

                // Timer indicator - shows seconds remaining
                const timeLeft = this.getTimeRemaining();
                const timerColor = timeLeft <= 10 ? 'rgba(255, 80, 80, 0.9)' :
                                   timeLeft <= 20 ? 'rgba(255, 180, 80, 0.9)' :
                                   'rgba(255, 255, 255, 0.7)';
                ctx.fillStyle = timerColor;
                ctx.font = 'bold 9px "DM Mono", monospace';
                ctx.fillText(`${timeLeft}s`, 0, r + 12);

                // Spoiling warning flash
                if (timeLeft <= 10 && Math.floor(time / 15) % 2 === 0) {
                    ctx.strokeStyle = 'rgba(255, 80, 80, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, r + 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // Food piece that an ant carries - tracks source food for spoilage and zone
        class CarriedFoodPiece {
            constructor(type, sourceFoodId, fromDangerZone) {
                this.type = type;
                this.emoji = CONFIG.foodTypes[type].emoji;
                this.sourceFoodId = sourceFoodId;  // Track which food this came from
                this.fromDangerZone = fromDangerZone;  // Track zone for glow color
            }
        }

        function addFood(x, y, type) {
            const cost = CONFIG.foodTypes[type].cost;
            if (spendCoins(cost)) {
                foodItems.push(new FoodItem(x, y, type));
                return true;
            }
            return false;
        }

        // ===========================================
        // ANTS
        // ===========================================

        let ants = [];
        let antIdCounter = 0;
        let selectedAnt = null;  // Currently selected ant for character card

        // Ant name generator - normal human names
        const ANT_NAMES = [
            'Gustav', 'Anja', 'Erik', 'Marta', 'Felix', 'Lena', 'Otto', 'Hilda',
            'Bruno', 'Ingrid', 'Karl', 'Freya', 'Hans', 'Greta', 'Fritz', 'Elsa',
            'Max', 'Anna', 'Klaus', 'Liesel', 'Hugo', 'Heidi', 'Emil', 'Rosa',
            'Theo', 'Klara', 'Oscar', 'Maja', 'Lars', 'Petra', 'Nils', 'Vera',
            'Axel', 'Ida', 'Sven', 'Tilda', 'Rolf', 'Britta', 'Lukas', 'Sonja',
            'Kasper', 'Astrid', 'Johan', 'Sigrid', 'Anders', 'Helga', 'Olaf', 'Inga',
            'Finn', 'Linnea', 'Magnus', 'Ylva', 'Bjorn', 'Saga', 'Leif', 'Freja',
            'Henrik', 'Ebba', 'Stefan', 'Alma', 'Viktor', 'Nova', 'Anton', 'Wilma'
        ];
        let usedNames = new Set();

        function generateAntName() {
            // Try to get an unused name
            const availableNames = ANT_NAMES.filter(n => !usedNames.has(n));
            if (availableNames.length > 0) {
                const name = availableNames[Math.floor(Math.random() * availableNames.length)];
                usedNames.add(name);
                return name;
            }
            // All names used, add a number suffix
            const baseName = ANT_NAMES[Math.floor(Math.random() * ANT_NAMES.length)];
            let suffix = 2;
            while (usedNames.has(`${baseName} ${suffix}`)) suffix++;
            const fullName = `${baseName} ${suffix}`;
            usedNames.add(fullName);
            return fullName;
        }

        // Trait quality levels based on roll
        function getTraitQuality(roll) {
            if (roll >= 0.95) return { label: 'Legendary', class: 'legendary', multiplier: 1.4 };
            if (roll >= 0.85) return { label: 'Exceptional', class: 'exceptional', multiplier: 1.25 };
            if (roll >= 0.65) return { label: 'Good', class: 'good', multiplier: 1.1 };
            if (roll >= 0.35) return { label: 'Average', class: '', multiplier: 1.0 };
            if (roll >= 0.15) return { label: 'Below Avg', class: 'weak', multiplier: 0.9 };
            return { label: 'Poor', class: 'poor', multiplier: 0.8 };
        }

        // Rank titles based on experience
        function getAntRank(experience) {
            if (experience >= 100) return { title: 'Legendary', class: 'legendary' };
            if (experience >= 50) return { title: 'Veteran', class: 'exceptional' };
            if (experience >= 25) return { title: 'Experienced', class: 'good' };
            if (experience >= 10) return { title: 'Skilled', class: '' };
            if (experience >= 5) return { title: 'Novice', class: 'weak' };
            return { title: 'Rookie', class: 'poor' };
        }

        class Ant {
            constructor(x, y, type = 'worker') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = ++antIdCounter;
                this.name = generateAntName();

                // Individual trait rolls (0-1, higher is better)
                this.traitRolls = {
                    speed: Math.random(),
                    efficiency: Math.random(),
                    detection: Math.random(),
                    resilience: Math.random()
                };

                // Experience tracking
                this.experience = {
                    totalDeliveries: 0,
                    dangerDeliveries: 0,
                    totalValue: 0,
                    predatorEncounters: 0,
                    predatorEscapes: 0
                };

                // Load type-specific stats with trait modifications
                const typeConfig = CONFIG.antTypes[type] || CONFIG.antTypes.worker;

                // Speed affected by speed trait roll
                const speedQuality = getTraitQuality(this.traitRolls.speed);
                this.baseSpeed = typeConfig.speed * speedQuality.multiplier;
                this.speed = this.baseSpeed;

                // Detection radius affected by detection trait
                const detectionQuality = getTraitQuality(this.traitRolls.detection);
                this.foodDetectRadius = typeConfig.foodDetectRadius * detectionQuality.multiplier;

                // Efficiency affects carry speed bonus
                const efficiencyQuality = getTraitQuality(this.traitRolls.efficiency);
                this.carrySpeedBonus = typeConfig.carrySpeedBonus * efficiencyQuality.multiplier;

                // Resilience affects fight survival (for soldiers)
                const resilienceQuality = getTraitQuality(this.traitRolls.resilience);

                this.carryCapacity = typeConfig.carryCapacity;
                this.fightChance = typeConfig.fightChance || 0;
                // Better resilience = lower death chance
                this.fightDeathChance = (typeConfig.fightDeathChance || 0) * (2 - resilienceQuality.multiplier);
                this.pheromoneStrength = typeConfig.pheromoneStrength;
                this.colorConfig = typeConfig.color;
                this.accentColor = typeConfig.accentColor || typeConfig.color;
                this.sizeMultiplier = typeConfig.size || 1;

                this.angle = Math.random() * Math.PI * 2;
                this.state = 'exploring';
                this.targetFood = null;
                this.carriedFoodPiece = null;  // Now stores a CarriedFoodPiece
                this.carriedFoodValue = 0;  // Value of the piece being carried
                this.wanderBias = (Math.random() - 0.5) * 0.1;
                this.isScout = type === 'scout';
                this.wanderStrength = typeConfig.wanderStrength || CONFIG.wanderStrength;
                this.depositTimer = 0;
                this.foundFoodRecently = false;
                this.legPhase = Math.random() * Math.PI * 2;
                this.colorOffset = Math.floor(Math.random() * 15) - 7;
                this.panicTimer = 0;

                // Soldier-specific properties
                this.targetPredator = null;
                this.escortTarget = null;

                // Queen-specific properties
                this.spawnTimer = 0;
                this.staysNearNest = typeConfig.staysNearNest || false;
            }

            // Get total experience points
            getTotalExp() {
                return this.experience.totalDeliveries +
                       this.experience.dangerDeliveries * 2 +  // Danger zone worth double
                       this.experience.predatorEscapes * 3;    // Escapes worth triple
            }

            // Record a successful delivery
            recordDelivery(value, fromDangerZone) {
                this.experience.totalDeliveries++;
                this.experience.totalValue += value;
                if (fromDangerZone) {
                    this.experience.dangerDeliveries++;
                }

                // Experience can boost stats slightly over time
                const exp = this.getTotalExp();
                const expBonus = 1 + Math.min(0.2, exp * 0.002);  // Up to 20% bonus at 100 exp
                this.speed = this.baseSpeed * expBonus;
            }

            // Record predator encounter
            recordPredatorEncounter(escaped) {
                this.experience.predatorEncounters++;
                if (escaped) {
                    this.experience.predatorEscapes++;
                }
            }

            // Soldiers can attempt to fight predators
            attemptFight(predator) {
                if (this.type !== 'soldier' || this.fightChance <= 0) return 'lose';

                if (Math.random() < this.fightChance) {
                    // Soldier wins - stun predator
                    predator.stun(180); // 3 seconds stun
                    if (Math.random() < this.fightDeathChance) {
                        return 'mutual'; // Both affected
                    }
                    return 'win';
                }
                return 'lose';
            }

            update() {
                this.legPhase += 0.25;

                // Flee from nearby predators if in danger zone and not carrying
                // Soldiers don't flee - they fight!
                if (this.type !== 'soldier' && isInDangerZone(this.x, this.y) && this.state !== 'carrying') {
                    let nearestPredator = null;
                    let nearestDist = 60;

                    // Check all predators
                    for (const key in predators) {
                        const p = predators[key];
                        if (!p || p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestPredator = p;
                        }
                    }

                    if (nearestPredator) {
                        this.panicTimer = 30;
                        const fleeAngle = Math.atan2(this.y - nearestPredator.y, this.x - nearestPredator.x);
                        this.angle = fleeAngle + (Math.random() - 0.5) * 0.5;
                        this.x += Math.cos(this.angle) * this.speed * 2.5;
                        this.y += Math.sin(this.angle) * this.speed * 2.5;
                        this.bounceOffWalls();
                        return;
                    }
                }

                // Soldiers actively engage predators when nearby
                if (this.type === 'soldier' && this.state !== 'hunting' && this.state !== 'escorting') {
                    for (const key in predators) {
                        const p = predators[key];
                        if (!p || p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < 40) {
                            this.targetPredator = p;
                            this.state = 'hunting';
                            break;
                        }
                    }
                }

                if (this.panicTimer > 0) this.panicTimer--;

                // Queen behavior - spawn workers over time
                if (this.type === 'queen') {
                    this.spawnTimer++;
                    const typeConfig = CONFIG.antTypes.queen;
                    if (this.spawnTimer >= typeConfig.spawnInterval && ants.length < CONFIG.maxAnts) {
                        this.spawnTimer = 0;
                        const angle = Math.random() * Math.PI * 2;
                        const spawnDist = 15;
                        const newAnt = new Ant(
                            this.x + Math.cos(angle) * spawnDist,
                            this.y + Math.sin(angle) * spawnDist,
                            'worker'
                        );
                        ants.push(newAnt);
                        addSpawnNotification('worker');
                    }
                    // Queen stays near nest
                    if (this.staysNearNest && this.distanceToNest() > getColonySize() * 1.5) {
                        const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                        this.angle = angleToNest;
                    }
                }

                switch (this.state) {
                    case 'exploring': this.explore(); break;
                    case 'returning': this.returnToNest(); break;
                    case 'carrying': this.carryFood(); break;
                    case 'hunting': this.huntPredator(); break;
                    case 'escorting': this.escortAnt(); break;
                }

                this.bounceOffWalls();
            }

            // Soldiers: Find a predator to hunt or ant to escort
            findSoldierTask() {
                // Priority 1: Hunt predators in danger zones
                let nearestPredator = null;
                let nearestPredatorDist = 200;

                for (const key in predators) {
                    const p = predators[key];
                    if (!p || p.state === 'stunned') continue;
                    const dist = Math.hypot(p.x - this.x, p.y - this.y);
                    if (dist < nearestPredatorDist) {
                        nearestPredatorDist = dist;
                        nearestPredator = p;
                    }
                }

                if (nearestPredator && nearestPredatorDist < 150) {
                    this.targetPredator = nearestPredator;
                    this.state = 'hunting';
                    return true;
                }

                // Priority 2: Escort non-soldier ants heading into danger zones
                let nearestVulnerable = null;
                let nearestVulnerableDist = 80;

                for (const ant of ants) {
                    if (ant === this || ant.type === 'soldier') continue;
                    if (ant.state !== 'carrying') continue; // Only escort carriers

                    // Check if ant is near or heading toward danger
                    if (isInDangerZone(ant.x, ant.y)) {
                        const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                        if (dist < nearestVulnerableDist) {
                            nearestVulnerableDist = dist;
                            nearestVulnerable = ant;
                        }
                    }
                }

                if (nearestVulnerable) {
                    this.escortTarget = nearestVulnerable;
                    this.state = 'escorting';
                    return true;
                }

                return false;
            }

            // Soldier behavior: Hunt predators
            huntPredator() {
                const predator = this.targetPredator;

                // Check if predator is still valid target
                if (!predator || predator.state === 'stunned') {
                    this.targetPredator = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(predator.x - this.x, predator.y - this.y);

                // If close enough, attempt to stun
                if (dist < 15) {
                    const result = this.attemptFight(predator);
                    if (result === 'win') {
                        // Soldier survived and stunned predator
                        this.targetPredator = null;
                        this.state = 'exploring';
                    } else if (result === 'mutual') {
                        // Both affected - soldier dies
                        const idx = ants.indexOf(this);
                        if (idx !== -1) ants.splice(idx, 1);
                    } else {
                        // Soldier lost - dies
                        const idx = ants.indexOf(this);
                        if (idx !== -1) ants.splice(idx, 1);
                    }
                    return;
                }

                // Move toward predator
                const angleToTarget = Math.atan2(predator.y - this.y, predator.x - this.x);
                this.angle = angleToTarget + (Math.random() - 0.5) * 0.2;
                this.move();

                // Give up if too far
                if (dist > 250) {
                    this.targetPredator = null;
                    this.state = 'exploring';
                }
            }

            // Soldier behavior: Escort vulnerable ants
            escortAnt() {
                const target = this.escortTarget;

                // Check if target is still valid
                if (!target || !ants.includes(target) || target.state !== 'carrying') {
                    this.escortTarget = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(target.x - this.x, target.y - this.y);

                // Stay close to the target
                if (dist > 25) {
                    const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                    this.angle = angleToTarget + (Math.random() - 0.5) * 0.3;
                    this.move();
                } else {
                    // Circle around the target protectively
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x) + Math.PI / 2;
                    this.x += Math.cos(this.angle) * this.speed * 0.5;
                    this.y += Math.sin(this.angle) * this.speed * 0.5;
                }

                // If predator gets close, intercept it
                for (const key in predators) {
                    const p = predators[key];
                    if (!p || p.state === 'stunned') continue;
                    const predatorDist = Math.hypot(p.x - target.x, p.y - target.y);
                    if (predatorDist < 50) {
                        this.targetPredator = p;
                        this.escortTarget = null;
                        this.state = 'hunting';
                        return;
                    }
                }

                // Stop escorting if target leaves danger zone
                if (!isInDangerZone(target.x, target.y)) {
                    this.escortTarget = null;
                    this.state = 'exploring';
                }
            }

            explore() {
                // Soldiers look for tasks instead of food
                if (this.type === 'soldier') {
                    // Check for tasks more frequently
                    if (Math.random() < 0.1) {
                        if (this.findSoldierTask()) return;
                    }

                    // Soldiers patrol toward danger zones - much more focused
                    let nearestPred = null;
                    let nearestDist = Infinity;
                    for (const key in predators) {
                        const p = predators[key];
                        if (!p || p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestPred = p;
                        }
                    }
                    if (nearestPred) {
                        const angleToTarget = Math.atan2(nearestPred.y - this.y, nearestPred.x - this.x);
                        // Strong bias toward predator (80% follow, 20% wander)
                        if (Math.random() < 0.8) {
                            this.angle = angleToTarget + (Math.random() - 0.5) * 0.3;
                        } else {
                            this.angle += (Math.random() - 0.5) * this.wanderStrength;
                        }
                    } else {
                        this.angle += (Math.random() - 0.5) * this.wanderStrength;
                    }
                } else if (this.isScout || Math.random() < 0.25) {
                    this.angle += (Math.random() - 0.5) * this.wanderStrength + this.wanderBias;
                } else {
                    const turn = samplePheromoneDirection(this.x, this.y, this.angle, 'food');
                    this.angle += turn + (Math.random() - 0.5) * CONFIG.wanderStrength * 0.4;
                }

                this.depositTimer++;
                if (this.depositTimer > 6) {
                    const distToNest = this.distanceToNest();
                    depositPheromone(this.x, this.y, 'home', CONFIG.pheromoneDeposit * Math.max(0.15, 1 - distToNest / 350));
                    this.depositTimer = 0;
                }

                this.move();

                // Soldiers still pick up food if they find it, but less eagerly
                if (this.type !== 'soldier' || Math.random() < 0.3) {
                    this.checkForFood();
                }

                if (Math.random() < 0.0004) {
                    this.state = 'returning';
                    this.foundFoodRecently = false;
                }
            }

            checkForFood() {
                for (const food of foodItems) {
                    const dist = Math.hypot(this.x - food.x, this.y - food.y);
                    if (dist < food.getRadius() + 8) {
                        if (food.canTakeUnit()) {
                            this.pickUpFoodUnit(food);
                        } else {
                            // Food is depleted, leave pheromone and mark as found
                            depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * 6);
                            this.state = 'returning';
                            this.foundFoodRecently = true;
                        }
                        break;
                    }
                }
            }

            pickUpFoodUnit(food) {
                // Take 1 unit from the food
                const units = food.takeUnit();
                if (units > 0) {
                    this.carriedFoodPiece = new CarriedFoodPiece(food.type, food.id, food.inDangerZone);
                    this.carriedFoodValue = food.getValue();  // Value based on danger zone
                    this.targetFood = food;
                    this.state = 'carrying';
                    this.angle = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);

                    // Remove food if empty
                    if (food.isEmpty()) {
                        const idx = foodItems.indexOf(food);
                        if (idx !== -1) foodItems.splice(idx, 1);
                    }
                }
            }

            carryFood() {
                // Ant is carrying a food piece back to nest
                if (!this.carriedFoodPiece) {
                    this.state = 'exploring';
                    return;
                }

                // Move toward nest
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const turnRate = 0.1;
                const angleDiff = this.angleDiff(angleToNest, this.angle);
                this.angle += angleDiff * turnRate;

                // Carriers move slower when carrying, adjusted by carrySpeedBonus
                const carrySpeed = this.speed * 0.6 * this.carrySpeedBonus;
                this.x += Math.cos(this.angle) * carrySpeed;
                this.y += Math.sin(this.angle) * carrySpeed;

                // Deposit pheromones
                this.depositTimer++;
                if (this.depositTimer > 4) {
                    depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * 3);
                    this.depositTimer = 0;
                }

                // Check if reached nest
                const distToNest = this.distanceToNest();
                if (distToNest < getColonySize()) {
                    // Record experience before clearing the food piece
                    this.recordDelivery(this.carriedFoodValue, this.carriedFoodPiece.fromDangerZone);

                    // Earn coins (no ant spawning - that's separate now)
                    earnCoins(this.carriedFoodValue);
                    foodCollected += 1;

                    // Reset state
                    this.carriedFoodPiece = null;
                    this.carriedFoodValue = 0;
                    this.targetFood = null;
                    this.state = 'exploring';
                    this.foundFoodRecently = true;
                    this.angle += Math.PI + (Math.random() - 0.5) * 1.2;
                }
            }

            returnToNest() {
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const pheromoneTurn = samplePheromoneDirection(this.x, this.y, this.angle, 'home');
                const directTurn = this.angleDiff(angleToNest, this.angle) * 0.12;

                this.angle += directTurn + pheromoneTurn * 0.4 + (Math.random() - 0.5) * 0.08;

                if (this.foundFoodRecently) {
                    this.depositTimer++;
                    if (this.depositTimer > 4) {
                        depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * 2.5);
                        this.depositTimer = 0;
                    }
                }

                this.move();

                if (this.distanceToNest() < getColonySize()) {
                    this.state = 'exploring';
                    this.foundFoodRecently = false;
                    this.angle += Math.PI + (Math.random() - 0.5) * 1.2;
                }
            }

            move() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }

            bounceOffWalls() {
                const margin = 15;
                if (this.x < margin) { this.x = margin; this.angle = Math.PI - this.angle; }
                if (this.x > width - margin) { this.x = width - margin; this.angle = Math.PI - this.angle; }
                if (this.y < margin) { this.y = margin; this.angle = -this.angle; }
                if (this.y > height - margin) { this.y = height - margin; this.angle = -this.angle; }
            }

            distanceToNest() {
                return Math.hypot(this.x - CONFIG.nestX, this.y - CONFIG.nestY);
            }

            angleDiff(target, current) {
                let diff = target - current;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                return diff;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const size = CONFIG.antSize * this.sizeMultiplier;
                const legWave = Math.sin(this.legPhase) * 0.35;

                // Type-based colors - use accent for highlights
                const baseColor = this.colorConfig || CONFIG.antTypes.worker.color;
                const accent = this.accentColor || baseColor;
                const r = baseColor.r;
                const g = baseColor.g;
                const b = baseColor.b;
                const bodyColor = `rgb(${r}, ${g}, ${b})`;
                const darkColor = `rgb(${Math.max(0, r - 20)}, ${Math.max(0, g - 15)}, ${Math.max(0, b - 10)})`;
                const accentColorStr = `rgb(${accent.r}, ${accent.g}, ${accent.b})`;
                const legColor = `rgb(${Math.min(255, r + 30)}, ${Math.min(255, g + 25)}, ${Math.min(255, b + 20)})`;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 2, size * 1.2, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs - use accent color for visibility
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.12;
                ctx.lineCap = 'round';

                const legPositions = [-0.15, 0.05, 0.25];
                for (let i = 0; i < 3; i++) {
                    const attachX = legPositions[i] * size;
                    const phase = (i === 1) ? -legWave : legWave;

                    ctx.beginPath();
                    ctx.moveTo(attachX, -size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, -size * 0.45 - phase * size * 0.15, attachX - size * 0.1, -size * 0.7 - phase * size * 0.1);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(attachX, size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, size * 0.45 + phase * size * 0.15, attachX - size * 0.1, size * 0.7 + phase * size * 0.1);
                    ctx.stroke();
                }

                // Gaster (abdomen) - main body color
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.5, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Gaster stripe/marking for visibility
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.35, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = darkColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.7, 0, size * 0.15, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Petiole
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.1, 0, size * 0.1, size * 0.07, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax - with accent highlight
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.28, size * 0.18, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax accent stripe
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.18, size * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.55, 0, size * 0.22, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes - white with black pupil for visibility
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(size * 0.62, -size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.arc(size * 0.62, size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(size * 0.64, -size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.arc(size * 0.64, size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.fill();

                // Antennae - use accent color
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.07;
                const antennaWave = Math.sin(this.legPhase * 0.6) * 0.12;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, -size * 0.12);
                ctx.lineTo(size * 0.88, -size * 0.25);
                ctx.lineTo(size * 1.05, -size * 0.2 + antennaWave * size);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(size * 0.7, size * 0.12);
                ctx.lineTo(size * 0.88, size * 0.25);
                ctx.lineTo(size * 1.05, size * 0.2 - antennaWave * size);
                ctx.stroke();

                // Draw carried food piece with zone-based glow
                if (this.carriedFoodPiece && this.state === 'carrying') {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    const pieceSize = 10;
                    const pieceX = size * 0.8;
                    const pieceY = -size * 0.3;

                    // Zone-based glow
                    const glowGrad = ctx.createRadialGradient(pieceX, pieceY, 0, pieceX, pieceY, pieceSize * 0.8);
                    if (this.carriedFoodPiece.fromDangerZone) {
                        glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.6)');
                        glowGrad.addColorStop(1, 'transparent');
                    } else {
                        glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.5)');
                        glowGrad.addColorStop(1, 'transparent');
                    }
                    ctx.fillStyle = glowGrad;
                    ctx.beginPath();
                    ctx.arc(pieceX, pieceY, pieceSize * 0.8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = `${pieceSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.carriedFoodPiece.emoji, pieceX, pieceY);
                    ctx.restore();
                }

                // Queen crown indicator only
                if (this.type === 'queen') {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    ctx.font = `${size * 0.7}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëë', 0, -size * 0.7);
                    ctx.restore();
                }

                // Selection indicator - large triangle above selected ant
                if (selectedAnt === this) {
                    ctx.save();
                    ctx.rotate(-this.angle);

                    // Animated bounce
                    const bounce = Math.sin(Date.now() / 150) * 4;
                    const triangleY = -size * 2.2 - bounce;
                    const triSize = size * 1.2;  // Much bigger triangle

                    // Strong glow effect
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 20;

                    // Outer glow ring
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();

                    // Draw main triangle (pointing down)
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.7);
                    ctx.lineTo(-triSize * 0.5, triangleY);
                    ctx.lineTo(triSize * 0.5, triangleY);
                    ctx.closePath();
                    ctx.fill();

                    // Inner lighter triangle
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#80ffbb';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.5);
                    ctx.lineTo(-triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.lineTo(triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }

                ctx.restore();
            }
        }

        function initAnts() {
            ants = [];
            for (let i = 0; i < CONFIG.initialAnts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * CONFIG.nestRadius * 0.7;
                // Start with all workers
                ants.push(new Ant(CONFIG.nestX + Math.cos(angle) * dist, CONFIG.nestY + Math.sin(angle) * dist, 'worker'));
            }
        }

        // ===========================================
        // RENDERING
        // ===========================================

        function drawGround() {
            // Brighter, greener forest floor
            const gradient = ctx.createRadialGradient(width * 0.4, height * 0.35, 0, width * 0.5, height * 0.5, Math.max(width, height) * 0.8);
            gradient.addColorStop(0, '#3a4a30');
            gradient.addColorStop(0.3, '#2e3d28');
            gradient.addColorStop(0.6, '#243320');
            gradient.addColorStop(1, '#1a2818');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Warm light beam
            const beamGradient = ctx.createRadialGradient(width * 0.3, height * 0.2, 0, width * 0.3, height * 0.2, height * 0.8);
            beamGradient.addColorStop(0, 'rgba(255, 250, 220, 0.08)');
            beamGradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.04)');
            beamGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = beamGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw forest elements
            for (const el of forestElements) drawForestElement(el);

            // Draw grass
            drawGrass();

            // Subtle vignette
            const vignetteGradient = ctx.createRadialGradient(width / 2, height / 2, Math.min(width, height) * 0.35, width / 2, height / 2, Math.max(width, height) * 0.85);
            vignetteGradient.addColorStop(0, 'transparent');
            vignetteGradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.1)');
            vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            ctx.fillStyle = vignetteGradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawPheromones() {
            const cellSize = CONFIG.pheromoneGridSize;

            for (let row = 0; row < pheromoneGrid.rows; row++) {
                for (let col = 0; col < pheromoneGrid.cols; col++) {
                    const idx = row * pheromoneGrid.cols + col;
                    const foodPh = pheromoneGrid.food[idx];

                    if (foodPh > 0.8) {
                        const x = col * cellSize;
                        const y = row * cellSize;
                        const alpha = Math.min(0.3, foodPh / CONFIG.pheromoneMax * 0.4);
                        ctx.fillStyle = `rgba(160, 220, 120, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(x + cellSize / 2, y + cellSize / 2, cellSize * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function getColonySize() {
            // Colony grows slightly based on ant population
            return CONFIG.nestRadius * Math.min(2.5, 1 + ants.length / 100);
        }

        function drawNest() {
            const currentRadius = getColonySize();
            const cx = CONFIG.nestX;
            const cy = CONFIG.nestY;
            const antCount = ants.length;

            // Excavated dirt
            ctx.fillStyle = '#4a4030';
            const dirtPiles = 20 + Math.min(antCount, 100) * 0.3;
            for (let i = 0; i < dirtPiles; i++) {
                const angle = (i / dirtPiles) * Math.PI * 2 + Math.sin(i * 1.7) * 0.4;
                const dist = currentRadius * (1.1 + Math.sin(i * 2.9) * 0.2);
                const blobSize = currentRadius * (0.06 + Math.sin(i * 4.1) * 0.03);
                ctx.beginPath();
                ctx.ellipse(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.5, blobSize * 1.2, blobSize * 0.4, angle * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Shadow
            const shadowGrad = ctx.createRadialGradient(cx + currentRadius * 0.1, cy + currentRadius * 0.15, 0, cx, cy, currentRadius * 1.3);
            shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            shadowGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.12)');
            shadowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = shadowGrad;
            ctx.beginPath();
            ctx.ellipse(cx + currentRadius * 0.1, cy + currentRadius * 0.12, currentRadius * 1.2, currentRadius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main mound
            const baseGrad = ctx.createRadialGradient(cx - currentRadius * 0.2, cy - currentRadius * 0.25, 0, cx, cy, currentRadius * 1.2);
            baseGrad.addColorStop(0, '#6a5a45');
            baseGrad.addColorStop(0.3, '#5a4a38');
            baseGrad.addColorStop(0.6, '#4a3a2a');
            baseGrad.addColorStop(1, '#3a2a1f');

            ctx.fillStyle = baseGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius, currentRadius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Texture
            const textureDots = 25 + Math.min(antCount, 100) * 0.4;
            for (let i = 0; i < textureDots; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * currentRadius * 0.9;
                const brightness = 40 + Math.random() * 25;
                ctx.fillStyle = `rgb(${brightness + 25}, ${brightness + 15}, ${brightness})`;
                ctx.beginPath();
                ctx.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.55, 1 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Entrance
            const entranceGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, currentRadius * 0.25);
            entranceGrad.addColorStop(0, '#080604');
            entranceGrad.addColorStop(0.6, '#100e0a');
            entranceGrad.addColorStop(1, '#2a2218');

            ctx.fillStyle = entranceGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.22, currentRadius * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Entrance rim
            ctx.strokeStyle = '#6a5838';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.25, currentRadius * 0.17, 0, Math.PI * 0.8, Math.PI * 0.2);
            ctx.stroke();
        }

        function drawFood() {
            for (const food of foodItems) food.draw();
        }

        function drawAnts() {
            for (const ant of ants) ant.draw();
        }

        function updateUI() {
            document.getElementById('coins').textContent = coins;
            document.getElementById('ant-count').textContent = ants.length;
            document.getElementById('food-collected').textContent = foodCollected;

            // Count ant types
            let workerCount = 0, soldierCount = 0, scoutCount = 0, carrierCount = 0, queenCount = 0;
            for (const ant of ants) {
                if (ant.type === 'worker') workerCount++;
                else if (ant.type === 'soldier') soldierCount++;
                else if (ant.type === 'scout') scoutCount++;
                else if (ant.type === 'carrier') carrierCount++;
                else if (ant.type === 'queen') queenCount++;
            }
            document.getElementById('worker-count').textContent = workerCount;
            document.getElementById('soldier-count').textContent = soldierCount;
            document.getElementById('scout-count').textContent = scoutCount;
            document.getElementById('carrier-count').textContent = carrierCount;
            document.getElementById('queen-count').textContent = queenCount;

            // Update food button states based on affordability
            document.querySelectorAll('.food-btn').forEach(btn => {
                const cost = parseInt(btn.dataset.cost);
                btn.classList.toggle('disabled', coins < cost);
            });

            // Update ant button states and costs
            document.querySelectorAll('.ant-btn').forEach(btn => {
                const antType = btn.dataset.ant;
                const cost = getAntSpawnCost(antType);
                btn.classList.toggle('disabled', coins < cost || ants.length >= CONFIG.maxAnts);
            });

            // Update displayed costs
            updateAntCosts();
        }

        // ===========================================
        // INPUT HANDLING
        // ===========================================

        let selectedFoodType = null;
        let isPlacing = false;
        let lastPlaceTime = 0;
        let showHint = true;
        let foodPlacementActive = false;
        let foodPlacementTimeout = null;

        // Drag selection state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragCurrentX = 0;
        let dragCurrentY = 0;
        let dragThreshold = 10; // Minimum pixels to trigger drag vs click

        function activateFoodPlacement(foodType) {
            // Clear any existing timeout
            if (foodPlacementTimeout) {
                clearTimeout(foodPlacementTimeout);
            }

            selectedFoodType = foodType;
            foodPlacementActive = true;
            document.querySelectorAll('.food-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.querySelector(`.food-btn[data-food="${foodType}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            // Auto-deselect after 10 seconds if no food placed
            foodPlacementTimeout = setTimeout(() => {
                deactivateFoodPlacement();
            }, 10000);
        }

        function deactivateFoodPlacement() {
            if (foodPlacementTimeout) {
                clearTimeout(foodPlacementTimeout);
                foodPlacementTimeout = null;
            }
            foodPlacementActive = false;
            selectedFoodType = null;
            document.querySelectorAll('.food-btn').forEach(b => b.classList.remove('active'));
        }

        document.querySelectorAll('.food-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (btn.classList.contains('disabled')) return;
                const foodType = btn.dataset.food;
                // Toggle: if same food clicked again, deactivate
                if (selectedFoodType === foodType && foodPlacementActive) {
                    deactivateFoodPlacement();
                } else {
                    activateFoodPlacement(foodType);
                }
            });
            btn.addEventListener('mousedown', (e) => e.stopPropagation());
            btn.addEventListener('touchstart', (e) => e.stopPropagation());
        });

        document.querySelector('.food-selector').addEventListener('mousedown', (e) => e.stopPropagation());
        document.querySelector('.food-selector').addEventListener('touchstart', (e) => e.stopPropagation());

        // Ant spawn button handlers
        document.querySelectorAll('.ant-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (btn.classList.contains('disabled')) return;
                const antType = btn.dataset.ant;
                spawnAnt(antType);
            });
            btn.addEventListener('mousedown', (e) => e.stopPropagation());
            btn.addEventListener('touchstart', (e) => e.stopPropagation());
        });

        document.querySelector('.ant-selector').addEventListener('mousedown', (e) => e.stopPropagation());
        document.querySelector('.ant-selector').addEventListener('touchstart', (e) => e.stopPropagation());

        // ===========================================
        // CHARACTER CARD SYSTEM
        // ===========================================

        let characterCardOpen = false;

        const ANT_CARD_DATA = {
            worker: {
                icon: 'üêú',
                title: 'Worker',
                subtitle: 'Colony Backbone',
                description: 'The reliable workhorse of the colony. Workers form the majority of any ant colony, tirelessly foraging for food and maintaining trails.',
                stats: [
                    { name: 'Speed', value: 'Normal', class: '' },
                    { name: 'Pheromones', value: 'Normal', class: '' },
                    { name: 'Detection', value: '8 range', class: '' },
                    { name: 'Efficiency', value: '+20%', class: 'good' }
                ],
                traits: [
                    { text: 'Balanced', class: '' },
                    { text: 'Efficient Carrier', class: 'positive' },
                    { text: 'Common', class: '' }
                ]
            },
            soldier: {
                icon: '‚öîÔ∏è',
                title: 'Soldier',
                subtitle: 'Colony Defender',
                description: 'Fearless protectors that actively seek out threats. Soldiers patrol danger zones and can stun predators, sacrificing themselves to protect the colony.',
                stats: [
                    { name: 'Speed', value: 'Slow', class: 'bad' },
                    { name: 'Combat', value: '40% stun', class: 'good' },
                    { name: 'Survival', value: '70%', class: '' },
                    { name: 'Aggression', value: 'High', class: 'neutral' }
                ],
                traits: [
                    { text: 'Brave', class: 'positive' },
                    { text: 'Patrols Danger', class: 'special' },
                    { text: 'May Die Fighting', class: 'negative' }
                ]
            },
            scout: {
                icon: 'üîç',
                title: 'Scout',
                subtitle: 'Swift Explorer',
                description: 'The fastest ants in the colony with exceptional senses. Scouts leave extra-strong pheromone trails, helping others find food quickly.',
                stats: [
                    { name: 'Speed', value: 'Fast', class: 'good' },
                    { name: 'Pheromones', value: '2x Strong', class: 'good' },
                    { name: 'Detection', value: '15 range', class: 'good' },
                    { name: 'Wander', value: 'High', class: 'neutral' }
                ],
                traits: [
                    { text: 'Swift', class: 'positive' },
                    { text: 'Trail Blazer', class: 'special' },
                    { text: 'Wide Explorer', class: 'positive' }
                ]
            },
            carrier: {
                icon: 'üí™',
                title: 'Carrier',
                subtitle: 'Heavy Lifter',
                description: 'Larger, stronger ants bred for hauling. Though slower normally, carriers maintain better speed when carrying food back to the nest.',
                stats: [
                    { name: 'Speed', value: 'Slow', class: 'bad' },
                    { name: 'Carry Speed', value: '+50%', class: 'good' },
                    { name: 'Detection', value: '10 range', class: '' },
                    { name: 'Size', value: 'Large', class: 'neutral' }
                ],
                traits: [
                    { text: 'Strong', class: 'positive' },
                    { text: 'Efficient Hauler', class: 'special' },
                    { text: 'Slow Walker', class: 'negative' }
                ]
            },
            queen: {
                icon: 'üëë',
                title: 'Queen',
                subtitle: 'Colony Mother',
                description: 'The heart of the colony. Queens stay near the nest and periodically spawn new worker ants for free, providing a steady stream of reinforcements.',
                stats: [
                    { name: 'Speed', value: 'Very Slow', class: 'bad' },
                    { name: 'Spawns', value: '1 per 10s', class: 'good' },
                    { name: 'Pheromones', value: '1.5x', class: '' },
                    { name: 'Size', value: 'Largest', class: 'neutral' }
                ],
                traits: [
                    { text: 'Royal', class: 'special' },
                    { text: 'Spawns Workers', class: 'positive' },
                    { text: 'Stays Near Nest', class: '' }
                ]
            }
        };

        const PREDATOR_CARD_DATA = {
            spider: {
                icon: 'üï∑Ô∏è',
                title: 'Spider',
                subtitle: 'Ambush Predator',
                description: 'A patient hunter that lurks in its territory. The spider waits for ants to wander too close, then strikes with deadly precision.',
                stats: [
                    { name: 'Danger', value: 'High', class: 'bad' },
                    { name: 'Territory', value: 'Center', class: '' },
                    { name: 'Style', value: 'Ambush', class: 'neutral' },
                    { name: 'Reward', value: '2x Gold', class: 'good' }
                ],
                traits: [
                    { text: 'Territorial', class: 'negative' },
                    { text: 'Can Be Stunned', class: 'positive' },
                    { text: 'Deadly Strike', class: 'negative' }
                ]
            },
            bird: {
                icon: 'üê¶',
                title: 'Bird',
                subtitle: 'Aerial Hunter',
                description: 'A swift predator that swoops down from above. Birds are harder to predict but leave their territory periodically.',
                stats: [
                    { name: 'Danger', value: 'High', class: 'bad' },
                    { name: 'Territory', value: 'Left', class: '' },
                    { name: 'Style', value: 'Diving', class: 'neutral' },
                    { name: 'Reward', value: '2x Gold', class: 'good' }
                ],
                traits: [
                    { text: 'Fast', class: 'negative' },
                    { text: 'Can Be Stunned', class: 'positive' },
                    { text: 'Unpredictable', class: 'negative' }
                ]
            },
            beetle: {
                icon: 'ü™≤',
                title: 'Beetle',
                subtitle: 'Armored Threat',
                description: 'A tough, slow-moving predator with heavy armor. Beetles patrol their territory methodically, crushing any ant in their path.',
                stats: [
                    { name: 'Danger', value: 'Medium', class: 'neutral' },
                    { name: 'Territory', value: 'Right', class: '' },
                    { name: 'Style', value: 'Patrol', class: '' },
                    { name: 'Reward', value: '2x Gold', class: 'good' }
                ],
                traits: [
                    { text: 'Armored', class: 'negative' },
                    { text: 'Can Be Stunned', class: 'positive' },
                    { text: 'Slow Moving', class: 'positive' }
                ]
            }
        };

        // Helper to get stat class based on value comparison
        function getStatClass(value, baseline) {
            const ratio = value / baseline;
            if (ratio >= 1.35) return 'legendary';
            if (ratio >= 1.2) return 'exceptional';
            if (ratio >= 1.05) return 'good';
            if (ratio >= 0.95) return '';
            if (ratio >= 0.85) return 'weak';
            return 'poor';
        }

        // Generate dynamic card data for an individual ant
        function generateAntCardData(ant) {
            const baseData = ANT_CARD_DATA[ant.type];
            const typeConfig = CONFIG.antTypes[ant.type];
            const rank = getAntRank(ant.getTotalExp());

            // Calculate actual numeric stats
            const actualSpeed = ant.speed.toFixed(2);
            const actualDetection = ant.foodDetectRadius.toFixed(1);
            const actualEfficiency = (ant.carrySpeedBonus * 100).toFixed(0);

            // Fourth stat varies by ant type
            let fourthStat;
            if (ant.type === 'soldier') {
                const combatRating = Math.round((ant.fightChance * 100) * (1 - ant.fightDeathChance));
                fourthStat = { name: 'Combat', value: combatRating, class: combatRating >= 35 ? 'good' : combatRating >= 25 ? '' : 'weak' };
            } else if (ant.type === 'scout') {
                const exploreRating = Math.round(ant.wanderStrength * 250);
                fourthStat = { name: 'Explore', value: exploreRating, class: exploreRating >= 100 ? 'good' : '' };
            } else if (ant.type === 'queen') {
                fourthStat = { name: 'Royalty', value: '‚òÖ‚òÖ‚òÖ', class: 'legendary' };
            } else {
                // Worker, Carrier - show resilience as a simple rating
                const resRating = Math.round(ant.traitRolls.resilience * 100);
                fourthStat = { name: 'Stamina', value: resRating, class: resRating >= 85 ? 'good' : resRating >= 50 ? '' : 'weak' };
            }

            // Build dynamic stats with real numbers
            const stats = [
                { name: 'Speed', value: actualSpeed, class: getStatClass(ant.speed, typeConfig.speed) },
                { name: 'Carry Eff.', value: `${actualEfficiency}%`, class: getStatClass(ant.carrySpeedBonus, typeConfig.carrySpeedBonus) },
                { name: 'Detection', value: actualDetection, class: getStatClass(ant.foodDetectRadius, typeConfig.foodDetectRadius) },
                fourthStat
            ];

            // Build dynamic traits
            const traits = [
                { text: rank.title, class: rank.class }
            ];

            // Add experience-based traits
            if (ant.experience.dangerDeliveries >= 10) {
                traits.push({ text: 'Daredevil', class: 'exceptional' });
            } else if (ant.experience.dangerDeliveries >= 5) {
                traits.push({ text: 'Risk Taker', class: 'good' });
            }

            if (ant.experience.totalDeliveries >= 20) {
                traits.push({ text: 'Hardworker', class: 'positive' });
            }

            if (ant.experience.predatorEscapes >= 3) {
                traits.push({ text: 'Survivor', class: 'exceptional' });
            }

            // Add trait-based special labels
            if (ant.traitRolls.speed >= 0.95) {
                traits.push({ text: 'Lightning Fast', class: 'legendary' });
            }
            if (ant.traitRolls.detection >= 0.95) {
                traits.push({ text: 'Eagle Eye', class: 'legendary' });
            }

            // Type indicator
            traits.push({ text: baseData.title, class: '' });

            // Build description with experience info
            const expTotal = ant.getTotalExp();
            let desc = baseData.description;
            if (expTotal > 0) {
                desc += ` Has delivered ${ant.experience.totalDeliveries} food items`;
                if (ant.experience.dangerDeliveries > 0) {
                    desc += ` (${ant.experience.dangerDeliveries} from danger zones)`;
                }
                desc += '.';
            }

            return {
                icon: baseData.icon,
                title: ant.name,
                subtitle: `${rank.title} ${baseData.title} ‚Ä¢ EXP: ${expTotal}`,
                description: desc,
                stats: stats,
                traits: traits
            };
        }

        // Track update interval for real-time character card updates
        let cardUpdateInterval = null;

        // Stat tooltips explaining what each stat does
        const STAT_TOOLTIPS = {
            'Speed': 'Movement speed when exploring. Higher = faster foraging and escaping predators.',
            'Carry Eff.': 'Speed retained when carrying food back to nest. Higher = faster deliveries.',
            'Detection': 'Radius for detecting food sources. Higher = spots food from further away.',
            'Combat': 'Fighting effectiveness against predators. Combines attack chance and survival.',
            'Explore': 'Tendency to venture into unexplored areas. Scouts find new food sources faster.',
            'Stamina': 'Overall endurance and resilience. Affects performance under pressure.',
            'Royalty': 'The queen is the heart of the colony. Protect her at all costs!'
        };

        // Calculate bar percentage for a stat
        function getStatBarPercent(statName, value, antType) {
            const typeConfig = CONFIG.antTypes[antType] || CONFIG.antTypes.worker;
            let baseline, max;

            switch(statName) {
                case 'Speed':
                    baseline = typeConfig.speed;
                    max = baseline * 1.5;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Carry Eff.':
                    baseline = typeConfig.carrySpeedBonus * 100;
                    max = baseline * 1.5;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Detection':
                    baseline = typeConfig.foodDetectRadius;
                    max = baseline * 1.5;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Combat':
                    return Math.min(100, parseFloat(value) * 2);  // Max combat ~50
                case 'Explore':
                    return Math.min(100, parseFloat(value));  // Already 0-100
                case 'Stamina':
                    return parseFloat(value);  // Already 0-100
                case 'Royalty':
                    return 100;  // Queens always 100%
                default:
                    return 50;
            }
        }

        function showCharacterCard(data, ant = null) {
            selectedAnt = ant;
            const card = document.getElementById('character-card');

            // Update basic info
            document.getElementById('card-icon').textContent = data.icon;
            document.getElementById('card-title').textContent = data.title;
            document.getElementById('card-subtitle').textContent = data.subtitle;
            document.getElementById('card-description').textContent = data.description;

            // Update experience section (only for ants)
            const expSection = document.getElementById('card-exp-section');
            if (ant && ant.experience) {
                expSection.style.display = 'block';
                document.getElementById('exp-value').textContent = ant.getTotalExp();
                document.getElementById('exp-details').innerHTML = `
                    <div class="exp-detail">
                        <span class="count">${ant.experience.totalDeliveries}</span> deliveries
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.dangerDeliveries}</span> danger
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.predatorEscapes}</span> escapes
                    </div>
                `;
                document.getElementById('card-id').textContent = `ID: #${String(ant.id).padStart(3, '0')}`;
            } else {
                expSection.style.display = 'none';
                document.getElementById('card-id').textContent = 'PREDATOR';
            }

            // Build stats HTML with bars and tooltips
            let statsHtml = '';
            for (const stat of data.stats) {
                const tooltip = STAT_TOOLTIPS[stat.name] || '';
                const barPercent = ant ? getStatBarPercent(stat.name, stat.value, ant.type) : 50;
                const barClass = stat.class || 'default';

                statsHtml += `<div class="stat-item">
                    <div class="stat-header">
                        <span class="stat-name">${stat.name}</span>
                        <span class="stat-val ${stat.class}">${stat.value}</span>
                    </div>
                    <div class="stat-bar-container">
                        <div class="stat-bar ${barClass}" style="width: ${barPercent}%"></div>
                    </div>
                    ${tooltip ? `<div class="stat-tooltip">${tooltip}</div>` : ''}
                </div>`;
            }
            document.getElementById('card-stats').innerHTML = statsHtml;

            // Build traits HTML
            let traitsHtml = '';
            for (const trait of data.traits) {
                traitsHtml += `<span class="trait-tag ${trait.class}">${trait.text}</span>`;
            }
            document.getElementById('card-traits').innerHTML = traitsHtml;

            card.classList.remove('hidden');
            characterCardOpen = true;

            // Start real-time updates for ants
            if (ant) {
                if (cardUpdateInterval) clearInterval(cardUpdateInterval);
                cardUpdateInterval = setInterval(() => {
                    if (selectedAnt && characterCardOpen) {
                        updateCardRealTime();
                    }
                }, 500);
            }
        }

        // Real-time update function for the card
        function updateCardRealTime() {
            if (!selectedAnt || !characterCardOpen) return;

            // Check if ant still exists
            if (!ants.includes(selectedAnt)) {
                closeCharacterCard();
                return;
            }

            // Update experience values
            document.getElementById('exp-value').textContent = selectedAnt.getTotalExp();
            document.getElementById('exp-details').innerHTML = `
                <div class="exp-detail">
                    <span class="count">${selectedAnt.experience.totalDeliveries}</span> deliveries
                </div>
                <div class="exp-detail">
                    <span class="count">${selectedAnt.experience.dangerDeliveries}</span> danger
                </div>
                <div class="exp-detail">
                    <span class="count">${selectedAnt.experience.predatorEscapes}</span> escapes
                </div>
            `;

            // Update subtitle with current rank
            const rank = getAntRank(selectedAnt.getTotalExp());
            const baseData = ANT_CARD_DATA[selectedAnt.type];
            document.getElementById('card-subtitle').textContent =
                `${rank.title} ${baseData.title}`;

            // Update speed stat (can change with experience)
            const speedStat = document.querySelector('.stat-item:first-child .stat-val');
            if (speedStat) {
                speedStat.textContent = selectedAnt.speed.toFixed(2);
            }
        }

        function closeCharacterCard() {
            document.getElementById('character-card').classList.add('hidden');
            characterCardOpen = false;
            selectedAnt = null;
            if (cardUpdateInterval) {
                clearInterval(cardUpdateInterval);
                cardUpdateInterval = null;
            }
        }

        function findClickedEntity(x, y) {
            // Check predators first (larger click targets)
            for (const key in predators) {
                const p = predators[key];
                if (!p) continue;
                const dist = Math.hypot(p.x - x, p.y - y);
                if (dist < 30) {
                    return { type: 'predator', key: key };
                }
            }

            // Check ants
            for (const ant of ants) {
                const dist = Math.hypot(ant.x - x, ant.y - y);
                if (dist < 15) {
                    return { type: 'ant', ant: ant };
                }
            }

            return null;
        }

        function findAntsInRect(x1, y1, x2, y2) {
            // Normalize rectangle coordinates
            const left = Math.min(x1, x2);
            const right = Math.max(x1, x2);
            const top = Math.min(y1, y2);
            const bottom = Math.max(y1, y2);

            const foundAnts = [];
            for (const ant of ants) {
                if (ant.x >= left && ant.x <= right && ant.y >= top && ant.y <= bottom) {
                    foundAnts.push(ant);
                }
            }
            return foundAnts;
        }

        function drawSelectionRect() {
            if (!isDragging) return;

            const left = Math.min(dragStartX, dragCurrentX);
            const top = Math.min(dragStartY, dragCurrentY);
            const right = Math.max(dragStartX, dragCurrentX);
            const bottom = Math.max(dragStartY, dragCurrentY);
            const w = right - left;
            const h = bottom - top;

            if (w < dragThreshold && h < dragThreshold) return;

            ctx.save();

            // Semi-transparent fill
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(left, top, w, h);

            // Animated dashed border
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.lineDashOffset = -Date.now() / 50;
            ctx.strokeRect(left, top, w, h);

            // Corner accents
            const cornerSize = 12;
            ctx.setLineDash([]);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 8;

            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(left, top + cornerSize);
            ctx.lineTo(left, top);
            ctx.lineTo(left + cornerSize, top);
            ctx.stroke();

            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, top);
            ctx.lineTo(right, top);
            ctx.lineTo(right, top + cornerSize);
            ctx.stroke();

            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(left, bottom - cornerSize);
            ctx.lineTo(left, bottom);
            ctx.lineTo(left + cornerSize, bottom);
            ctx.stroke();

            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, bottom);
            ctx.lineTo(right, bottom);
            ctx.lineTo(right, bottom - cornerSize);
            ctx.stroke();

            // Show count of ants in selection
            const antsInRect = findAntsInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
            if (antsInRect.length > 0) {
                ctx.shadowBlur = 12;
                ctx.fillStyle = 'rgba(0, 20, 10, 0.9)';
                ctx.font = 'bold 14px "Orbitron", monospace';
                const text = `${antsInRect.length} ANT${antsInRect.length > 1 ? 'S' : ''}`;
                const metrics = ctx.measureText(text);
                const padding = 8;
                const boxWidth = metrics.width + padding * 2;
                const boxHeight = 24;
                const boxX = left + w / 2 - boxWidth / 2;
                const boxY = top - boxHeight - 8;

                // Background
                ctx.fillStyle = 'rgba(0, 20, 10, 0.95)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 1;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // Text
                ctx.fillStyle = '#00ff88';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, left + w / 2, boxY + boxHeight / 2);
            }

            ctx.restore();
        }

        function placeFood(x, y) {
            // Only place food if placement mode is active
            if (!foodPlacementActive || !selectedFoodType) return false;

            const now = Date.now();
            const minInterval = selectedFoodType === 'sugar' ? 100 : 200;
            if (now - lastPlaceTime < minInterval) return false;
            lastPlaceTime = now;

            const distToNest = Math.hypot(x - CONFIG.nestX, y - CONFIG.nestY);
            if (distToNest < getColonySize() * 1.5) return false;

            if (addFood(x, y, selectedFoodType)) {
                showHint = false;
                // Reset the timeout when food is placed
                if (foodPlacementTimeout) {
                    clearTimeout(foodPlacementTimeout);
                    foodPlacementTimeout = setTimeout(() => {
                        deactivateFoodPlacement();
                    }, 10000);
                }
                return true;
            }
            return false;
        }

        let wasDragging = false; // Track if we just finished a drag

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // If card is open, close it and don't start drag
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            // If food placement is active, handle food placement mode
            if (foodPlacementActive) {
                isPlacing = true;
                placeFood(e.clientX, e.clientY);
                return;
            }

            // Start potential drag selection
            isDragging = true;
            wasDragging = false;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragCurrentX = e.clientX;
            dragCurrentY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            // Handle food placement drag
            if (isPlacing && foodPlacementActive) {
                placeFood(e.clientX, e.clientY);
                return;
            }

            // Handle selection drag
            if (isDragging) {
                dragCurrentX = e.clientX;
                dragCurrentY = e.clientY;

                // Check if we've exceeded the threshold to be considered a drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                if (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold) {
                    wasDragging = true;
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isPlacing = false;

            if (isDragging) {
                isDragging = false;

                // Check if this was a significant drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                const wasDragSelection = Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold;

                if (wasDragSelection) {
                    // Find ants in selection rectangle
                    const selectedAnts = findAntsInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
                    if (selectedAnts.length > 0) {
                        // Select a random ant from the selection (more interesting than always first)
                        const randomAnt = selectedAnts[Math.floor(Math.random() * selectedAnts.length)];
                        showCharacterCard(generateAntCardData(randomAnt), randomAnt);
                    }
                    wasDragging = false;
                    return;
                }
            }

            // Only process click if we weren't dragging
            if (!wasDragging && !foodPlacementActive) {
                const entity = findClickedEntity(e.clientX, e.clientY);
                if (entity) {
                    if (entity.type === 'ant') {
                        showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                    } else if (entity.type === 'predator') {
                        showCharacterCard(PREDATOR_CARD_DATA[entity.key], null);
                    }
                }
            }
            wasDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isPlacing = false;
            isDragging = false;
            wasDragging = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();

            // If card is open, close it on any touch
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            // If food placement is active, place food
            if (foodPlacementActive) {
                isPlacing = true;
                placeFood(touchX, touchY);
                return;
            }

            // Check if touching an entity (only when not placing food)
            const entity = findClickedEntity(touchX, touchY);
            if (entity) {
                if (entity.type === 'ant') {
                    showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                } else if (entity.type === 'predator') {
                    showCharacterCard(PREDATOR_CARD_DATA[entity.key], null);
                }
                return;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isPlacing && foodPlacementActive && !characterCardOpen) placeFood(e.touches[0].clientX, e.touches[0].clientY);
        });

        canvas.addEventListener('touchend', () => isPlacing = false);

        // ===========================================
        // MAIN LOOP
        // ===========================================

        function update() {
            time++;
            for (const ant of ants) ant.update();
            // Update all predators
            if (predators.spider) predators.spider.update();
            if (predators.bird) predators.bird.update();
            if (predators.beetle) predators.beetle.update();
            decayPheromones();
            updateAmbientParticles();
            updateSpawnNotifications();
            updateFoodTimers();
        }

        // Track spoiled food IDs this frame
        let spoiledFoodIds = new Set();

        function updateFoodTimers() {
            spoiledFoodIds.clear();

            // Update all food items and collect spoiled ones
            for (let i = foodItems.length - 1; i >= 0; i--) {
                const food = foodItems[i];
                food.update();

                if (food.spoiled) {
                    spoiledFoodIds.add(food.id);
                    foodItems.splice(i, 1);
                }
            }

            // If any food spoiled, remove carried pieces from that food
            if (spoiledFoodIds.size > 0) {
                for (const ant of ants) {
                    if (ant.carriedFoodPiece && spoiledFoodIds.has(ant.carriedFoodPiece.sourceFoodId)) {
                        // Food went bad - drop the carried piece
                        ant.carriedFoodPiece = null;
                        ant.carriedFoodValue = 0;
                        ant.targetFood = null;
                        ant.state = 'exploring';
                        ant.foundFoodRecently = false;
                    }
                }
            }
        }

        function drawHint() {
            if (!showHint) return;

            ctx.save();
            ctx.fillStyle = 'rgba(240, 235, 224, 0.5)';
            ctx.font = 'italic 16px "Playfair Display", Georgia, serif';
            ctx.textAlign = 'center';
            ctx.fillText('click to drop food', width / 2, height * 0.18);

            ctx.strokeStyle = 'rgba(240, 235, 224, 0.3)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(width / 2, height * 0.21);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.moveTo(width / 2 - 6, height * 0.26);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.lineTo(width / 2 + 6, height * 0.26);
            ctx.stroke();
            ctx.restore();
        }

        function render() {
            drawGround();
            drawDangerZones();
            drawPheromones();
            drawNest();
            drawFood();
            drawAnts();
            // Draw all predators
            if (predators.spider) predators.spider.draw();
            if (predators.bird) predators.bird.draw();
            if (predators.beetle) predators.beetle.draw();
            drawAmbientParticles();
            drawSpawnNotifications();
            drawHint();
            drawSelectionRect(); // Draw selection rectangle on top
        }

        function gameLoop() {
            update();
            render();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function resize() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);

            initPheromoneGrid();
            CONFIG.nestX = width * 0.5;
            CONFIG.nestY = height * 0.6;

            // Position predator territories
            const baseRadius = Math.min(width, height) * 0.12;

            // Spider: center-top
            CONFIG.predators.spider.x = width * 0.5;
            CONFIG.predators.spider.y = height * 0.22;
            CONFIG.predators.spider.radius = baseRadius;

            // Bird: left-top
            CONFIG.predators.bird.x = width * 0.25;
            CONFIG.predators.bird.y = height * 0.28;
            CONFIG.predators.bird.radius = baseRadius * 0.9;

            // Beetle: right-top
            CONFIG.predators.beetle.x = width * 0.75;
            CONFIG.predators.beetle.y = height * 0.28;
            CONFIG.predators.beetle.radius = baseRadius * 0.85;

            generateForestElements();
            generateGrass();
            initAmbientParticles();
        }

        function initPredators() {
            predators.spider = new Spider();
            predators.bird = new Bird();
            predators.beetle = new Beetle();
        }

        // Initialize
        resize();
        initAnts();
        initPredators();
        gameLoop();

        window.addEventListener('resize', resize);
    </script>
</body>
</html>
