<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ant Colony - hafnr</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #1a2418;
            --surface: rgba(28, 32, 26, 0.92);
            --border: rgba(100, 120, 80, 0.3);
            --text: #f0ebe0;
            --text-muted: #a8b0a0;
            --accent: #b8d468;
            --accent-glow: rgba(184, 212, 104, 0.15);
            --gold: #f4d03f;
        }

        body {
            background: var(--bg);
            min-height: 100vh;
            min-height: 100dvh;
            font-family: 'Playfair Display', Georgia, serif;
            color: var(--text);
            overflow: hidden;
            touch-action: none;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            display: block;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            cursor: crosshair;
            z-index: 1;
        }

        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 13px;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            backdrop-filter: blur(16px);
            transition: all 0.25s ease;
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.5px;
        }

        .back-link:hover {
            color: var(--text);
            background: rgba(35, 40, 32, 0.95);
            border-color: rgba(120, 160, 80, 0.4);
            transform: translateX(-2px);
        }

        .info-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 12px;
            padding: 20px 22px;
            font-size: 14px;
            color: var(--text-muted);
            max-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .info-panel h3 {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            font-weight: 500;
            color: var(--accent);
            margin-bottom: 16px;
            letter-spacing: 3px;
            text-transform: uppercase;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .stat-label {
            opacity: 0.7;
        }

        .stat-value {
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-weight: 500;
            font-size: 14px;
        }

        .stat-value.coins {
            color: var(--gold);
        }

        .ant-breakdown {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 12px;
            font-family: 'DM Mono', monospace;
            font-size: 11px;
        }

        .ant-type {
            padding: 2px 8px;
            border-radius: 4px;
            opacity: 0.9;
        }

        .ant-type.worker {
            background: rgba(70, 50, 35, 0.5);
            color: #a08060;
        }

        .ant-type.soldier {
            background: rgba(180, 50, 50, 0.5);
            color: #ff9080;
        }

        .ant-type.scout {
            background: rgba(200, 160, 50, 0.5);
            color: #ffe080;
        }

        .ant-type.carrier {
            background: rgba(70, 90, 120, 0.5);
            color: #a0c0e0;
        }

        .ant-type.queen {
            background: rgba(130, 60, 150, 0.5);
            color: #e0a0f0;
        }

        /* Character Card Styles - Tactical Dossier Theme */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&display=swap');

        .character-card {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 420px;
            background: linear-gradient(165deg, rgba(12, 14, 18, 0.97), rgba(8, 10, 12, 0.99));
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 4px;
            box-shadow:
                0 0 40px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(0, 255, 136, 0.1),
                inset 0 0 60px rgba(0, 255, 136, 0.02);
            z-index: 1000;
            overflow: hidden;
            animation: cardAppear 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            font-family: 'Share Tech Mono', monospace;
        }

        .character-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 136, 0.015) 2px,
                    rgba(0, 255, 136, 0.015) 4px
                );
            pointer-events: none;
            z-index: 1;
        }

        .character-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 40%,
                rgba(0, 255, 136, 0.03) 50%,
                transparent 60%
            );
            animation: holographicSweep 4s linear infinite;
            pointer-events: none;
            z-index: 2;
        }

        @keyframes holographicSweep {
            from { transform: translateX(-30%) translateY(-30%) rotate(0deg); }
            to { transform: translateX(30%) translateY(30%) rotate(0deg); }
        }

        @keyframes cardAppear {
            from {
                opacity: 0;
                transform: translateX(30px) scale(0.95);
                filter: blur(10px);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
                filter: blur(0);
            }
        }

        .character-card.hidden {
            display: none;
        }

        .card-header {
            position: relative;
            display: flex;
            align-items: center;
            padding: 14px 16px;
            background: linear-gradient(180deg, rgba(0, 255, 136, 0.08), transparent);
            border-bottom: 1px solid rgba(0, 255, 136, 0.15);
            gap: 12px;
            z-index: 3;
        }

        .card-header::before {
            content: 'UNIT DOSSIER';
            position: absolute;
            top: 4px;
            right: 40px;
            font-size: 8px;
            color: rgba(0, 255, 136, 0.4);
            letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif;
        }

        .card-icon {
            font-size: 48px;
            filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.4));
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { filter: drop-shadow(0 0 8px rgba(0, 255, 136, 0.4)); }
            50% { filter: drop-shadow(0 0 12px rgba(0, 255, 136, 0.6)); }
        }

        .card-title-section {
            flex: 1;
        }

        .card-title-section h3 {
            margin: 0;
            font-size: 26px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            letter-spacing: 1px;
        }

        .card-subtitle {
            font-size: 13px;
            color: rgba(0, 255, 136, 0.6);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-top: 4px;
        }

        .card-close {
            background: rgba(255, 60, 60, 0.1);
            border: 1px solid rgba(255, 60, 60, 0.3);
            color: #ff4444;
            font-size: 18px;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 2px;
            transition: all 0.2s;
            font-family: 'Orbitron', sans-serif;
            z-index: 10;
        }

        .card-close:hover {
            background: rgba(255, 60, 60, 0.2);
            border-color: rgba(255, 60, 60, 0.6);
            box-shadow: 0 0 15px rgba(255, 60, 60, 0.3);
        }

        .card-body {
            padding: 20px 24px;
            position: relative;
            z-index: 3;
        }

        .card-stats {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 255, 136, 0.1);
            border-radius: 2px;
            padding: 12px 14px;
            position: relative;
            cursor: help;
            transition: all 0.2s;
        }

        .stat-item:hover {
            border-color: rgba(0, 255, 136, 0.4);
            background: rgba(0, 255, 136, 0.05);
        }

        .stat-item:hover .stat-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .stat-item .stat-name {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.7);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }

        .stat-item .stat-val {
            font-size: 18px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
        }

        .stat-bar-container {
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .stat-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
        }

        .stat-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: barShine 2s ease-in-out infinite;
        }

        @keyframes barShine {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .stat-bar.good { background: linear-gradient(90deg, #00ff88, #00cc6a); box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
        .stat-bar.exceptional { background: linear-gradient(90deg, #a78bfa, #8b5cf6); box-shadow: 0 0 10px rgba(167, 139, 250, 0.5); }
        .stat-bar.legendary { background: linear-gradient(90deg, #ffd700, #ffaa00); box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        .stat-bar.neutral, .stat-bar.default { background: linear-gradient(90deg, #4a9eff, #2d7dd2); box-shadow: 0 0 10px rgba(74, 158, 255, 0.3); }
        .stat-bar.weak { background: linear-gradient(90deg, #9ca3af, #6b7280); }
        .stat-bar.poor { background: linear-gradient(90deg, #ef4444, #dc2626); box-shadow: 0 0 10px rgba(239, 68, 68, 0.3); }

        /* Starting stat marker - shows where stat began */
        .stat-start-marker {
            position: absolute;
            top: -2px;
            bottom: -2px;
            width: 2px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1px;
            z-index: 2;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.6);
        }
        .stat-start-marker::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -2px;
            width: 6px;
            height: 3px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1px;
        }

        .stat-item .stat-val.good { color: #00ff88; }
        .stat-item .stat-val.exceptional { color: #a78bfa; }
        .stat-item .stat-val.legendary { color: #ffd700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.6); }
        .stat-item .stat-val.weak { color: #9ca3af; }
        .stat-item .stat-val.poor { color: #ef4444; }

        .stat-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(8px);
            background: rgba(8, 12, 16, 0.98);
            border: 1px solid rgba(0, 255, 136, 0.4);
            border-radius: 4px;
            padding: 12px 14px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.95);
            width: 220px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: all 0.2s ease-out;
            z-index: 1000;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 255, 136, 0.15);
            text-align: center;
        }

        .stat-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: rgba(0, 255, 136, 0.4);
        }

        .card-exp-section {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.15);
            border-radius: 2px;
            padding: 14px 16px;
            margin-bottom: 18px;
        }

        .exp-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .exp-label {
            font-size: 11px;
            color: rgba(0, 255, 136, 0.6);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'Orbitron', sans-serif;
        }

        .exp-value {
            font-size: 24px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Orbitron', sans-serif;
        }

        .exp-details {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
        }

        .exp-detail {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .exp-detail .count {
            color: #00ff88;
            font-weight: 600;
        }

        .card-description {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            margin-bottom: 18px;
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid rgba(0, 255, 136, 0.3);
        }

        .card-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .trait-tag {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 3px;
            padding: 6px 14px;
            font-size: 11px;
            color: rgba(0, 255, 136, 0.8);
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
            position: relative;
            cursor: help;
        }

        .trait-tag:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .trait-tag .trait-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 10, 0.95);
            border: 1px solid rgba(0, 255, 136, 0.4);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 10px;
            font-family: 'Share Tech Mono', monospace;
            text-transform: none;
            letter-spacing: 0;
            color: #c0c0c0;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .trait-tag .trait-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 255, 136, 0.4);
        }

        .trait-tag:hover .trait-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .trait-tag.positive { border-color: rgba(125, 206, 160, 0.4); color: #7dcea0; }
        .trait-tag.negative { border-color: rgba(239, 68, 68, 0.4); color: #ef4444; }
        .trait-tag.special { border-color: rgba(255, 215, 0, 0.4); color: #ffd700; }
        .trait-tag.legendary {
            border-color: rgba(255, 215, 0, 0.6);
            color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 170, 0, 0.1));
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
            animation: legendaryPulse 2s ease-in-out infinite;
        }
        .trait-tag.exceptional {
            border-color: rgba(167, 139, 250, 0.5);
            color: #a78bfa;
            background: rgba(167, 139, 250, 0.1);
        }
        .trait-tag.good { border-color: rgba(0, 255, 136, 0.4); color: #00ff88; }
        .trait-tag.weak { border-color: rgba(156, 163, 175, 0.3); color: #9ca3af; }
        .trait-tag.poor { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .trait-tag.skill {
            border-color: rgba(59, 130, 246, 0.6);
            color: #60a5fa;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.1));
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
            animation: skillGlow 2.5s ease-in-out infinite;
        }

        @keyframes skillGlow {
            0%, 100% { box-shadow: 0 0 8px rgba(59, 130, 246, 0.3); }
            50% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
        }

        /* Level progress bar */
        .level-display {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .level-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
            letter-spacing: 2px;
        }

        .xp-total {
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            color: rgba(0, 255, 136, 0.7);
            background: rgba(0, 255, 136, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .level-bar-container {
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .level-bar {
            height: 100%;
            background: linear-gradient(90deg, #006633, #00aa55, #00ff88);
            transition: width 0.5s ease;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.4);
        }

        .level-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 100%);
            animation: levelShine 2s ease-in-out infinite;
        }

        .level-bar.max {
            background: linear-gradient(90deg, #cc8800, #ffd700, #ffee88, #ffd700, #cc8800);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .level-bar.max::after {
            animation: levelShineGold 1.5s ease-in-out infinite;
        }

        @keyframes levelShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        @keyframes levelShineGold {
            0% { transform: translateX(-100%); opacity: 0.5; }
            100% { transform: translateX(200%); opacity: 0.8; }
        }

        .level-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-family: 'Share Tech Mono', monospace;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9), 0 0 6px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            letter-spacing: 0.5px;
        }

        @keyframes legendaryPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        }

        .card-footer {
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(0, 255, 136, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 9px;
            color: rgba(0, 255, 136, 0.4);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            z-index: 3;
            position: relative;
        }

        .card-id {
            opacity: 0.6;
        }

        .card-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00ff88;
            animation: statusBlink 1.5s ease-in-out infinite;
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .instructions {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
            line-height: 1.7;
            font-size: 12px;
            font-style: italic;
            color: rgba(168, 176, 160, 0.75);
        }

        .bottom-ui {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .food-selector, .ant-selector {
            display: flex;
            gap: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            backdrop-filter: blur(16px);
            border-radius: 14px;
            padding: 12px 18px;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .food-label, .ant-label {
            color: var(--text-muted);
            font-size: 11px;
            margin-right: 10px;
            font-family: 'DM Mono', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.6;
            min-width: 45px;
        }

        .food-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(50, 60, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .food-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .food-btn:hover::before {
            opacity: 1;
        }

        .food-btn:hover {
            background: rgba(70, 80, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .food-btn.active {
            border-color: var(--accent);
            background: rgba(80, 100, 60, 0.45);
            box-shadow: 0 0 24px var(--accent-glow), inset 0 0 20px var(--accent-glow);
        }

        .food-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .food-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        .food-btn span.cost, .ant-btn span.cost {
            font-size: 9px;
            font-family: 'DM Mono', monospace;
            color: var(--gold);
            opacity: 0.9;
        }

        .ant-btn {
            width: 52px;
            height: 52px;
            border: 2px solid transparent;
            border-radius: 10px;
            background: rgba(60, 50, 45, 0.4);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            gap: 2px;
        }

        .ant-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), transparent 60%);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .ant-btn:hover::before {
            opacity: 1;
        }

        .ant-btn:hover {
            background: rgba(80, 70, 60, 0.5);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .ant-btn:active {
            transform: translateY(-1px) scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .ant-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ant-btn span.emoji {
            font-size: 20px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        }

        @media (max-width: 600px) {
            .info-panel {
                max-width: 180px;
                padding: 14px 16px;
            }

            .ui-overlay {
                top: 12px;
                left: 12px;
            }

            .bottom-ui {
                bottom: 12px;
                gap: 6px;
            }

            .food-selector, .ant-selector {
                padding: 8px 12px;
                gap: 6px;
            }

            .food-btn, .ant-btn {
                width: 42px;
                height: 42px;
            }

            .food-btn span.emoji, .ant-btn span.emoji {
                font-size: 16px;
            }

            .food-btn span.cost, .ant-btn span.cost {
                font-size: 8px;
            }

            .food-label, .ant-label {
                display: none;
            }
        }

        /* Game Over Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .game-over-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .game-over-content {
            background: linear-gradient(165deg, rgba(20, 24, 18, 0.98), rgba(12, 14, 10, 0.99));
            border: 2px solid rgba(180, 60, 60, 0.5);
            border-radius: 16px;
            padding: 48px 64px;
            text-align: center;
            box-shadow: 0 0 60px rgba(180, 60, 60, 0.3), inset 0 0 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .game-over-modal.visible .game-over-content {
            transform: scale(1);
        }

        .game-over-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 42px;
            color: #ff6b6b;
            margin-bottom: 12px;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            letter-spacing: 4px;
        }

        .game-over-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 32px;
            letter-spacing: 2px;
        }

        .survival-time {
            font-family: 'Orbitron', sans-serif;
            font-size: 64px;
            color: var(--gold);
            text-shadow: 0 0 30px rgba(244, 208, 63, 0.6);
            margin-bottom: 8px;
        }

        .survival-label {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: var(--text-muted);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 32px;
        }

        .game-stats {
            display: flex;
            gap: 32px;
            justify-content: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .game-stat {
            text-align: center;
        }

        .game-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: var(--accent);
        }

        .game-stat-label {
            font-family: 'DM Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-top: 4px;
        }

        .restart-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            padding: 16px 48px;
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.2), rgba(184, 212, 104, 0.1));
            border: 2px solid var(--accent);
            color: var(--accent);
            border-radius: 8px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            background: linear-gradient(180deg, rgba(184, 212, 104, 0.3), rgba(184, 212, 104, 0.2));
            box-shadow: 0 0 30px rgba(184, 212, 104, 0.3);
            transform: scale(1.05);
        }

        /* Timer Display */
        .timer-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: var(--gold);
            text-align: center;
            padding: 12px;
            margin-bottom: 12px;
            background: rgba(244, 208, 63, 0.1);
            border: 1px solid rgba(244, 208, 63, 0.3);
            border-radius: 8px;
            letter-spacing: 2px;
        }

        .timer-label {
            font-family: 'DM Mono', monospace;
            font-size: 9px;
            color: var(--text-muted);
            letter-spacing: 2px;
            text-transform: uppercase;
            display: block;
            margin-bottom: 4px;
        }

        /* Danger warning pulse */
        .danger-warning {
            animation: dangerPulse 1s ease-in-out infinite;
        }

        @keyframes dangerPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 60, 60, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 60, 60, 0.6); }
        }

        /* Upgrade Selection Modal */
        .upgrade-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .upgrade-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .upgrade-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            color: var(--gold);
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(244, 208, 63, 0.5);
            letter-spacing: 4px;
        }

        .upgrade-subtitle {
            font-family: 'DM Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 32px;
            letter-spacing: 2px;
        }

        .upgrade-options {
            display: flex;
            gap: 24px;
            justify-content: center;
            flex-wrap: wrap;
            max-width: 900px;
            padding: 0 20px;
        }

        .upgrade-card {
            background: linear-gradient(165deg, rgba(30, 35, 28, 0.98), rgba(20, 24, 18, 0.99));
            border: 2px solid rgba(184, 212, 104, 0.3);
            border-radius: 12px;
            padding: 28px 24px;
            width: 240px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
        }

        .upgrade-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .upgrade-card:hover {
            border-color: var(--accent);
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 30px rgba(184, 212, 104, 0.2);
        }

        .upgrade-card:hover::before {
            opacity: 1;
        }

        .upgrade-card:active {
            transform: translateY(-4px) scale(0.98);
        }

        .upgrade-emoji {
            font-size: 48px;
            margin-bottom: 16px;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .upgrade-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: var(--accent);
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .upgrade-desc {
            font-family: 'DM Mono', monospace;
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .upgrade-stacks {
            position: absolute;
            top: 12px;
            right: 12px;
            background: var(--accent);
            color: var(--bg);
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* Upgrade count display in UI */
        .upgrade-count {
            font-family: 'DM Mono', monospace;
            font-size: 11px;
            color: var(--accent);
            text-align: center;
            padding: 8px;
            margin-top: 8px;
            background: rgba(184, 212, 104, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(184, 212, 104, 0.2);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ui-overlay">
        <a href="/" class="back-link">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            back
        </a>
        <div class="info-panel">
            <h3>Ant Colony</h3>
            <div class="timer-display" id="timer-display">
                <span class="timer-label">Survival Time</span>
                <span id="survival-timer">0:00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Coins</span>
                <span class="stat-value coins" id="coins">50</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-value" id="ant-count">0</span>
            </div>
            <div class="ant-breakdown">
                <span class="ant-type worker" id="worker-count" title="Workers">0</span>
                <span class="ant-type soldier" id="soldier-count" title="Soldiers">0</span>
                <span class="ant-type scout" id="scout-count" title="Scouts">0</span>
                <span class="ant-type carrier" id="carrier-count" title="Carriers">0</span>
                <span class="ant-type queen" id="queen-count" title="Queens">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Food stored</span>
                <span class="stat-value" id="food-collected">0</span>
            </div>
            <div class="instructions">
                Drop food to earn coins when ants bring it back. Spawn different ant types using the bottom panel!
            </div>
        </div>
    </div>

    <!-- Character Card Modal -->
    <div id="character-card" class="character-card hidden">
        <div class="card-header">
            <span class="card-icon" id="card-icon"></span>
            <div class="card-title-section">
                <h3 id="card-title">Worker</h3>
                <span class="card-subtitle" id="card-subtitle">Ant</span>
            </div>
            <button class="card-close" onclick="closeCharacterCard()">√ó</button>
        </div>
        <div class="card-body">
            <div class="card-exp-section" id="card-exp-section">
                <div class="exp-header">
                    <span class="exp-label">Experience</span>
                    <span class="exp-value" id="exp-value">0</span>
                </div>
                <div class="exp-details" id="exp-details"></div>
            </div>
            <div class="card-stats" id="card-stats"></div>
            <div class="card-description" id="card-description"></div>
            <div class="card-traits" id="card-traits"></div>
        </div>
        <div class="card-footer">
            <span class="card-id" id="card-id">ID: #000</span>
            <div class="card-status">
                <span class="status-dot"></span>
                <span>ACTIVE</span>
            </div>
        </div>
    </div>

    <div class="bottom-ui">
        <div class="food-selector">
            <span class="food-label">drop</span>
            <button class="food-btn active" data-food="sugar" data-cost="1" title="Sugar - 1 gold per unit">
                <span class="emoji">üç¨</span>
                <span class="cost">1</span>
            </button>
            <button class="food-btn" data-food="protein" data-cost="5" title="Protein - 1 gold per unit">
                <span class="emoji">üçñ</span>
                <span class="cost">5</span>
            </button>
            <button class="food-btn" data-food="fruit" data-cost="15" title="Fruit - 1 gold per unit">
                <span class="emoji">üçá</span>
                <span class="cost">15</span>
            </button>
            <button class="food-btn" data-food="feast" data-cost="40" title="Feast - 1 gold per unit">
                <span class="emoji">üçØ</span>
                <span class="cost">40</span>
            </button>
            <button class="food-btn" data-food="nectar" data-cost="100" title="Nectar - 1 gold per unit">
                <span class="emoji">üå∏</span>
                <span class="cost">100</span>
            </button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="game-over-modal">
        <div class="game-over-content">
            <div class="game-over-title">COLONY EXTINCT</div>
            <div class="game-over-subtitle">The darkness has consumed your colony</div>
            <div class="survival-time" id="final-time">0:00</div>
            <div class="survival-label">Survival Time</div>
            <div class="game-stats">
                <div class="game-stat">
                    <div class="game-stat-value" id="final-food">0</div>
                    <div class="game-stat-label">Food Collected</div>
                </div>
                <div class="game-stat">
                    <div class="game-stat-value" id="final-coins">0</div>
                    <div class="game-stat-label">Coins Earned</div>
                </div>
                <div class="game-stat">
                    <div class="game-stat-value" id="final-ants">0</div>
                    <div class="game-stat-label">Ants Spawned</div>
                </div>
            </div>
            <button class="restart-btn" onclick="restartGame()">RESTART</button>
        </div>
    </div>

    <!-- Upgrade Selection Modal -->
    <div id="upgrade-modal" class="upgrade-modal">
        <div class="upgrade-title">EVOLUTION</div>
        <div class="upgrade-subtitle">Choose an upgrade for your colony</div>
        <div class="upgrade-options" id="upgrade-options">
            <!-- Upgrade cards will be inserted here by JavaScript -->
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let dpr = window.devicePixelRatio || 1;
        let width = window.innerWidth;
        let height = window.innerHeight;
        let time = 0;

        // ===========================================
        // SEEDED RANDOM NUMBER GENERATOR
        // ===========================================

        let currentSeed = Date.now();

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        class SeededRNG {
            constructor(seed) {
                this.seed = seed;
            }

            next() {
                this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
                return this.seed / 0x7fffffff;
            }

            nextRange(min, max) {
                return min + this.next() * (max - min);
            }

            nextInt(min, max) {
                return Math.floor(this.nextRange(min, max + 1));
            }
        }

        let rng = new SeededRNG(currentSeed);

        // ===========================================
        // MAP SPOTS (Food & Predator spawn points)
        // ===========================================

        let foodSpots = [];      // 3 spots where food can be placed
        let predatorSpots = [];  // 2 spots where predators spawn (spider, beetle)

        function generateMapSpots() {
            foodSpots = [];
            predatorSpots = [];

            const margin = 100;
            const nestSafeRadius = 150;  // Keep spots away from nest

            // Generate 3 food spots
            for (let i = 0; i < 3; i++) {
                let spot;
                let attempts = 0;
                do {
                    spot = {
                        x: rng.nextRange(margin, width - margin),
                        y: rng.nextRange(margin, height - margin),
                        type: 'food',
                        radius: 60
                    };
                    attempts++;
                } while (
                    (Math.hypot(spot.x - CONFIG.nestX, spot.y - CONFIG.nestY) < nestSafeRadius ||
                    foodSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < 120)) &&
                    attempts < 50
                );
                foodSpots.push(spot);
            }

            // Generate 2 predator spots (spider and beetle)
            const predatorTypes = ['spider', 'beetle'];
            for (let i = 0; i < 2; i++) {
                let spot;
                let attempts = 0;
                do {
                    spot = {
                        x: rng.nextRange(margin, width - margin),
                        y: rng.nextRange(margin, height - margin),
                        type: predatorTypes[i],
                        radius: 40
                    };
                    attempts++;
                } while (
                    (Math.hypot(spot.x - CONFIG.nestX, spot.y - CONFIG.nestY) < nestSafeRadius + 50 ||
                    foodSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < 100) ||
                    predatorSpots.some(s => Math.hypot(s.x - spot.x, s.y - spot.y) < 150)) &&
                    attempts < 50
                );
                predatorSpots.push(spot);
            }
        }

        function drawSpots() {
            // Draw food spots
            for (const spot of foodSpots) {
                ctx.save();

                // Glowing circle for food spot
                const gradient = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.radius);
                gradient.addColorStop(0, 'rgba(184, 212, 104, 0.15)');
                gradient.addColorStop(0.7, 'rgba(184, 212, 104, 0.08)');
                gradient.addColorStop(1, 'rgba(184, 212, 104, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // Dashed border
                ctx.strokeStyle = 'rgba(184, 212, 104, 0.4)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 6]);
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = 'rgba(184, 212, 104, 0.7)';
                ctx.font = 'bold 10px "DM Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('FOOD ZONE', spot.x, spot.y - spot.radius - 8);

                ctx.restore();
            }

            // Draw predator spots
            for (const spot of predatorSpots) {
                ctx.save();

                const color = spot.type === 'spider'
                    ? { r: 120, g: 40, b: 40 }
                    : { r: 80, g: 100, b: 50 };

                // Danger glow
                const gradient = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.radius);
                gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.25)`);
                gradient.addColorStop(0.7, `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`);
                gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // Pulsing border
                const pulse = Math.sin(Date.now() / 500) * 0.2 + 0.8;
                ctx.strokeStyle = `rgba(${color.r * 2}, ${color.g * 2}, ${color.b * 2}, ${0.5 * pulse})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = `rgba(${color.r * 2}, ${color.g * 2}, ${color.b * 2}, 0.8)`;
                ctx.font = 'bold 10px "DM Mono", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(spot.type.toUpperCase() + ' DEN', spot.x, spot.y - spot.radius - 8);

                // Icon
                ctx.font = '20px sans-serif';
                ctx.fillText(spot.type === 'spider' ? 'üï∑Ô∏è' : 'ü™≤', spot.x, spot.y + 6);

                ctx.restore();
            }
        }

        // ===========================================
        // CONFIGURATION
        // ===========================================

        const CONFIG = {
            nestX: 0,
            nestY: 0,
            nestRadius: 40,
            initialAnts: 10,
            maxAnts: 300,

            antSpeed: 0.7,
            antSize: 6,
            carryCapacity: 8,
            turnRate: 0.15,
            wanderStrength: 0.25,

            pheromoneGridSize: 10,
            pheromoneDecay: 0.996,
            pheromoneDeposit: 1.2,
            pheromoneMax: 255,
            pheromoneFollowStrength: 0.35,

            // Food types with costs and rewards (no ant spawning - ants are bought separately)
            foodTypes: {
                sugar:   { size: 1, baseRadius: 12, value: 1, cost: 1, name: 'sugar', emoji: 'üç¨' },
                protein: { size: 5, baseRadius: 16, value: 1, cost: 5, name: 'protein', emoji: 'üçñ' },
                fruit:   { size: 15, baseRadius: 20, value: 1, cost: 15, name: 'fruit', emoji: 'üçá' },
                feast:   { size: 40, baseRadius: 26, value: 1, cost: 40, name: 'feast', emoji: 'üçØ' },
                nectar:  { size: 100, baseRadius: 32, value: 1, cost: 100, name: 'nectar', emoji: 'üå∏' }
            },

            // Ant types that can be spawned (costs scale up)
            antSpawnCosts: {
                worker:   { baseCost: 5, emoji: 'üêú', description: 'Balanced worker ant' },
                soldier:  { baseCost: 15, emoji: '‚öîÔ∏è', description: 'Fights predators' },
                scout:    { baseCost: 25, emoji: 'üîç', description: 'Fast explorer' },
                carrier:  { baseCost: 40, emoji: 'üí™', description: 'High carry capacity' },
                queen:    { baseCost: 80, emoji: 'üëë', description: 'Spawns workers over time' }
            },

            // Ant types with Pokemon-style stats (HP, ATK, DEF) plus behavior stats
            antTypes: {
                worker: {
                    // Classic dark brown ant - balanced stats
                    color: { r: 45, g: 30, b: 20 },
                    accentColor: { r: 70, g: 50, b: 35 },
                    // Pokemon-style stats
                    hp: 10,                  // Health points
                    atk: 2,                  // Attack power
                    def: 2,                  // Defense (damage reduction)
                    // Behavior stats
                    speed: 0.5,
                    carryCapacity: 1,
                    carrySpeedBonus: 1.0,
                    pheromoneStrength: 0.8,
                    foodDetectRadius: 12,
                    // Level bonuses per level (1-5)
                    levelBonuses: {
                        hp: 2,               // +2 HP per level
                        atk: 0.5,            // +0.5 ATK per level
                        def: 0.5,            // +0.5 DEF per level
                        speed: 0.06,
                        carryCapacity: 0.25,
                        carrySpeedBonus: 0.08,
                        foodDetectRadius: 3
                    },
                    skillLevel: 3,
                    skillName: 'Efficient Forager',
                    skillDesc: 'Follows pheromone trails with 95% accuracy instead of 70%'
                },
                soldier: {
                    // Deep red/crimson - high ATK, good DEF
                    color: { r: 120, g: 25, b: 25 },
                    accentColor: { r: 180, g: 50, b: 50 },
                    // Pokemon-style stats
                    hp: 20,                  // Tanky
                    atk: 8,                  // High attack
                    def: 5,                  // Good defense
                    // Behavior stats
                    speed: 0.5,
                    carryCapacity: 1,
                    carrySpeedBonus: 0.9,
                    pheromoneStrength: 0.6,
                    foodDetectRadius: 10,
                    levelBonuses: {
                        hp: 5,               // +5 HP per level
                        atk: 2,              // +2 ATK per level
                        def: 1,              // +1 DEF per level
                        speed: 0.05,
                        foodDetectRadius: 2
                    },
                    skillLevel: 3,
                    skillName: 'Berserker',
                    skillDesc: 'ATK doubles when colony has lost ants to predators recently'
                },
                scout: {
                    // Bright golden/yellow - fast, low combat stats
                    color: { r: 180, g: 140, b: 40 },
                    accentColor: { r: 220, g: 180, b: 60 },
                    // Pokemon-style stats
                    hp: 6,                   // Fragile
                    atk: 1,                  // Low attack
                    def: 1,                  // Low defense
                    // Behavior stats
                    speed: 0.7,
                    carryCapacity: 1,
                    carrySpeedBonus: 0.9,
                    pheromoneStrength: 4.0,
                    foodDetectRadius: 160,
                    wanderStrength: 0.5,
                    levelBonuses: {
                        hp: 1,
                        atk: 0.25,
                        def: 0.25,
                        speed: 0.1,
                        pheromoneStrength: 1.0,
                        foodDetectRadius: 40
                    },
                    skillLevel: 3,
                    skillName: 'Trailblazer',
                    skillDesc: 'Discovering food creates a bright beacon visible to all nearby ants'
                },
                carrier: {
                    // Steel blue/gray - high HP, high DEF
                    color: { r: 50, g: 65, b: 85 },
                    accentColor: { r: 80, g: 100, b: 130 },
                    // Pokemon-style stats
                    hp: 25,                  // Very tanky
                    atk: 1,                  // Low attack
                    def: 6,                  // High defense
                    // Behavior stats
                    speed: 0.4,
                    carryCapacity: 3,
                    carrySpeedBonus: 1.2,
                    pheromoneStrength: 0.5,
                    foodDetectRadius: 14,
                    size: 1.35,
                    levelBonuses: {
                        hp: 6,               // +6 HP per level
                        atk: 0.25,
                        def: 1.5,            // +1.5 DEF per level
                        speed: 0.04,
                        carryCapacity: 0.5,
                        carrySpeedBonus: 0.12,
                        foodDetectRadius: 3
                    },
                    skillLevel: 3,
                    skillName: 'Beast of Burden',
                    skillDesc: 'No speed penalty when carrying food - moves at full speed always'
                },
                queen: {
                    // Royal purple/magenta - moderate stats, spawns workers
                    color: { r: 100, g: 45, b: 120 },
                    accentColor: { r: 150, g: 80, b: 170 },
                    // Pokemon-style stats
                    hp: 30,                  // High HP - valuable target
                    atk: 3,                  // Moderate attack
                    def: 4,                  // Moderate defense
                    // Behavior stats
                    speed: 0.25,
                    carryCapacity: 1,
                    carrySpeedBonus: 1,
                    pheromoneStrength: 1.2,
                    foodDetectRadius: 8,
                    size: 1.6,
                    spawnInterval: 900,
                    staysNearNest: true,
                    levelBonuses: {
                        speed: 0.02,
                        pheromoneStrength: 0.15,
                        spawnInterval: -100  // Faster spawning with levels (negative = better)
                    },
                    skillLevel: 3,
                    skillName: 'Royal Decree',
                    skillDesc: 'All ants within range receive +25% speed boost from royal inspiration'
                }
            },

            // Level thresholds (XP needed for each level)
            levelThresholds: [0, 8, 20, 40, 75],  // Level 1, 2, 3, 4, 5

            // Colony state tracking
            recentDeaths: 0,
            deathDecayTimer: 0,

            // Predator territories and stats
            predators: {
                spider: {
                    x: 0, y: 0, radius: 120,
                    multiplier: 3,
                    color: { r: 80, g: 20, b: 20 },
                    label: 'SPIDER ZONE',
                    huntRadius: 100,
                    killRadius: 12,
                    speed: 1.8,
                    // Pokemon-style stats
                    hp: 50,                  // Lower HP, but deadly
                    atk: 15,                 // High attack - kills most ants in 1-2 hits
                    def: 3                   // Low defense
                },
                beetle: {
                    x: 0, y: 0, radius: 90,
                    multiplier: 2,
                    color: { r: 50, g: 70, b: 35 },
                    label: 'BEETLE ZONE',
                    patrolSpeed: 0.5,
                    killRadius: 20,
                    blockRadius: 35,
                    // Pokemon-style stats
                    hp: 80,                  // Tanky
                    atk: 10,                 // Moderate attack
                    def: 8                   // High defense - hard to damage
                }
            }
        };

        // ===========================================
        // CURRENCY SYSTEM
        // ===========================================

        let coins = 50;

        // ===========================================
        // SURVIVAL MODE STATE
        // ===========================================

        let gameOver = false;
        let gameStartTime = Date.now();
        let totalAntsSpawned = 0;
        let totalCoinsEarned = 0;
        let lastUpdateTime = Date.now();
        
        // Arrays to hold multiple predators of each type
        let spiderPredators = [];
        let beetlePredators = [];

        function getElapsedSeconds() {
            return (Date.now() - gameStartTime) / 1000;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function checkGameOver() {
            if (gameOver) return;

            // Game over when all ants are dead (after 2 second grace period)
            if (ants.length === 0 && getElapsedSeconds() > 2) {
                triggerGameOver();
            }
        }

        function triggerGameOver() {
            gameOver = true;

            // Update final stats
            document.getElementById('final-time').textContent = formatTime(getElapsedSeconds());
            document.getElementById('final-food').textContent = foodCollected;
            document.getElementById('final-coins').textContent = totalCoinsEarned;
            document.getElementById('final-ants').textContent = totalAntsSpawned;

            // Show modal
            document.getElementById('game-over-modal').classList.add('visible');
        }

        let lastPredatorSpawnTime = 0;  // Track spawn time in seconds

        function checkPredatorSpawn() {
            if (gameOver) return;

            const elapsed = getElapsedSeconds();
            const spawnInterval = 30;  // Every 30 seconds

            // Check if enough time has passed since last spawn
            if (elapsed >= spawnInterval && elapsed - lastPredatorSpawnTime >= spawnInterval) {
                lastPredatorSpawnTime = elapsed;
                spawnAdditionalPredators();
            }
        }

        function spawnAdditionalPredators() {
            // Spawn one more of each predator type
            const newSpider = new Spider();
            // Offset position slightly
            newSpider.x += (Math.random() - 0.5) * 50;
            newSpider.y += (Math.random() - 0.5) * 50;
            spiderPredators.push(newSpider);

            const newBeetle = new Beetle();
            newBeetle.x += (Math.random() - 0.5) * 50;
            newBeetle.y += (Math.random() - 0.5) * 50;
            beetlePredators.push(newBeetle);
        }

        // ===========================================
        // UPGRADE SYSTEM (Vampire Survivors style)
        // ===========================================

        let upgradesPaused = false;
        let lastUpgradeTime = 0;
        const UPGRADE_INTERVAL = 20;  // Seconds between upgrade offers
        let activeUpgrades = [];  // Track which upgrades player has chosen
        let upgradeMultipliers = {
            antSpeed: 1,
            carryCapacity: 1,
            spawnCostReduction: 1,
            foodValue: 1,
            coinBonus: 0,
            maxAnts: 0,
            detectionRadius: 1,
            atkBonus: 0,       // Flat ATK bonus for all ants
            defBonus: 0,       // Flat DEF bonus for all ants
            hpBonus: 0,        // Flat HP bonus for all ants
            queenSpawnRate: 1
        };

        const UPGRADE_POOL = [
            {
                id: 'speed_boost',
                name: 'Swift Legs',
                description: 'All ants move 15% faster',
                emoji: '‚ö°',
                apply: () => { upgradeMultipliers.antSpeed *= 1.15; },
                maxStacks: 5
            },
            {
                id: 'carry_boost',
                name: 'Strong Mandibles',
                description: 'Carry capacity +1 for all ants',
                emoji: 'üí™',
                apply: () => { upgradeMultipliers.carryCapacity += 0.25; },
                maxStacks: 4
            },
            {
                id: 'cheap_spawns',
                name: 'Efficient Breeding',
                description: 'Ant spawn costs reduced by 15%',
                emoji: 'ü•ö',
                apply: () => { upgradeMultipliers.spawnCostReduction *= 0.85; },
                maxStacks: 4
            },
            {
                id: 'food_value',
                name: 'Nutrient Rich',
                description: 'Food gives 25% more value',
                emoji: 'üçØ',
                apply: () => { upgradeMultipliers.foodValue *= 1.25; },
                maxStacks: 4
            },
            {
                id: 'coin_bonus',
                name: 'Golden Harvest',
                description: '+2 coins per food delivery',
                emoji: 'üí∞',
                apply: () => { upgradeMultipliers.coinBonus += 2; },
                maxStacks: 5
            },
            {
                id: 'max_ants',
                name: 'Colony Expansion',
                description: 'Max colony size +25 ants',
                emoji: 'üè†',
                apply: () => {
                    upgradeMultipliers.maxAnts += 25;
                    CONFIG.maxAnts += 25;
                },
                maxStacks: 4
            },
            {
                id: 'detection',
                name: 'Keen Senses',
                description: 'Food detection radius +30%',
                emoji: 'üëÅÔ∏è',
                apply: () => { upgradeMultipliers.detectionRadius *= 1.3; },
                maxStacks: 3
            },
            {
                id: 'free_worker',
                name: 'Spontaneous Birth',
                description: 'Instantly spawn 3 free workers',
                emoji: 'üêú',
                apply: () => {
                    for (let i = 0; i < 3; i++) {
                        if (ants.length < CONFIG.maxAnts) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 30 + Math.random() * 20;
                            const ant = new Ant(
                                CONFIG.nestX + Math.cos(angle) * dist,
                                CONFIG.nestY + Math.sin(angle) * dist,
                                'worker'
                            );
                            ants.push(ant);
                            totalAntsSpawned++;
                        }
                    }
                },
                maxStacks: 99
            },
            {
                id: 'free_soldier',
                name: 'Call to Arms',
                description: 'Instantly spawn 2 free soldiers',
                emoji: '‚öîÔ∏è',
                apply: () => {
                    for (let i = 0; i < 2; i++) {
                        if (ants.length < CONFIG.maxAnts) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 30 + Math.random() * 20;
                            const ant = new Ant(
                                CONFIG.nestX + Math.cos(angle) * dist,
                                CONFIG.nestY + Math.sin(angle) * dist,
                                'soldier'
                            );
                            ants.push(ant);
                            totalAntsSpawned++;
                        }
                    }
                },
                maxStacks: 99
            },
            {
                id: 'atk_boost',
                name: 'Combat Training',
                description: 'All ants gain +2 ATK',
                emoji: 'üó°Ô∏è',
                apply: () => { upgradeMultipliers.atkBonus += 2; },
                maxStacks: 5
            },
            {
                id: 'def_boost',
                name: 'Hardened Carapace',
                description: 'All ants gain +2 DEF',
                emoji: 'üõ°Ô∏è',
                apply: () => { upgradeMultipliers.defBonus += 2; },
                maxStacks: 5
            },
            {
                id: 'hp_boost',
                name: 'Vitality',
                description: 'All ants gain +5 max HP',
                emoji: '‚ù§Ô∏è',
                apply: () => { upgradeMultipliers.hpBonus += 5; },
                maxStacks: 5
            },
            {
                id: 'queen_boost',
                name: 'Royal Fertility',
                description: 'Queens spawn workers 25% faster',
                emoji: 'üëë',
                apply: () => { upgradeMultipliers.queenSpawnRate *= 0.75; },
                maxStacks: 3
            },
            {
                id: 'coin_burst',
                name: 'Treasure Found',
                description: 'Instantly gain 50 coins',
                emoji: '‚ú®',
                apply: () => {
                    coins += 50;
                    totalCoinsEarned += 50;
                },
                maxStacks: 99
            }
        ];

        function getUpgradeStacks(upgradeId) {
            return activeUpgrades.filter(u => u === upgradeId).length;
        }

        function getRandomUpgrades(count = 3) {
            // Filter out maxed upgrades
            const available = UPGRADE_POOL.filter(u => getUpgradeStacks(u.id) < u.maxStacks);

            // Shuffle and pick
            const shuffled = [...available].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, Math.min(count, shuffled.length));
        }

        function showUpgradeSelection() {
            upgradesPaused = true;
            const upgrades = getRandomUpgrades(3);

            const container = document.getElementById('upgrade-options');
            container.innerHTML = '';

            upgrades.forEach(upgrade => {
                const stacks = getUpgradeStacks(upgrade.id);
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `
                    <div class="upgrade-emoji">${upgrade.emoji}</div>
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.description}</div>
                    ${stacks > 0 ? `<div class="upgrade-stacks">x${stacks + 1}</div>` : ''}
                `;
                card.onclick = () => selectUpgrade(upgrade);
                container.appendChild(card);
            });

            document.getElementById('upgrade-modal').classList.add('visible');
        }

        function selectUpgrade(upgrade) {
            upgrade.apply();
            activeUpgrades.push(upgrade.id);

            document.getElementById('upgrade-modal').classList.remove('visible');
            upgradesPaused = false;
            lastUpgradeTime = getElapsedSeconds();
        }

        function checkUpgradeTime() {
            if (gameOver || upgradesPaused) return;

            const elapsed = getElapsedSeconds();
            const timeSinceLastUpgrade = elapsed - lastUpgradeTime;

            if (timeSinceLastUpgrade >= UPGRADE_INTERVAL) {
                showUpgradeSelection();
            }
        }

        function resetUpgrades() {
            activeUpgrades = [];
            upgradeMultipliers = {
                antSpeed: 1,
                carryCapacity: 1,
                spawnCostReduction: 1,
                foodValue: 1,
                coinBonus: 0,
                maxAnts: 0,
                detectionRadius: 1,
                atkBonus: 0,
                defBonus: 0,
                hpBonus: 0,
                queenSpawnRate: 1
            };
            lastUpgradeTime = 0;
            CONFIG.maxAnts = 300;  // Reset to default
        }

        function restartGame() {
            // Hide modals
            document.getElementById('game-over-modal').classList.remove('visible');
            document.getElementById('upgrade-modal').classList.remove('visible');

            // Reset upgrades
            resetUpgrades();
            upgradesPaused = false;

            // Reset game state
            gameOver = false;
            gameStartTime = Date.now();
            lastUpdateTime = Date.now();
            lastPredatorSpawnTime = 0;
            coins = 50;
            totalAntsSpawned = 0;
            totalCoinsEarned = 0;

            // Clear entities
            ants.length = 0;
            foodItems.length = 0;
            foodCollected = 0;
            antIdCounter = 0;
            antSpawnCounts = { worker: 0, soldier: 0, scout: 0, carrier: 0, queen: 0 };

            // Reset seed and regenerate spots
            currentSeed = Date.now();
            rng = new SeededRNG(currentSeed);
            generateMapSpots();

            // Update predator positions from spots
            for (const spot of predatorSpots) {
                if (spot.type === 'spider') {
                    CONFIG.predators.spider.x = spot.x;
                    CONFIG.predators.spider.y = spot.y;
                } else if (spot.type === 'beetle') {
                    CONFIG.predators.beetle.x = spot.x;
                    CONFIG.predators.beetle.y = spot.y;
                }
            }

            // Reset predator arrays - just one of each to start
            spiderPredators = [new Spider()];
            beetlePredators = [new Beetle()];

            // Reinitialize
            initAnts();
            totalAntsSpawned = ants.length;
            resize();
            updateUI();
        }

        function canAfford(cost) {
            return coins >= cost;
        }

        function spendCoins(amount) {
            if (coins >= amount) {
                coins -= amount;
                updateUI();
                return true;
            }
            return false;
        }

        function earnCoins(amount) {
            coins += amount;
            totalCoinsEarned += amount;
            updateUI();
        }

        function isInDangerZone(x, y) {
            // Check if position is near a predator spawn spot
            for (const spot of predatorSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius * 2) {
                    return true;
                }
            }
            return false;
        }

        function getDangerZoneMultiplier(x, y) {
            // Give bonus gold for killing predators near their den
            let maxMultiplier = 1;
            for (const spot of predatorSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius * 2) {
                    maxMultiplier = Math.max(maxMultiplier, 2);  // 2x gold near predator dens
                }
            }
            return maxMultiplier;
        }

        function isNearBeetle(x, y) {
            // Check all beetles in the array
            for (const beetle of beetlePredators) {
                if (Math.hypot(x - beetle.x, y - beetle.y) < CONFIG.predators.beetle.blockRadius) {
                    return true;
                }
            }
            return false;
        }

        // ===========================================
        // SPAWN NOTIFICATIONS
        // ===========================================

        let spawnNotifications = [];

        function addSpawnNotification(antType) {
            const typeNames = {
                worker: 'Worker',
                soldier: 'Soldier',
                scout: 'Scout',
                carrier: 'Carrier',
                queen: 'Queen'
            };
            const typeColors = {
                worker: 'rgba(139, 90, 43, 0.9)',
                soldier: 'rgba(170, 60, 50, 0.9)',
                scout: 'rgba(180, 140, 60, 0.9)',
                carrier: 'rgba(100, 80, 60, 0.9)',
                queen: 'rgba(200, 150, 100, 0.9)'
            };
            spawnNotifications.push({
                text: `${typeNames[antType]} spawned!`,
                color: typeColors[antType],
                x: CONFIG.nestX,
                y: CONFIG.nestY - getColonySize() - 20,
                alpha: 1,
                life: 90
            });
        }

        function updateSpawnNotifications() {
            for (let i = spawnNotifications.length - 1; i >= 0; i--) {
                const notif = spawnNotifications[i];
                notif.y -= 0.5;
                notif.life--;
                notif.alpha = notif.life / 90;
                if (notif.life <= 0) {
                    spawnNotifications.splice(i, 1);
                }
            }
        }

        function drawSpawnNotifications() {
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px "DM Mono", monospace';
            for (const notif of spawnNotifications) {
                ctx.fillStyle = notif.color.replace('0.9', notif.alpha.toFixed(2));
                ctx.fillText(notif.text, notif.x, notif.y);
            }
        }

        // ===========================================
        // AMBIENT PARTICLES
        // ===========================================

        let dustMotes = [];

        function initAmbientParticles() {
            dustMotes = [];
            const numDust = Math.floor((width * height) / 25000);
            for (let i = 0; i < numDust; i++) {
                dustMotes.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: 0.5 + Math.random() * 1.5,
                    alpha: 0.08 + Math.random() * 0.15,
                    speed: 0.08 + Math.random() * 0.15,
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.008 + Math.random() * 0.015
                });
            }
        }

        function updateAmbientParticles() {
            for (const dust of dustMotes) {
                dust.wobble += dust.wobbleSpeed;
                dust.y -= dust.speed * 0.3;
                dust.x += Math.sin(dust.wobble) * 0.25;
                if (dust.y < -10) {
                    dust.y = height + 10;
                    dust.x = Math.random() * width;
                }
            }
        }

        function drawAmbientParticles() {
            for (const dust of dustMotes) {
                const gradient = ctx.createRadialGradient(dust.x, dust.y, 0, dust.x, dust.y, dust.size * 2);
                gradient.addColorStop(0, `rgba(255, 250, 220, ${dust.alpha})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size * 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ===========================================
        // GRASS SYSTEM - Reduced density
        // ===========================================

        let grassClusters = [];

        function generateGrass() {
            grassClusters = [];
            const numClusters = Math.floor((width * height) / 50000); // Reduced from 25000

            for (let i = 0; i < numClusters; i++) {
                const clusterX = Math.random() * width;
                const clusterY = Math.random() * height;

                const distToNest = Math.hypot(clusterX - CONFIG.nestX, clusterY - CONFIG.nestY);
                if (distToNest < CONFIG.nestRadius * 3) continue;

                const cluster = {
                    x: clusterX,
                    y: clusterY,
                    blades: []
                };

                const numBlades = 4 + Math.floor(Math.random() * 5); // Reduced blades per cluster
                for (let j = 0; j < numBlades; j++) {
                    cluster.blades.push({
                        offsetX: (Math.random() - 0.5) * 15,
                        offsetY: (Math.random() - 0.5) * 6,
                        height: 12 + Math.random() * 20,
                        width: 1.5 + Math.random() * 1,
                        curve: (Math.random() - 0.5) * 0.5,
                        phase: Math.random() * Math.PI * 2,
                        swaySpeed: 0.012 + Math.random() * 0.008,
                        swayAmount: 0.015 + Math.random() * 0.02,
                        color: `hsl(${95 + Math.random() * 25}, ${35 + Math.random() * 20}%, ${28 + Math.random() * 15}%)`
                    });
                }

                grassClusters.push(cluster);
            }
        }

        function drawGrass() {
            for (const cluster of grassClusters) {
                for (const blade of cluster.blades) {
                    const x = cluster.x + blade.offsetX;
                    const y = cluster.y + blade.offsetY;
                    const sway = Math.sin(time * blade.swaySpeed + blade.phase) * blade.swayAmount * blade.height;

                    ctx.save();
                    ctx.strokeStyle = blade.color;
                    ctx.lineWidth = blade.width;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    const cp1x = x + blade.curve * blade.height * 0.5 + sway * 0.3;
                    const cp1y = y - blade.height * 0.5;
                    const cp2x = x + blade.curve * blade.height + sway;
                    const cp2y = y - blade.height * 0.85;
                    const endX = x + blade.curve * blade.height * 1.2 + sway * 1.2;
                    const endY = y - blade.height;

                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        // ===========================================
        // FOREST FLOOR - Reduced clutter
        // ===========================================

        let forestElements = [];

        function generateForestElements() {
            forestElements = [];
            const numElements = Math.floor((width * height) / 30000); // Reduced from 12000

            for (let i = 0; i < numElements; i++) {
                const type = Math.random();
                let element;

                if (type < 0.4) {
                    // Fallen leaf
                    element = {
                        type: 'leaf',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 8 + Math.random() * 12,
                        rotation: Math.random() * Math.PI * 2,
                        color: ['#5a6040', '#6b7050', '#4a5535', '#7a8560'][Math.floor(Math.random() * 4)],
                        alpha: 0.3 + Math.random() * 0.25
                    };
                } else if (type < 0.7) {
                    // Pebble
                    element = {
                        type: 'pebble',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: 2 + Math.random() * 4,
                        color: ['#4a4840', '#5a5850', '#3a3835', '#6a6860'][Math.floor(Math.random() * 4)],
                        alpha: 0.4 + Math.random() * 0.25
                    };
                } else {
                    // Twig
                    element = {
                        type: 'twig',
                        x: Math.random() * width,
                        y: Math.random() * height,
                        length: 15 + Math.random() * 25,
                        rotation: Math.random() * Math.PI,
                        thickness: 1 + Math.random() * 1.5,
                        color: '#4d3a2a',
                        alpha: 0.35 + Math.random() * 0.2
                    };
                }

                const distToNest = Math.hypot(element.x - CONFIG.nestX, element.y - CONFIG.nestY);
                if (distToNest > CONFIG.nestRadius * 2.5) {
                    forestElements.push(element);
                }
            }
        }

        function drawForestElement(el) {
            ctx.save();
            ctx.globalAlpha = el.alpha;

            switch (el.type) {
                case 'leaf':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, el.size * 0.35, el.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -el.size * 0.4);
                    ctx.lineTo(0, el.size * 0.4);
                    ctx.stroke();
                    break;

                case 'pebble':
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.ellipse(el.x, el.y, el.size, el.size * 0.65, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'twig':
                    ctx.translate(el.x, el.y);
                    ctx.rotate(el.rotation);
                    ctx.strokeStyle = el.color;
                    ctx.lineWidth = el.thickness;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-el.length / 2, 0);
                    ctx.lineTo(el.length / 2, 0);
                    ctx.stroke();
                    break;
            }

            ctx.restore();
        }

        // ===========================================
        // PHEROMONE GRID
        // ===========================================

        let pheromoneGrid = { food: null, home: null, cols: 0, rows: 0 };

        function initPheromoneGrid() {
            const cellSize = CONFIG.pheromoneGridSize;
            pheromoneGrid.cols = Math.ceil(width / cellSize);
            pheromoneGrid.rows = Math.ceil(height / cellSize);
            const size = pheromoneGrid.cols * pheromoneGrid.rows;
            pheromoneGrid.food = new Float32Array(size);
            pheromoneGrid.home = new Float32Array(size);
        }

        function getPheromoneIndex(x, y) {
            const col = Math.floor(x / CONFIG.pheromoneGridSize);
            const row = Math.floor(y / CONFIG.pheromoneGridSize);
            if (col < 0 || col >= pheromoneGrid.cols || row < 0 || row >= pheromoneGrid.rows) return -1;
            return row * pheromoneGrid.cols + col;
        }

        function depositPheromone(x, y, type, amount) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return;
            const grid = type === 'food' ? pheromoneGrid.food : pheromoneGrid.home;
            grid[idx] = Math.min(grid[idx] + amount, CONFIG.pheromoneMax);
        }

        function getPheromone(x, y, type) {
            const idx = getPheromoneIndex(x, y);
            if (idx === -1) return 0;
            return (type === 'food' ? pheromoneGrid.food : pheromoneGrid.home)[idx];
        }

        function samplePheromoneDirection(x, y, currentAngle, type) {
            const sampleDist = 15;
            const sampleAngle = 0.5;
            const left = getPheromone(x + Math.cos(currentAngle - sampleAngle) * sampleDist, y + Math.sin(currentAngle - sampleAngle) * sampleDist, type);
            const center = getPheromone(x + Math.cos(currentAngle) * sampleDist, y + Math.sin(currentAngle) * sampleDist, type);
            const right = getPheromone(x + Math.cos(currentAngle + sampleAngle) * sampleDist, y + Math.sin(currentAngle + sampleAngle) * sampleDist, type);

            if (center >= left && center >= right) return 0;
            return (left > right ? -1 : 1) * sampleAngle * CONFIG.pheromoneFollowStrength;
        }

        function decayPheromones() {
            const decay = CONFIG.pheromoneDecay;
            for (let i = 0; i < pheromoneGrid.food.length; i++) {
                pheromoneGrid.food[i] *= decay;
                pheromoneGrid.home[i] *= decay;
                if (pheromoneGrid.food[i] < 0.01) pheromoneGrid.food[i] = 0;
                if (pheromoneGrid.home[i] < 0.01) pheromoneGrid.home[i] = 0;
            }
        }

        // ===========================================
        // PREDATORS (Spider, Beetle)
        // ===========================================

        // Helper to get all predators as a flat array
        function getAllPredators() {
            return [...spiderPredators, ...beetlePredators];
        }

        // Helper to get predators with their type key (for card display)
        function getAllPredatorsWithKeys() {
            const result = [];
            for (const p of spiderPredators) result.push({ predator: p, key: 'spider' });
            for (const p of beetlePredators) result.push({ predator: p, key: 'beetle' });
            return result;
        }

        // Attack an ant - uses Pokemon-style damage calculation
        function attackAnt(ant, predator) {
            // Get predator's attack power
            const attackPower = predator.atk || 10;

            // All ants can fight back now (deal damage to predator)
            ant.attemptFight(predator);

            // Ant takes damage
            const survived = ant.takeDamage(attackPower);

            if (!survived) {
                // Ant is killed
                const idx = ants.indexOf(ant);
                if (idx !== -1) {
                    ants.splice(idx, 1);

                    // Track death for Berserker skill (decays over time)
                    CONFIG.recentDeaths++;
                    CONFIG.deathDecayTimer = 600;  // 10 seconds of rage
                }
                return true;  // Ant died
            }

            // Ant survived the hit - give it a panic response
            ant.panicTimer = 60;
            return false;  // Ant survived
        }

        // Legacy function name for compatibility
        function killAnt(ant, predator) {
            return attackAnt(ant, predator);
        }

        // Decay recent deaths counter over time
        function updateDeathCounter() {
            if (CONFIG.deathDecayTimer > 0) {
                CONFIG.deathDecayTimer--;
                if (CONFIG.deathDecayTimer <= 0) {
                    CONFIG.recentDeaths = Math.max(0, CONFIG.recentDeaths - 1);
                    if (CONFIG.recentDeaths > 0) {
                        CONFIG.deathDecayTimer = 300;  // Decay one at a time
                    }
                }
            }
        }

        // Trailblazer beacons for Scout skill
        let trailblazerBeacons = [];

        function addTrailblazerBeacon(x, y, food) {
            trailblazerBeacons.push({
                x: x,
                y: y,
                food: food,
                timer: 300,  // 5 seconds
                pulsePhase: 0
            });
        }

        function updateTrailblazerBeacons() {
            for (let i = trailblazerBeacons.length - 1; i >= 0; i--) {
                const beacon = trailblazerBeacons[i];
                beacon.timer--;
                beacon.pulsePhase += 0.15;

                if (beacon.timer <= 0) {
                    trailblazerBeacons.splice(i, 1);
                    continue;
                }

                // Attract nearby ants toward the beacon
                for (const ant of ants) {
                    if (ant.type === 'soldier') continue;  // Soldiers ignore
                    if (ant.state !== 'exploring') continue;

                    const dist = Math.hypot(ant.x - beacon.x, ant.y - beacon.y);
                    if (dist < 150 && dist > 20) {
                        // Gently guide ants toward beacon
                        const angleToBeacon = Math.atan2(beacon.y - ant.y, beacon.x - ant.x);
                        const influence = 0.02 * (1 - dist / 150);
                        ant.angle += ant.angleDiff(angleToBeacon, ant.angle) * influence;
                    }
                }
            }
        }

        function drawTrailblazerBeacons() {
            for (const beacon of trailblazerBeacons) {
                const alpha = Math.min(1, beacon.timer / 60);
                const pulse = Math.sin(beacon.pulsePhase) * 0.3 + 0.7;

                ctx.save();

                // Outer glow rings
                for (let r = 3; r >= 1; r--) {
                    const radius = 20 + r * 15 + Math.sin(beacon.pulsePhase - r * 0.5) * 5;
                    ctx.beginPath();
                    ctx.arc(beacon.x, beacon.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * 0.15 * pulse / r})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Inner beacon
                ctx.beginPath();
                ctx.arc(beacon.x, beacon.y, 8 + pulse * 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha * 0.6 * pulse})`;
                ctx.fill();

                // Center bright spot
                ctx.beginPath();
                ctx.arc(beacon.x, beacon.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha * pulse})`;
                ctx.fill();

                ctx.restore();
            }
        }

        class Spider {
            constructor() {
                const cfg = CONFIG.predators.spider;
                this.x = cfg.x;
                this.y = cfg.y;
                this.targetX = this.x;
                this.targetY = this.y;
                this.angle = Math.random() * Math.PI * 2;
                this.size = 18;
                this.speed = cfg.speed;
                this.legPhase = 0;
                this.state = 'hunting';
                this.eatTimer = 0;
                this.stunTimer = 0;

                // Pokemon-style stats
                this.maxHp = cfg.hp;
                this.currentHp = cfg.hp;
                this.atk = cfg.atk;
                this.def = cfg.def;
            }

            stun(duration) {
                this.stunTimer = duration;
                this.state = 'stunned';

                // Respawn with full HP if killed (HP <= 0)
                if (this.currentHp <= 0) {
                    const cfg = CONFIG.predators.spider;
                    this.currentHp = cfg.hp;
                    this.x = cfg.x;
                    this.y = cfg.y;
                }
            }

            update() {
                const cfg = CONFIG.predators.spider;
                this.legPhase += 0.2;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) this.state = 'hunting';
                    return;
                }

                if (this.state === 'eating') {
                    this.eatTimer--;
                    if (this.eatTimer <= 0) this.state = 'hunting';
                    return;
                }

                // Find nearest ant within territory
                let nearestAnt = null;
                let nearestDist = cfg.huntRadius;

                for (const ant of ants) {
                    const distToCenter = Math.hypot(ant.x - cfg.x, ant.y - cfg.y);
                    if (distToCenter > cfg.radius) continue;
                    const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestAnt = ant;
                    }
                }

                if (nearestAnt) {
                    this.targetX = nearestAnt.x;
                    this.targetY = nearestAnt.y;

                    if (nearestDist < cfg.killRadius) {
                        if (killAnt(nearestAnt, this)) {
                            this.state = 'eating';
                            this.eatTimer = 60;
                        }
                    }
                } else {
                    // Wander within entire territory (uses full radius)
                    if (Math.random() < 0.03) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * cfg.radius * 0.95;  // Use almost full radius
                        this.targetX = cfg.x + Math.cos(angle) * dist;
                        this.targetY = cfg.y + Math.sin(angle) * dist;
                    }
                }

                // Move toward target but stay in territory
                const angleToTarget = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                this.angle = angleToTarget;

                let newX = this.x + Math.cos(this.angle) * this.speed;
                let newY = this.y + Math.sin(this.angle) * this.speed;

                // Constrain to territory
                const distFromCenter = Math.hypot(newX - cfg.x, newY - cfg.y);
                if (distFromCenter > cfg.radius - 10) {
                    const angleFromCenter = Math.atan2(newY - cfg.y, newX - cfg.x);
                    newX = cfg.x + Math.cos(angleFromCenter) * (cfg.radius - 10);
                    newY = cfg.y + Math.sin(angleFromCenter) * (cfg.radius - 10);
                }

                const dist = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                if (dist > 5) {
                    this.x = newX;
                    this.y = newY;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.3;

                // Stun effect
                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(3, 3, s * 0.8, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.strokeStyle = '#1a1008';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 4; i++) {
                        const attachY = -s * 0.3 + i * s * 0.2;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.2, attachY);
                        ctx.lineTo(side * s * 0.7, attachY - s * 0.2 + phase * s * 0.15);
                        ctx.lineTo(side * s * 0.9, attachY + s * 0.3 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Abdomen
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.3, s * 0.45, s * 0.55, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#3a2a18';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.2, s * 0.2, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#2a1a10';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.25, s * 0.3, s * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#400808';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 80, 80, 0.5)';
                ctx.beginPath();
                ctx.arc(-s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.arc(s * 0.1, -s * 0.45, s * 0.04, 0, Math.PI * 2);
                ctx.fill();

                if (this.state === 'eating') {
                    ctx.fillStyle = 'rgba(200, 50, 50, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, -s * 0.55, s * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.6;
                        const y = Math.sin(angle) * s * 0.6 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }

            reset() {
                const cfg = CONFIG.predators.spider;
                this.x = cfg.x;
                this.y = cfg.y;
                this.targetX = this.x;
                this.targetY = this.y;
                this.angle = Math.random() * Math.PI * 2;
                this.state = 'hunting';
                this.eatTimer = 0;
                this.stunTimer = 0;
            }
        }

        class Beetle {
            constructor() {
                const cfg = CONFIG.predators.beetle;
                this.x = cfg.x;
                this.y = cfg.y;
                this.angle = Math.random() * Math.PI * 2;
                this.targetX = cfg.x;
                this.targetY = cfg.y;
                this.size = 22;
                this.legPhase = 0;
                this.state = 'patrolling';
                this.stunTimer = 0;
                this.wanderTimer = 0;

                // Pokemon-style stats
                this.maxHp = cfg.hp;
                this.currentHp = cfg.hp;
                this.atk = cfg.atk;
                this.def = cfg.def;
            }

            stun(duration) {
                this.stunTimer = duration;
                this.state = 'stunned';

                // Respawn with full HP if killed (HP <= 0)
                if (this.currentHp <= 0) {
                    const cfg = CONFIG.predators.beetle;
                    this.currentHp = cfg.hp;
                    this.x = cfg.x;
                    this.y = cfg.y;
                }
            }

            update() {
                const cfg = CONFIG.predators.beetle;
                this.legPhase += 0.12;

                if (this.state === 'stunned') {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) this.state = 'patrolling';
                    return;
                }

                // Random wandering patrol within territory
                this.wanderTimer--;
                if (this.wanderTimer <= 0) {
                    // Pick a new random target within the zone
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * cfg.radius * 0.9;
                    this.targetX = cfg.x + Math.cos(angle) * dist;
                    this.targetY = cfg.y + Math.sin(angle) * dist;
                    this.wanderTimer = 60 + Math.random() * 120;  // New target every 1-3 seconds
                }

                // Move toward target
                const angleToTarget = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                this.angle = angleToTarget;

                this.x += Math.cos(this.angle) * cfg.patrolSpeed;
                this.y += Math.sin(this.angle) * cfg.patrolSpeed;

                // Stay within territory
                const distFromCenter = Math.hypot(this.x - cfg.x, this.y - cfg.y);
                if (distFromCenter > cfg.radius * 0.95) {
                    const angleToCenter = Math.atan2(cfg.y - this.y, cfg.x - this.x);
                    this.x += Math.cos(angleToCenter) * 2;
                    this.y += Math.sin(angleToCenter) * 2;
                }

                // Kill ants in radius
                for (let i = ants.length - 1; i >= 0; i--) {
                    const ant = ants[i];
                    if (Math.hypot(ant.x - this.x, ant.y - this.y) < cfg.killRadius) {
                        killAnt(ant, this);
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI / 2);

                const s = this.size;
                const legWave = Math.sin(this.legPhase) * 0.2;

                if (this.state === 'stunned') {
                    ctx.globalAlpha = 0.5 + Math.sin(this.stunTimer * 0.3) * 0.3;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(4, 4, s * 0.7, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs (6 legs, 3 per side)
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';

                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 3; i++) {
                        const attachY = -s * 0.2 + i * s * 0.25;
                        const phase = (i % 2 === 0) ? legWave : -legWave;

                        ctx.beginPath();
                        ctx.moveTo(side * s * 0.3, attachY);
                        ctx.lineTo(side * s * 0.6, attachY - s * 0.1 + phase * s * 0.1);
                        ctx.lineTo(side * s * 0.75, attachY + s * 0.15 + phase * s * 0.1);
                        ctx.stroke();
                    }
                }

                // Shell (elytra)
                ctx.fillStyle = '#2a3520';
                ctx.beginPath();
                ctx.ellipse(0, s * 0.1, s * 0.5, s * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Shell line
                ctx.strokeStyle = '#1a2510';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.4);
                ctx.lineTo(0, s * 0.6);
                ctx.stroke();

                // Shell highlights
                ctx.fillStyle = '#3a4530';
                ctx.beginPath();
                ctx.ellipse(-s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s * 0.15, 0, s * 0.15, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#1a2010';
                ctx.beginPath();
                ctx.ellipse(0, -s * 0.55, s * 0.3, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mandibles
                ctx.strokeStyle = '#2a1010';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-s * 0.15, -s * 0.7);
                ctx.lineTo(-s * 0.25, -s * 0.85);
                ctx.moveTo(s * 0.15, -s * 0.7);
                ctx.lineTo(s * 0.25, -s * 0.85);
                ctx.stroke();

                // Antennae
                ctx.strokeStyle = '#1a2010';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-s * 0.1, -s * 0.65);
                ctx.lineTo(-s * 0.2, -s * 0.9);
                ctx.lineTo(-s * 0.15, -s * 1.0);
                ctx.moveTo(s * 0.1, -s * 0.65);
                ctx.lineTo(s * 0.2, -s * 0.9);
                ctx.lineTo(s * 0.15, -s * 1.0);
                ctx.stroke();

                // Stun stars
                if (this.state === 'stunned') {
                    ctx.fillStyle = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + this.stunTimer * 0.1;
                        const x = Math.cos(angle) * s * 0.5;
                        const y = Math.sin(angle) * s * 0.5 - s * 0.5;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }

            reset() {
                const cfg = CONFIG.predators.beetle;
                this.x = cfg.x;
                this.y = cfg.y;
                this.angle = Math.random() * Math.PI * 2;
                this.targetX = cfg.x;
                this.targetY = cfg.y;
                this.state = 'patrolling';
                this.stunTimer = 0;
                this.wanderTimer = 0;
            }
        }

        // ===========================================
        // FOOD ITEMS
        // ===========================================

        let foodItems = [];
        let foodCollected = 0;

        // Track ant spawn counts for scaling costs
        let antSpawnCounts = { worker: 0, soldier: 0, scout: 0, carrier: 0, queen: 0 };

        function getAntSpawnCost(antType) {
            const base = CONFIG.antSpawnCosts[antType].baseCost;
            const count = antSpawnCounts[antType];
            // Cost increases by 20% for each ant of that type spawned, reduced by upgrades
            return Math.floor(base * Math.pow(1.2, count) * upgradeMultipliers.spawnCostReduction);
        }

        function spawnAnt(antType) {
            const cost = getAntSpawnCost(antType);
            if (!canAfford(cost)) return false;
            if (ants.length >= CONFIG.maxAnts) return false;
            if (gameOver) return false;

            spendCoins(cost);
            antSpawnCounts[antType]++;
            totalAntsSpawned++;

            const angle = Math.random() * Math.PI * 2;
            const spawnDist = getColonySize() * 0.3;
            const newAnt = new Ant(
                CONFIG.nestX + Math.cos(angle) * spawnDist,
                CONFIG.nestY + Math.sin(angle) * spawnDist,
                antType
            );
            ants.push(newAnt);
            addSpawnNotification(antType);
            updateAntCosts();
            return true;
        }

        function updateAntCosts() {
            for (const antType in CONFIG.antSpawnCosts) {
                const costEl = document.getElementById(`${antType}-cost`);
                if (costEl) {
                    costEl.textContent = getAntSpawnCost(antType);
                }
            }
        }

        const FOOD_LIFETIME_SECONDS = 60;  // 60 seconds until food spoils

        class FoodItem {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = Math.random().toString(36).substr(2, 9);  // Unique ID for tracking
                const config = CONFIG.foodTypes[type];
                this.size = config.size;  // Current size (units of food remaining)
                this.maxSize = config.size;  // Original size
                this.baseRadius = config.baseRadius;
                this.valuePerUnit = config.value;  // Gold per unit of food
                this.name = config.name;
                this.emoji = config.emoji;
                this.carriers = [];
                this.inDangerZone = isInDangerZone(x, y);
                this.spawnTime = Date.now();  // Real timestamp when food was created
                this.spoiled = false;
            }

            update() {
                if (this.getTimeRemaining() <= 0 && !this.spoiled) {
                    this.spoiled = true;
                }
            }

            getTimeRemaining() {
                const elapsed = (Date.now() - this.spawnTime) / 1000;  // Seconds elapsed
                return Math.max(0, Math.ceil(FOOD_LIFETIME_SECONDS - elapsed));
            }

            getRadius() {
                // Radius scales with sqrt of remaining size
                return this.baseRadius * Math.sqrt(this.size / this.maxSize);
            }

            getValue() {
                // Value per unit times danger zone multiplier
                const multiplier = getDangerZoneMultiplier(this.x, this.y);
                return this.valuePerUnit * multiplier;
            }

            // Single ant can always carry 1 unit
            canTakeUnit() {
                return this.size >= 1;
            }

            takeUnit() {
                if (this.size < 1) return 0;
                this.size -= 1;
                return 1;
            }

            isEmpty() {
                return this.size < 1;
            }

            addCarrier(ant) {
                if (!this.carriers.includes(ant)) this.carriers.push(ant);
            }

            removeCarrier(ant) {
                const idx = this.carriers.indexOf(ant);
                if (idx !== -1) this.carriers.splice(idx, 1);
            }

            draw() {
                const r = this.getRadius();
                if (r < 3) return;  // Too small to draw

                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow (offset more so it doesn't darken the emoji)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(3, 5, r * 0.9, r * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Zone-based glow behind emoji
                const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.2);
                if (this.inDangerZone) {
                    // Golden/amber glow for danger zone food
                    glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.5)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 180, 50, 0.2)');
                    glowGrad.addColorStop(1, 'transparent');
                } else {
                    // Green glow for safe zone food
                    glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.4)');
                    glowGrad.addColorStop(0.5, 'rgba(100, 230, 130, 0.15)');
                    glowGrad.addColorStop(1, 'transparent');
                }
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(0, 0, r * 1.2, 0, Math.PI * 2);
                ctx.fill();

                // Draw emoji scaled to size
                const fontSize = Math.max(14, r * 2);
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);

                // Size indicator
                if (this.size > 1) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(r * 0.8, -r * 0.6, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px "DM Mono", monospace';
                    ctx.fillText(Math.floor(this.size), r * 0.8, -r * 0.6);
                }

                // Timer indicator - shows seconds remaining
                const timeLeft = this.getTimeRemaining();
                const timerColor = timeLeft <= 10 ? 'rgba(255, 80, 80, 0.9)' :
                                   timeLeft <= 20 ? 'rgba(255, 180, 80, 0.9)' :
                                   'rgba(255, 255, 255, 0.7)';
                ctx.fillStyle = timerColor;
                ctx.font = 'bold 9px "DM Mono", monospace';
                ctx.fillText(`${timeLeft}s`, 0, r + 12);

                // Spoiling warning flash
                if (timeLeft <= 10 && Math.floor(time / 15) % 2 === 0) {
                    ctx.strokeStyle = 'rgba(255, 80, 80, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, r + 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // Food piece that an ant carries - tracks source food for spoilage and zone
        class CarriedFoodPiece {
            constructor(type, sourceFoodId, fromDangerZone) {
                this.type = type;
                this.emoji = CONFIG.foodTypes[type].emoji;
                this.sourceFoodId = sourceFoodId;  // Track which food this came from
                this.fromDangerZone = fromDangerZone;  // Track zone for glow color
            }
        }

        function addFood(x, y, type) {
            const cost = CONFIG.foodTypes[type].cost;
            if (spendCoins(cost)) {
                foodItems.push(new FoodItem(x, y, type));
                return true;
            }
            return false;
        }

        // ===========================================
        // ANTS
        // ===========================================

        let ants = [];
        let antIdCounter = 0;
        let selectedAnt = null;  // Currently selected ant for character card

        // Ant name generator - normal human names
        const ANT_NAMES = [
            'Gustav', 'Anja', 'Erik', 'Marta', 'Felix', 'Lena', 'Otto', 'Hilda',
            'Bruno', 'Ingrid', 'Karl', 'Freya', 'Hans', 'Greta', 'Fritz', 'Elsa',
            'Max', 'Anna', 'Klaus', 'Liesel', 'Hugo', 'Heidi', 'Emil', 'Rosa',
            'Theo', 'Klara', 'Oscar', 'Maja', 'Lars', 'Petra', 'Nils', 'Vera',
            'Axel', 'Ida', 'Sven', 'Tilda', 'Rolf', 'Britta', 'Lukas', 'Sonja',
            'Kasper', 'Astrid', 'Johan', 'Sigrid', 'Anders', 'Helga', 'Olaf', 'Inga',
            'Finn', 'Linnea', 'Magnus', 'Ylva', 'Bjorn', 'Saga', 'Leif', 'Freja',
            'Henrik', 'Ebba', 'Stefan', 'Alma', 'Viktor', 'Nova', 'Anton', 'Wilma'
        ];
        let usedNames = new Set();

        function generateAntName() {
            // Try to get an unused name
            const availableNames = ANT_NAMES.filter(n => !usedNames.has(n));
            if (availableNames.length > 0) {
                const name = availableNames[Math.floor(Math.random() * availableNames.length)];
                usedNames.add(name);
                return name;
            }
            // All names used, add a number suffix
            const baseName = ANT_NAMES[Math.floor(Math.random() * ANT_NAMES.length)];
            let suffix = 2;
            while (usedNames.has(`${baseName} ${suffix}`)) suffix++;
            const fullName = `${baseName} ${suffix}`;
            usedNames.add(fullName);
            return fullName;
        }

        // Trait quality levels based on roll
        function getTraitQuality(roll) {
            if (roll >= 0.95) return { label: 'Legendary', class: 'legendary', multiplier: 1.4 };
            if (roll >= 0.85) return { label: 'Exceptional', class: 'exceptional', multiplier: 1.25 };
            if (roll >= 0.65) return { label: 'Good', class: 'good', multiplier: 1.1 };
            if (roll >= 0.35) return { label: 'Average', class: '', multiplier: 1.0 };
            if (roll >= 0.15) return { label: 'Below Avg', class: 'weak', multiplier: 0.9 };
            return { label: 'Poor', class: 'poor', multiplier: 0.8 };
        }

        // Rank titles based on experience
        function getAntRank(experience) {
            if (experience >= 100) return { title: 'Legendary', class: 'legendary' };
            if (experience >= 50) return { title: 'Veteran', class: 'exceptional' };
            if (experience >= 25) return { title: 'Experienced', class: 'good' };
            if (experience >= 10) return { title: 'Skilled', class: '' };
            if (experience >= 5) return { title: 'Novice', class: 'weak' };
            return { title: 'Rookie', class: 'poor' };
        }

        class Ant {
            constructor(x, y, type = 'worker') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.id = ++antIdCounter;
                this.name = generateAntName();

                // Individual trait rolls (0-1, higher is better)
                this.traitRolls = {
                    speed: Math.random(),
                    efficiency: Math.random(),
                    detection: Math.random(),
                    resilience: Math.random(),
                    goldBonus: Math.random()  // 0-100% extra gold per delivery
                };

                // Experience tracking
                this.experience = {
                    totalDeliveries: 0,
                    dangerDeliveries: 0,
                    totalValue: 0,
                    predatorEncounters: 0,
                    predatorEscapes: 0,
                    foodDiscovered: 0,      // New: times this ant found food first
                    distanceTraveled: 0     // New: total distance moved
                };

                // Current level (1-5)
                this.level = 1;
                this.hasSkill = false;  // Unlocked at level 3

                // Store type config reference
                this.typeConfig = CONFIG.antTypes[type] || CONFIG.antTypes.worker;

                // Initialize stats (will be recalculated)
                this.recalculateStats();

                // Store starting stats for progress visualization
                this.startingStats = {
                    speed: this.speed,
                    carryCapacity: this.carryCapacity,
                    foodDetectRadius: this.foodDetectRadius,
                    carrySpeedBonus: this.carrySpeedBonus,
                    fightChance: this.fightChance || 0,
                    trailStrength: this.trailStrength || 1,
                    spawnInterval: this.spawnInterval || 900
                };

                this.angle = Math.random() * Math.PI * 2;
                this.state = 'exploring';
                this.targetFood = null;
                this.carriedFoodPiece = null;
                this.carriedFoodValue = 0;
                this.wanderBias = (Math.random() - 0.5) * 0.1;
                this.isScout = type === 'scout';
                this.wanderStrength = this.typeConfig.wanderStrength || CONFIG.wanderStrength;
                this.depositTimer = 0;
                this.foundFoodRecently = false;
                this.legPhase = Math.random() * Math.PI * 2;
                this.colorOffset = Math.floor(Math.random() * 15) - 7;
                this.panicTimer = 0;

                // Soldier-specific properties
                this.targetPredator = null;
                this.escortTarget = null;

                // Queen-specific properties
                this.spawnTimer = 0;
                this.staysNearNest = this.typeConfig.staysNearNest || false;

                // Visual properties
                this.colorConfig = this.typeConfig.color;
                this.accentColor = this.typeConfig.accentColor || this.typeConfig.color;
                this.sizeMultiplier = this.typeConfig.size || 1;

                // Skill-specific state
                this.trailblazerBeacon = null;  // For scout skill
                this.royalAuraTimer = 0;        // For queen skill

                // Position history for glowing trail (level 3+)
                this.positionHistory = [];
            }

            // Calculate current level from XP
            getLevel() {
                const xp = this.getTotalExp();
                const thresholds = CONFIG.levelThresholds;
                for (let i = thresholds.length - 1; i >= 0; i--) {
                    if (xp >= thresholds[i]) return i + 1;
                }
                return 1;
            }

            // Get XP needed for next level
            getXpToNextLevel() {
                const currentLevel = this.getLevel();
                if (currentLevel >= 5) return 0;
                const nextThreshold = CONFIG.levelThresholds[currentLevel];
                return nextThreshold - this.getTotalExp();
            }

            // Get XP progress percentage to next level
            getLevelProgress() {
                const currentLevel = this.getLevel();
                if (currentLevel >= 5) return 100;
                const currentThreshold = CONFIG.levelThresholds[currentLevel - 1];
                const nextThreshold = CONFIG.levelThresholds[currentLevel];
                const xp = this.getTotalExp();
                return ((xp - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
            }

            // Recalculate all stats based on level and traits
            recalculateStats() {
                const typeConfig = this.typeConfig;
                const level = this.getLevel();
                const levelBonus = level - 1;  // 0 at level 1, 4 at level 5

                // Get trait quality multipliers
                const speedQuality = getTraitQuality(this.traitRolls.speed);
                const detectionQuality = getTraitQuality(this.traitRolls.detection);
                const efficiencyQuality = getTraitQuality(this.traitRolls.efficiency);
                const resilienceQuality = getTraitQuality(this.traitRolls.resilience);

                // Calculate base stats with level bonuses
                const levelBonuses = typeConfig.levelBonuses || {};

                // Speed
                const baseSpeed = typeConfig.speed + (levelBonuses.speed || 0) * levelBonus;
                this.baseSpeed = baseSpeed * speedQuality.multiplier;
                this.speed = this.baseSpeed;

                // Detection
                const baseDetection = typeConfig.foodDetectRadius + (levelBonuses.foodDetectRadius || 0) * levelBonus;
                this.foodDetectRadius = baseDetection * detectionQuality.multiplier;

                // Carry efficiency
                const baseEfficiency = typeConfig.carrySpeedBonus + (levelBonuses.carrySpeedBonus || 0) * levelBonus;
                this.carrySpeedBonus = baseEfficiency * efficiencyQuality.multiplier;

                // Carry capacity
                this.carryCapacity = typeConfig.carryCapacity + (levelBonuses.carryCapacity || 0) * levelBonus;

                // Pokemon-style combat stats (with upgrade bonuses)
                const baseHp = typeConfig.hp + (levelBonuses.hp || 0) * levelBonus + upgradeMultipliers.hpBonus;
                const newMaxHp = Math.floor(baseHp * resilienceQuality.multiplier);
                if (this.currentHp === undefined) {
                    this.maxHp = newMaxHp;
                    this.currentHp = this.maxHp;  // Initialize HP on first calc
                } else {
                    // On stat change, heal proportionally
                    const oldMaxHp = this.maxHp || newMaxHp;
                    this.maxHp = newMaxHp;
                    this.currentHp = Math.min(this.maxHp, Math.ceil(this.currentHp * (this.maxHp / oldMaxHp)));
                }

                const baseAtk = typeConfig.atk + (levelBonuses.atk || 0) * levelBonus + upgradeMultipliers.atkBonus;
                this.atk = baseAtk;

                const baseDef = typeConfig.def + (levelBonuses.def || 0) * levelBonus + upgradeMultipliers.defBonus;
                this.def = baseDef * resilienceQuality.multiplier;

                // Pheromone strength
                const basePheromone = typeConfig.pheromoneStrength + (levelBonuses.pheromoneStrength || 0) * levelBonus;
                this.pheromoneStrength = basePheromone;

                // Queen spawn interval
                if (this.type === 'queen') {
                    const baseInterval = typeConfig.spawnInterval + (levelBonuses.spawnInterval || 0) * levelBonus;
                    this.spawnInterval = Math.max(300, baseInterval);  // Min 5 seconds
                }

                // Update level and skill status
                this.level = level;
                this.hasSkill = level >= (typeConfig.skillLevel || 3);
            }

            // Get total experience points
            getTotalExp() {
                return this.experience.totalDeliveries +
                       this.experience.dangerDeliveries * 2 +  // Danger zone worth double
                       this.experience.predatorEscapes * 3 +   // Escapes worth triple
                       Math.floor(this.experience.foodDiscovered * 0.5);  // Bonus for discovery
            }

            // Check if ant just leveled up and handle it
            checkLevelUp() {
                const newLevel = this.getLevel();
                if (newLevel > this.level) {
                    this.recalculateStats();
                    // Could add level-up visual effect here
                    return true;
                }
                return false;
            }

            // Record a successful delivery
            recordDelivery(value, fromDangerZone) {
                this.experience.totalDeliveries++;
                this.experience.totalValue += value;
                if (fromDangerZone) {
                    this.experience.dangerDeliveries++;
                }

                // Check for level up
                this.checkLevelUp();
            }

            // Record food discovery (when ant first finds a food source)
            recordFoodDiscovery() {
                this.experience.foodDiscovered++;
                this.checkLevelUp();
            }

            // Record predator encounter
            recordPredatorEncounter(escaped) {
                this.experience.predatorEncounters++;
                if (escaped) {
                    this.experience.predatorEscapes++;
                    this.checkLevelUp();
                }
            }

            // Take damage from a predator attack
            takeDamage(attackPower) {
                // Calculate damage: attacker's ATK minus defender's DEF (min 1 damage)
                const damage = Math.max(1, attackPower - this.def);
                this.currentHp -= damage;

                // Return true if ant survives
                return this.currentHp > 0;
            }

            // Check if ant is alive
            isAlive() {
                return this.currentHp > 0;
            }

            // Get HP percentage for UI
            getHpPercent() {
                return (this.currentHp / this.maxHp) * 100;
            }

            // Get effective ATK (including Berserker skill)
            getEffectiveAtk() {
                let atk = this.atk;

                // Berserker skill: doubles ATK when colony has recent deaths
                if (this.hasSkill && this.type === 'soldier' && CONFIG.recentDeaths > 0) {
                    atk *= 2;
                }

                return atk;
            }

            // Combat with predator - uses Pokemon-style stats
            attemptFight(predator) {
                // All ants can now take damage, but only soldiers fight back effectively
                const antAtk = this.getEffectiveAtk();

                // Deal damage to predator if we have attack power
                if (antAtk > 0 && predator.currentHp !== undefined) {
                    const damageDealt = Math.max(1, antAtk - (predator.def || 0));
                    predator.currentHp -= damageDealt;

                    // Check if predator is killed
                    if (predator.currentHp <= 0) {
                        predator.stun(300); // Long stun before respawn
                        return 'win';
                    }
                }

                // Soldier has chance to stun even if not killing
                if (this.type === 'soldier' && Math.random() < 0.3) {
                    predator.stun(120); // 2 second stun
                    return 'win';
                }

                return 'fought';  // Combat happened but no decisive result
            }

            // Check if this ant should follow pheromones (Worker skill affects this)
            shouldFollowPheromone() {
                // Efficient Forager skill: 95% accuracy instead of 70%
                if (this.hasSkill && this.type === 'worker') {
                    return Math.random() < 0.95;
                }
                return Math.random() < 0.7;
            }

            // Get carry speed (Carrier skill affects this)
            getCarrySpeed() {
                // Beast of Burden skill: no speed penalty
                if (this.hasSkill && this.type === 'carrier') {
                    return this.speed;
                }
                return this.speed * 0.6 * this.carrySpeedBonus;
            }

            // Check if within Queen's Royal Decree aura
            isInRoyalAura() {
                for (const ant of ants) {
                    if (ant.type === 'queen' && ant.hasSkill && ant !== this) {
                        const dist = Math.hypot(this.x - ant.x, this.y - ant.y);
                        if (dist < 120) {  // Royal aura radius
                            return true;
                        }
                    }
                }
                return false;
            }

            // Get effective speed (including Royal Decree bonus and upgrades)
            getEffectiveSpeed() {
                let speed = this.speed * upgradeMultipliers.antSpeed;
                if (this.isInRoyalAura()) {
                    speed *= 1.25;  // 25% boost from queen
                }
                return speed;
            }

            update() {
                this.legPhase += 0.25;

                // Record position for trail effect (every frame)
                this.positionHistory.push({ x: this.x, y: this.y });
                if (this.positionHistory.length > 20) {
                    this.positionHistory.shift();
                }

                // Flee from nearby predators if in danger zone and not carrying
                // Soldiers don't flee - they fight!
                if (this.type !== 'soldier' && isInDangerZone(this.x, this.y) && this.state !== 'carrying') {
                    let nearestPredator = null;
                    let nearestDist = 60;

                    // Check all predators
                    for (const p of getAllPredators()) {
                        if (p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestPredator = p;
                        }
                    }

                    if (nearestPredator) {
                        this.panicTimer = 30;
                        const fleeAngle = Math.atan2(this.y - nearestPredator.y, this.x - nearestPredator.x);
                        this.angle = fleeAngle + (Math.random() - 0.5) * 0.5;
                        this.x += Math.cos(this.angle) * this.speed * 2.5;
                        this.y += Math.sin(this.angle) * this.speed * 2.5;
                        this.bounceOffWalls();
                        return;
                    }
                }

                // Soldiers actively engage predators when nearby
                if (this.type === 'soldier' && this.state !== 'hunting' && this.state !== 'escorting') {
                    for (const p of getAllPredators()) {
                        if (p.state === 'stunned') continue;
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < 40) {
                            this.targetPredator = p;
                            this.state = 'hunting';
                            break;
                        }
                    }
                }

                if (this.panicTimer > 0) this.panicTimer--;

                // Queen behavior - spawn workers over time
                if (this.type === 'queen') {
                    this.spawnTimer++;
                    const typeConfig = CONFIG.antTypes.queen;
                    const effectiveInterval = typeConfig.spawnInterval * upgradeMultipliers.queenSpawnRate;
                    if (this.spawnTimer >= effectiveInterval && ants.length < CONFIG.maxAnts) {
                        this.spawnTimer = 0;
                        const angle = Math.random() * Math.PI * 2;
                        const spawnDist = 15;
                        const newAnt = new Ant(
                            this.x + Math.cos(angle) * spawnDist,
                            this.y + Math.sin(angle) * spawnDist,
                            'worker'
                        );
                        ants.push(newAnt);
                        addSpawnNotification('worker');
                    }
                    // Queen stays near nest
                    if (this.staysNearNest && this.distanceToNest() > getColonySize() * 1.5) {
                        const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                        this.angle = angleToNest;
                    }
                }

                switch (this.state) {
                    case 'exploring': this.explore(); break;
                    case 'returning': this.returnToNest(); break;
                    case 'carrying': this.carryFood(); break;
                    case 'hunting': this.huntPredator(); break;
                    case 'escorting': this.escortAnt(); break;
                }

                this.bounceOffWalls();
            }

            // Soldiers: Find a predator to hunt or ant to escort
            findSoldierTask() {
                // Priority 1: Hunt predators in danger zones
                let nearestPredator = null;
                let nearestPredatorDist = 200;

                for (const p of getAllPredators()) {
                    if (p.state === 'stunned') continue;
                    const dist = Math.hypot(p.x - this.x, p.y - this.y);
                    if (dist < nearestPredatorDist) {
                        nearestPredatorDist = dist;
                        nearestPredator = p;
                    }
                }

                if (nearestPredator && nearestPredatorDist < 150) {
                    this.targetPredator = nearestPredator;
                    this.state = 'hunting';
                    return true;
                }

                // Priority 2: Escort non-soldier ants heading into danger zones
                let nearestVulnerable = null;
                let nearestVulnerableDist = 80;

                for (const ant of ants) {
                    if (ant === this || ant.type === 'soldier') continue;
                    if (ant.state !== 'carrying') continue; // Only escort carriers

                    // Check if ant is near or heading toward danger
                    if (isInDangerZone(ant.x, ant.y)) {
                        const dist = Math.hypot(ant.x - this.x, ant.y - this.y);
                        if (dist < nearestVulnerableDist) {
                            nearestVulnerableDist = dist;
                            nearestVulnerable = ant;
                        }
                    }
                }

                if (nearestVulnerable) {
                    this.escortTarget = nearestVulnerable;
                    this.state = 'escorting';
                    return true;
                }

                return false;
            }

            // Soldier behavior: Hunt predators
            huntPredator() {
                const predator = this.targetPredator;

                // Check if predator is still valid target
                if (!predator || predator.state === 'stunned') {
                    this.targetPredator = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(predator.x - this.x, predator.y - this.y);

                // If close enough, attempt to stun
                if (dist < 15) {
                    const result = this.attemptFight(predator);
                    if (result === 'win') {
                        // Soldier survived and stunned predator
                        this.targetPredator = null;
                        this.state = 'exploring';
                    } else if (result === 'mutual') {
                        // Both affected - soldier dies
                        const idx = ants.indexOf(this);
                        if (idx !== -1) ants.splice(idx, 1);
                    } else {
                        // Soldier lost - dies
                        const idx = ants.indexOf(this);
                        if (idx !== -1) ants.splice(idx, 1);
                    }
                    return;
                }

                // Move toward predator
                const angleToTarget = Math.atan2(predator.y - this.y, predator.x - this.x);
                this.angle = angleToTarget + (Math.random() - 0.5) * 0.2;
                this.move();

                // Give up if too far
                if (dist > 250) {
                    this.targetPredator = null;
                    this.state = 'exploring';
                }
            }

            // Soldier behavior: Escort vulnerable ants
            escortAnt() {
                const target = this.escortTarget;

                // Check if target is still valid
                if (!target || !ants.includes(target) || target.state !== 'carrying') {
                    this.escortTarget = null;
                    this.state = 'exploring';
                    return;
                }

                const dist = Math.hypot(target.x - this.x, target.y - this.y);

                // Stay close to the target
                if (dist > 25) {
                    const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x);
                    this.angle = angleToTarget + (Math.random() - 0.5) * 0.3;
                    this.move();
                } else {
                    // Circle around the target protectively
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x) + Math.PI / 2;
                    this.x += Math.cos(this.angle) * this.speed * 0.5;
                    this.y += Math.sin(this.angle) * this.speed * 0.5;
                }

                // If predator gets close, intercept it
                for (const p of getAllPredators()) {
                    if (p.state === 'stunned') continue;
                    const predatorDist = Math.hypot(p.x - target.x, p.y - target.y);
                    if (predatorDist < 50) {
                        this.targetPredator = p;
                        this.escortTarget = null;
                        this.state = 'hunting';
                        return;
                    }
                }

                // Stop escorting if target leaves danger zone
                if (!isInDangerZone(target.x, target.y)) {
                    this.escortTarget = null;
                    this.state = 'exploring';
                }
            }

            explore() {
                // If ant has spotted food, head toward it
                if (this.targetFood && !this.targetFood.isEmpty()) {
                    const dist = Math.hypot(this.targetFood.x - this.x, this.targetFood.y - this.y);
                    // Keep heading toward food with slight wobble
                    this.angle = Math.atan2(this.targetFood.y - this.y, this.targetFood.x - this.x);
                    this.angle += (Math.random() - 0.5) * 0.2;  // Small wobble
                } else {
                    // Clear invalid target
                    this.targetFood = null;

                    // Soldiers look for tasks instead of food
                    if (this.type === 'soldier') {
                        // Check for tasks more frequently
                        if (Math.random() < 0.1) {
                            if (this.findSoldierTask()) return;
                        }

                        // Soldiers patrol toward danger zones - much more focused
                        let nearestPred = null;
                        let nearestDist = Infinity;
                        for (const p of getAllPredators()) {
                            if (p.state === 'stunned') continue;
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestPred = p;
                            }
                        }
                        if (nearestPred) {
                            const angleToTarget = Math.atan2(nearestPred.y - this.y, nearestPred.x - this.x);
                            // Strong bias toward predator (80% follow, 20% wander)
                            if (Math.random() < 0.8) {
                                this.angle = angleToTarget + (Math.random() - 0.5) * 0.3;
                            } else {
                                this.angle += (Math.random() - 0.5) * this.wanderStrength;
                            }
                        } else {
                            this.angle += (Math.random() - 0.5) * this.wanderStrength;
                        }
                    } else if (this.isScout || !this.shouldFollowPheromone()) {
                        // Scouts wander, workers sometimes do too (unless they have Efficient Forager)
                        this.angle += (Math.random() - 0.5) * this.wanderStrength + this.wanderBias;
                    } else {
                        // Follow pheromone trails
                        const turn = samplePheromoneDirection(this.x, this.y, this.angle, 'food');
                        this.angle += turn + (Math.random() - 0.5) * CONFIG.wanderStrength * 0.4;
                    }
                }

                this.depositTimer++;
                if (this.depositTimer > 6) {
                    const distToNest = this.distanceToNest();
                    depositPheromone(this.x, this.y, 'home', CONFIG.pheromoneDeposit * this.pheromoneStrength * Math.max(0.15, 1 - distToNest / 350));
                    this.depositTimer = 0;
                }

                this.move();

                // Soldiers still pick up food if they find it, but less eagerly
                if (this.type !== 'soldier' || Math.random() < 0.3) {
                    this.checkForFood();
                }

                if (Math.random() < 0.0004) {
                    this.state = 'returning';
                    this.foundFoodRecently = false;
                }
            }

            checkForFood() {
                // Detection radius is how far the ant can SEE food
                // Detection trait gives up to 20% bonus, plus upgrade bonus
                const detectionBonus = 1 + (this.traitRolls.detection - 0.5) * 0.4;  // 0.8x to 1.2x
                const effectiveDetectionRange = this.foodDetectRadius * detectionBonus * upgradeMultipliers.detectionRadius;

                // Pickup radius is small - ant must actually reach the food
                const pickupRadius = 8;

                for (const food of foodItems) {
                    const dist = Math.hypot(this.x - food.x, this.y - food.y);
                    const foodRadius = food.getRadius();

                    // Close enough to pick up?
                    if (dist < pickupRadius + foodRadius) {
                        if (food.canTakeUnit()) {
                            this.pickUpFoodUnit(food);
                        } else {
                            // Food is depleted, leave pheromone and mark as found
                            depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 6);
                            this.state = 'returning';
                            this.foundFoodRecently = true;
                        }
                        break;
                    }
                    // Can detect food from far away? Move toward it!
                    else if (dist < effectiveDetectionRange + foodRadius && !this.targetFood) {
                        // Spotted food - head toward it
                        this.targetFood = food;
                        this.angle = Math.atan2(food.y - this.y, food.x - this.x);
                        // Leave a food pheromone to help others
                        depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 2);
                        break;
                    }
                }
            }

            pickUpFoodUnit(food) {
                // Capacity determines how many units ant can carry at once (1 = 1 unit, 2 = 2 units, etc)
                const capacity = Math.max(1, Math.floor(this.carryCapacity));
                const unitsToTake = Math.min(capacity, Math.floor(food.size));

                // Take units from the food
                let unitsTaken = 0;
                for (let i = 0; i < unitsToTake; i++) {
                    if (food.takeUnit() > 0) {
                        unitsTaken++;
                    } else {
                        break;
                    }
                }

                if (unitsTaken > 0) {
                    // Record food discovery for XP
                    this.recordFoodDiscovery();

                    // Scout Trailblazer skill: create beacon when finding food
                    if (this.hasSkill && this.type === 'scout') {
                        addTrailblazerBeacon(food.x, food.y, food);
                    }

                    this.carriedFoodPiece = new CarriedFoodPiece(food.type, food.id, food.inDangerZone);
                    this.carriedFoodPiece.units = unitsTaken;  // Track how many units carried
                    this.carriedFoodValue = food.getValue() * unitsTaken;  // Value multiplied by units
                    this.targetFood = food;
                    this.state = 'carrying';
                    this.angle = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);

                    // Remove food if empty
                    if (food.isEmpty()) {
                        const idx = foodItems.indexOf(food);
                        if (idx !== -1) foodItems.splice(idx, 1);
                    }
                }
            }

            carryFood() {
                // Ant is carrying a food piece back to nest
                if (!this.carriedFoodPiece) {
                    this.state = 'exploring';
                    return;
                }

                // Move toward nest
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const turnRate = 0.1;
                const angleDiff = this.angleDiff(angleToNest, this.angle);
                this.angle += angleDiff * turnRate;

                // Carriers move slower when carrying, adjusted by carrySpeedBonus (and skills)
                const carrySpeed = this.getCarrySpeed();
                this.x += Math.cos(this.angle) * carrySpeed;
                this.y += Math.sin(this.angle) * carrySpeed;

                // Deposit pheromones
                this.depositTimer++;
                if (this.depositTimer > 4) {
                    depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 3);
                    this.depositTimer = 0;
                }

                // Check if reached nest
                const distToNest = this.distanceToNest();
                if (distToNest < getColonySize()) {
                    // Count units delivered for XP (each unit = 1 delivery)
                    const unitsDelivered = this.carriedFoodPiece.units || 1;

                    // Record experience - each unit counts as a delivery
                    for (let i = 0; i < unitsDelivered; i++) {
                        this.recordDelivery(this.carriedFoodValue / unitsDelivered, this.carriedFoodPiece.fromDangerZone);
                    }

                    // Gold bonus: innate trait that gives 0-100% extra gold per delivery
                    const goldMultiplier = 1 + this.traitRolls.goldBonus;  // 1.0x to 2.0x
                    // Apply upgrade multipliers for food value and coin bonus
                    let coinValue = Math.ceil(this.carriedFoodValue * goldMultiplier * upgradeMultipliers.foodValue);
                    coinValue += upgradeMultipliers.coinBonus;  // Flat bonus from upgrades

                    // Earn coins (no ant spawning - that's separate now)
                    earnCoins(coinValue);
                    foodCollected += Math.ceil(unitsDelivered * upgradeMultipliers.foodValue);

                    // Reset state
                    this.carriedFoodPiece = null;
                    this.carriedFoodValue = 0;
                    this.targetFood = null;
                    this.state = 'exploring';
                    this.foundFoodRecently = true;
                    this.angle += Math.PI + (Math.random() - 0.5) * 1.2;
                }
            }

            returnToNest() {
                const angleToNest = Math.atan2(CONFIG.nestY - this.y, CONFIG.nestX - this.x);
                const pheromoneTurn = samplePheromoneDirection(this.x, this.y, this.angle, 'home');
                const directTurn = this.angleDiff(angleToNest, this.angle) * 0.12;

                this.angle += directTurn + pheromoneTurn * 0.4 + (Math.random() - 0.5) * 0.08;

                if (this.foundFoodRecently) {
                    this.depositTimer++;
                    if (this.depositTimer > 4) {
                        depositPheromone(this.x, this.y, 'food', CONFIG.pheromoneDeposit * this.pheromoneStrength * 2.5);
                        this.depositTimer = 0;
                    }
                }

                this.move();

                if (this.distanceToNest() < getColonySize()) {
                    this.state = 'exploring';
                    this.foundFoodRecently = false;
                    this.targetFood = null;  // Clear so ant can spot new food
                    this.angle += Math.PI + (Math.random() - 0.5) * 1.2;
                }
            }

            move() {
                const effectiveSpeed = this.getEffectiveSpeed();
                const dx = Math.cos(this.angle) * effectiveSpeed;
                const dy = Math.sin(this.angle) * effectiveSpeed;
                this.x += dx;
                this.y += dy;

                // Track distance traveled for stats
                this.experience.distanceTraveled += Math.abs(dx) + Math.abs(dy);
            }

            bounceOffWalls() {
                const margin = 15;
                if (this.x < margin) { this.x = margin; this.angle = Math.PI - this.angle; }
                if (this.x > width - margin) { this.x = width - margin; this.angle = Math.PI - this.angle; }
                if (this.y < margin) { this.y = margin; this.angle = -this.angle; }
                if (this.y > height - margin) { this.y = height - margin; this.angle = -this.angle; }
            }

            distanceToNest() {
                return Math.hypot(this.x - CONFIG.nestX, this.y - CONFIG.nestY);
            }

            angleDiff(target, current) {
                let diff = target - current;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                return diff;
            }

            draw() {
                const antLevel = this.getLevel();

                // Draw sci-fi energy trail for level 2+ only
                if (antLevel >= 2 && this.positionHistory.length > 3) {
                    // Bright neon color palette
                    const trailThemes = {
                        2: { core: [0, 255, 200], glow: [0, 255, 255] },    // Cyan
                        3: { core: [100, 180, 255], glow: [150, 220, 255] }, // Electric blue
                        4: { core: [200, 100, 255], glow: [230, 150, 255] }, // Violet
                        5: { core: [255, 220, 100], glow: [255, 255, 180] }  // Golden
                    };

                    const theme = trailThemes[antLevel];
                    const time = Date.now() * 0.005;
                    const len = this.positionHistory.length;

                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Outer glow layer - BRIGHT
                    for (let i = 1; i < len; i++) {
                        const progress = i / len;
                        const glowAlpha = progress * (0.15 + antLevel * 0.08);
                        const glowWidth = progress * (4 + antLevel * 2);

                        ctx.strokeStyle = `rgba(${theme.glow[0]}, ${theme.glow[1]}, ${theme.glow[2]}, ${glowAlpha})`;
                        ctx.lineWidth = glowWidth;
                        ctx.beginPath();
                        ctx.moveTo(this.positionHistory[i - 1].x, this.positionHistory[i - 1].y);
                        ctx.lineTo(this.positionHistory[i].x, this.positionHistory[i].y);
                        ctx.stroke();
                    }

                    // Core energy line - bright white/color center
                    for (let i = 1; i < len; i++) {
                        const progress = i / len;
                        const coreAlpha = progress * (0.5 + antLevel * 0.1);
                        const coreWidth = progress * (1.5 + antLevel * 0.5);

                        ctx.strokeStyle = `rgba(${theme.core[0]}, ${theme.core[1]}, ${theme.core[2]}, ${coreAlpha})`;
                        ctx.lineWidth = coreWidth;
                        ctx.beginPath();
                        ctx.moveTo(this.positionHistory[i - 1].x, this.positionHistory[i - 1].y);
                        ctx.lineTo(this.positionHistory[i].x, this.positionHistory[i].y);
                        ctx.stroke();
                    }

                    // Energy nodes for level 3+
                    if (antLevel >= 3) {
                        const nodeInterval = 4;
                        for (let i = nodeInterval; i < len; i += nodeInterval) {
                            const pos = this.positionHistory[i];
                            const progress = i / len;
                            const pulse = 0.7 + Math.sin(time + i) * 0.3;
                            const nodeSize = (2 + antLevel) * progress * pulse;

                            // Glowing node
                            ctx.fillStyle = `rgba(${theme.glow[0]}, ${theme.glow[1]}, ${theme.glow[2]}, ${0.6 * progress})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, nodeSize, 0, Math.PI * 2);
                            ctx.fill();

                            // White hot center
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * progress})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, nodeSize * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Size increases with level (35% per level above 1) - level 5 is 140% bigger!
                const levelSizeBonus = 1 + (antLevel - 1) * 0.35;
                const size = CONFIG.antSize * this.sizeMultiplier * levelSizeBonus;
                const legWave = Math.sin(this.legPhase) * 0.35;

                // Type-based colors - use accent for highlights
                const baseColor = this.colorConfig || CONFIG.antTypes.worker.color;
                const accent = this.accentColor || baseColor;
                const r = baseColor.r;
                const g = baseColor.g;
                const b = baseColor.b;
                const bodyColor = `rgb(${r}, ${g}, ${b})`;
                const darkColor = `rgb(${Math.max(0, r - 20)}, ${Math.max(0, g - 15)}, ${Math.max(0, b - 10)})`;
                const accentColorStr = `rgb(${accent.r}, ${accent.g}, ${accent.b})`;
                const legColor = `rgb(${Math.min(255, r + 30)}, ${Math.min(255, g + 25)}, ${Math.min(255, b + 20)})`;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 2, size * 1.2, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs - use accent color for visibility
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.12;
                ctx.lineCap = 'round';

                const legPositions = [-0.15, 0.05, 0.25];
                for (let i = 0; i < 3; i++) {
                    const attachX = legPositions[i] * size;
                    const phase = (i === 1) ? -legWave : legWave;

                    ctx.beginPath();
                    ctx.moveTo(attachX, -size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, -size * 0.45 - phase * size * 0.15, attachX - size * 0.1, -size * 0.7 - phase * size * 0.1);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(attachX, size * 0.12);
                    ctx.quadraticCurveTo(attachX - size * 0.25, size * 0.45 + phase * size * 0.15, attachX - size * 0.1, size * 0.7 + phase * size * 0.1);
                    ctx.stroke();
                }

                // Gaster (abdomen) - main body color
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.5, size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Gaster stripe/marking for visibility
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(-size * 0.55, 0, size * 0.35, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = darkColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.7, 0, size * 0.15, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Petiole
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(-size * 0.1, 0, size * 0.1, size * 0.07, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax - with accent highlight
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.28, size * 0.18, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax accent stripe
                ctx.fillStyle = accentColorStr;
                ctx.beginPath();
                ctx.ellipse(size * 0.2, 0, size * 0.18, size * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(size * 0.55, 0, size * 0.22, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes - white with black pupil for visibility
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(size * 0.62, -size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.arc(size * 0.62, size * 0.1, size * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(size * 0.64, -size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.arc(size * 0.64, size * 0.1, size * 0.03, 0, Math.PI * 2);
                ctx.fill();

                // Antennae - use accent color
                ctx.strokeStyle = accentColorStr;
                ctx.lineWidth = size * 0.07;
                const antennaWave = Math.sin(this.legPhase * 0.6) * 0.12;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, -size * 0.12);
                ctx.lineTo(size * 0.88, -size * 0.25);
                ctx.lineTo(size * 1.05, -size * 0.2 + antennaWave * size);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(size * 0.7, size * 0.12);
                ctx.lineTo(size * 0.88, size * 0.25);
                ctx.lineTo(size * 1.05, size * 0.2 - antennaWave * size);
                ctx.stroke();

                // Draw carried food piece with zone-based glow
                if (this.carriedFoodPiece && this.state === 'carrying') {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    const pieceSize = 10;
                    const pieceX = size * 0.8;
                    const pieceY = -size * 0.3;

                    // Zone-based glow
                    const glowGrad = ctx.createRadialGradient(pieceX, pieceY, 0, pieceX, pieceY, pieceSize * 0.8);
                    if (this.carriedFoodPiece.fromDangerZone) {
                        glowGrad.addColorStop(0, 'rgba(255, 200, 80, 0.6)');
                        glowGrad.addColorStop(1, 'transparent');
                    } else {
                        glowGrad.addColorStop(0, 'rgba(120, 255, 150, 0.5)');
                        glowGrad.addColorStop(1, 'transparent');
                    }
                    ctx.fillStyle = glowGrad;
                    ctx.beginPath();
                    ctx.arc(pieceX, pieceY, pieceSize * 0.8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = `${pieceSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.carriedFoodPiece.emoji, pieceX, pieceY);
                    ctx.restore();
                }

                // Queen crown indicator only
                if (this.type === 'queen') {
                    ctx.save();
                    ctx.rotate(-this.angle);
                    ctx.font = `${size * 0.7}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëë', 0, -size * 0.7);
                    ctx.restore();
                }

                // Selection indicator - large triangle above selected ant
                if (selectedAnt === this) {
                    ctx.save();
                    ctx.rotate(-this.angle);

                    // Detection radius visualization (shows exact current range)
                    const detectionBonus = 1 + (this.traitRolls.detection - 0.5) * 0.4;
                    const detectionRadius = this.foodDetectRadius * detectionBonus;

                    // Detection ring - dashed outline
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.4)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, detectionRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Subtle inner fill
                    const detectGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, detectionRadius);
                    detectGrad.addColorStop(0, 'rgba(0, 200, 255, 0.03)');
                    detectGrad.addColorStop(0.8, 'rgba(0, 200, 255, 0.06)');
                    detectGrad.addColorStop(1, 'rgba(0, 200, 255, 0)');
                    ctx.setLineDash([]);
                    ctx.fillStyle = detectGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, detectionRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Animated bounce
                    const bounce = Math.sin(Date.now() / 150) * 4;
                    const triangleY = -size * 2.2 - bounce;
                    const triSize = size * 1.2;  // Much bigger triangle

                    // Strong glow effect
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 20;

                    // Outer glow ring
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();

                    // Draw main triangle (pointing down)
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.7);
                    ctx.lineTo(-triSize * 0.5, triangleY);
                    ctx.lineTo(triSize * 0.5, triangleY);
                    ctx.closePath();
                    ctx.fill();

                    // Inner lighter triangle
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#80ffbb';
                    ctx.beginPath();
                    ctx.moveTo(0, triangleY + triSize * 0.5);
                    ctx.lineTo(-triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.lineTo(triSize * 0.28, triangleY + triSize * 0.12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }

                ctx.restore();
            }
        }

        function initAnts() {
            ants = [];
            for (let i = 0; i < CONFIG.initialAnts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * CONFIG.nestRadius * 0.7;
                // Start with all workers
                ants.push(new Ant(CONFIG.nestX + Math.cos(angle) * dist, CONFIG.nestY + Math.sin(angle) * dist, 'worker'));
            }
        }

        // ===========================================
        // RENDERING
        // ===========================================

        function drawGround() {
            // Brighter, greener forest floor
            const gradient = ctx.createRadialGradient(width * 0.4, height * 0.35, 0, width * 0.5, height * 0.5, Math.max(width, height) * 0.8);
            gradient.addColorStop(0, '#3a4a30');
            gradient.addColorStop(0.3, '#2e3d28');
            gradient.addColorStop(0.6, '#243320');
            gradient.addColorStop(1, '#1a2818');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Warm light beam
            const beamGradient = ctx.createRadialGradient(width * 0.3, height * 0.2, 0, width * 0.3, height * 0.2, height * 0.8);
            beamGradient.addColorStop(0, 'rgba(255, 250, 220, 0.08)');
            beamGradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.04)');
            beamGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = beamGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw forest elements
            for (const el of forestElements) drawForestElement(el);

            // Draw grass
            drawGrass();

            // Subtle vignette
            const vignetteGradient = ctx.createRadialGradient(width / 2, height / 2, Math.min(width, height) * 0.35, width / 2, height / 2, Math.max(width, height) * 0.85);
            vignetteGradient.addColorStop(0, 'transparent');
            vignetteGradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.1)');
            vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            ctx.fillStyle = vignetteGradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawPheromones() {
            const cellSize = CONFIG.pheromoneGridSize;

            // Use soft blending for smooth trails
            ctx.globalCompositeOperation = 'lighter';

            for (let row = 0; row < pheromoneGrid.rows; row++) {
                for (let col = 0; col < pheromoneGrid.cols; col++) {
                    const idx = row * pheromoneGrid.cols + col;
                    const foodPh = pheromoneGrid.food[idx];

                    if (foodPh > 0.5) {
                        const x = col * cellSize + cellSize / 2;
                        const y = row * cellSize + cellSize / 2;

                        // Normalize strength (0-1 range, where 1 = very strong trail)
                        const strength = Math.min(1, foodPh / 15);

                        // Smaller base size, blends together into continuous trail
                        const size = cellSize * (0.5 + strength * 0.3);

                        // Alpha scales with strength but kept low for smooth blending
                        const alpha = 0.08 + strength * 0.25;

                        // Color shifts from pale green to bright cyan-green for strong trails
                        const r = Math.round(50 - strength * 30);
                        const g = Math.round(150 + strength * 105);
                        const b = Math.round(80 + strength * 120);

                        // Soft radial gradient for each point - creates smooth blending
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`);
                        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';
        }

        function getColonySize() {
            // Colony grows slightly based on ant population
            return CONFIG.nestRadius * Math.min(2.5, 1 + ants.length / 100);
        }

        function drawNest() {
            const currentRadius = getColonySize();
            const cx = CONFIG.nestX;
            const cy = CONFIG.nestY;
            const antCount = ants.length;

            // Excavated dirt
            ctx.fillStyle = '#4a4030';
            const dirtPiles = 20 + Math.min(antCount, 100) * 0.3;
            for (let i = 0; i < dirtPiles; i++) {
                const angle = (i / dirtPiles) * Math.PI * 2 + Math.sin(i * 1.7) * 0.4;
                const dist = currentRadius * (1.1 + Math.sin(i * 2.9) * 0.2);
                const blobSize = currentRadius * (0.06 + Math.sin(i * 4.1) * 0.03);
                ctx.beginPath();
                ctx.ellipse(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.5, blobSize * 1.2, blobSize * 0.4, angle * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Shadow
            const shadowGrad = ctx.createRadialGradient(cx + currentRadius * 0.1, cy + currentRadius * 0.15, 0, cx, cy, currentRadius * 1.3);
            shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            shadowGrad.addColorStop(0.5, 'rgba(0, 0, 0, 0.12)');
            shadowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = shadowGrad;
            ctx.beginPath();
            ctx.ellipse(cx + currentRadius * 0.1, cy + currentRadius * 0.12, currentRadius * 1.2, currentRadius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main mound
            const baseGrad = ctx.createRadialGradient(cx - currentRadius * 0.2, cy - currentRadius * 0.25, 0, cx, cy, currentRadius * 1.2);
            baseGrad.addColorStop(0, '#6a5a45');
            baseGrad.addColorStop(0.3, '#5a4a38');
            baseGrad.addColorStop(0.6, '#4a3a2a');
            baseGrad.addColorStop(1, '#3a2a1f');

            ctx.fillStyle = baseGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius, currentRadius * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Texture
            const textureDots = 25 + Math.min(antCount, 100) * 0.4;
            for (let i = 0; i < textureDots; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * currentRadius * 0.9;
                const brightness = 40 + Math.random() * 25;
                ctx.fillStyle = `rgb(${brightness + 25}, ${brightness + 15}, ${brightness})`;
                ctx.beginPath();
                ctx.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist * 0.55, 1 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Entrance
            const entranceGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, currentRadius * 0.25);
            entranceGrad.addColorStop(0, '#080604');
            entranceGrad.addColorStop(0.6, '#100e0a');
            entranceGrad.addColorStop(1, '#2a2218');

            ctx.fillStyle = entranceGrad;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.22, currentRadius * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Entrance rim
            ctx.strokeStyle = '#6a5838';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(cx, cy, currentRadius * 0.25, currentRadius * 0.17, 0, Math.PI * 0.8, Math.PI * 0.2);
            ctx.stroke();
        }

        function drawFood() {
            for (const food of foodItems) food.draw();
        }

        function drawAnts() {
            for (const ant of ants) ant.draw();
        }

        function updateUI() {
            document.getElementById('coins').textContent = coins;
            document.getElementById('ant-count').textContent = ants.length;
            document.getElementById('food-collected').textContent = foodCollected;
            document.getElementById('survival-timer').textContent = formatTime(getElapsedSeconds());

            // Count ant types
            let workerCount = 0, soldierCount = 0, scoutCount = 0, carrierCount = 0, queenCount = 0;
            for (const ant of ants) {
                if (ant.type === 'worker') workerCount++;
                else if (ant.type === 'soldier') soldierCount++;
                else if (ant.type === 'scout') scoutCount++;
                else if (ant.type === 'carrier') carrierCount++;
                else if (ant.type === 'queen') queenCount++;
            }
            document.getElementById('worker-count').textContent = workerCount;
            document.getElementById('soldier-count').textContent = soldierCount;
            document.getElementById('scout-count').textContent = scoutCount;
            document.getElementById('carrier-count').textContent = carrierCount;
            document.getElementById('queen-count').textContent = queenCount;

            // Update food button states based on affordability
            document.querySelectorAll('.food-btn').forEach(btn => {
                const cost = parseInt(btn.dataset.cost);
                btn.classList.toggle('disabled', coins < cost);
            });

            // Update ant button states and costs
            document.querySelectorAll('.ant-btn').forEach(btn => {
                const antType = btn.dataset.ant;
                const cost = getAntSpawnCost(antType);
                btn.classList.toggle('disabled', coins < cost || ants.length >= CONFIG.maxAnts);
            });

            // Update displayed costs
            updateAntCosts();
        }

        // ===========================================
        // INPUT HANDLING
        // ===========================================

        let selectedFoodType = null;
        let isPlacing = false;
        let lastPlaceTime = 0;
        let showHint = true;
        let foodPlacementActive = false;
        let foodPlacementTimeout = null;

        // Drag selection state
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragCurrentX = 0;
        let dragCurrentY = 0;
        let dragThreshold = 10; // Minimum pixels to trigger drag vs click

        function activateFoodPlacement(foodType) {
            // Clear any existing timeout
            if (foodPlacementTimeout) {
                clearTimeout(foodPlacementTimeout);
            }

            selectedFoodType = foodType;
            foodPlacementActive = true;
            document.querySelectorAll('.food-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.querySelector(`.food-btn[data-food="${foodType}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            // Auto-deselect after 10 seconds if no food placed
            foodPlacementTimeout = setTimeout(() => {
                deactivateFoodPlacement();
            }, 10000);
        }

        function deactivateFoodPlacement() {
            if (foodPlacementTimeout) {
                clearTimeout(foodPlacementTimeout);
                foodPlacementTimeout = null;
            }
            foodPlacementActive = false;
            selectedFoodType = null;
            document.querySelectorAll('.food-btn').forEach(b => b.classList.remove('active'));
        }

        document.querySelectorAll('.food-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (btn.classList.contains('disabled')) return;
                const foodType = btn.dataset.food;
                // Toggle: if same food clicked again, deactivate
                if (selectedFoodType === foodType && foodPlacementActive) {
                    deactivateFoodPlacement();
                } else {
                    activateFoodPlacement(foodType);
                }
            });
            btn.addEventListener('mousedown', (e) => e.stopPropagation());
            btn.addEventListener('touchstart', (e) => e.stopPropagation());
        });

        document.querySelector('.food-selector').addEventListener('mousedown', (e) => e.stopPropagation());
        document.querySelector('.food-selector').addEventListener('touchstart', (e) => e.stopPropagation());

        // ===========================================
        // CHARACTER CARD SYSTEM
        // ===========================================

        let characterCardOpen = false;

        const ANT_CARD_DATA = {
            worker: {
                icon: 'üêú',
                title: 'Worker',
                subtitle: 'Colony Backbone',
                description: 'The reliable workhorse of the colony. Balanced stats make them versatile foragers that can survive a few hits.',
                stats: [
                    { name: 'HP', value: '10', class: '' },
                    { name: 'ATK', value: '2', class: '' },
                    { name: 'DEF', value: '2', class: '' },
                    { name: 'SPD', value: 'Normal', class: '' }
                ],
                traits: [
                    { text: 'Balanced', class: '' },
                    { text: 'Efficient Carrier', class: 'positive' },
                    { text: 'Common', class: '' }
                ]
            },
            soldier: {
                icon: '‚öîÔ∏è',
                title: 'Soldier',
                subtitle: 'Colony Defender',
                description: 'Fearless protectors with high HP and ATK. They deal real damage to predators and can take several hits before falling.',
                stats: [
                    { name: 'HP', value: '20', class: 'good' },
                    { name: 'ATK', value: '8', class: 'good' },
                    { name: 'DEF', value: '5', class: 'good' },
                    { name: 'SPD', value: 'Normal', class: '' }
                ],
                traits: [
                    { text: 'Brave', class: 'positive' },
                    { text: 'Damages Predators', class: 'special' },
                    { text: 'Combat Focus', class: 'positive' }
                ]
            },
            scout: {
                icon: 'üîç',
                title: 'Scout',
                subtitle: 'Swift Explorer',
                description: 'Fast but fragile! Scouts have low HP and DEF but excel at finding food and leaving strong pheromone trails.',
                stats: [
                    { name: 'HP', value: '6', class: 'bad' },
                    { name: 'ATK', value: '1', class: 'bad' },
                    { name: 'DEF', value: '1', class: 'bad' },
                    { name: 'SPD', value: 'Fast', class: 'good' }
                ],
                traits: [
                    { text: 'Swift', class: 'positive' },
                    { text: 'Trail Blazer', class: 'special' },
                    { text: 'Glass Cannon', class: 'negative' }
                ]
            },
            carrier: {
                icon: 'üí™',
                title: 'Carrier',
                subtitle: 'Heavy Lifter',
                description: 'Tank-like ants with the highest HP and DEF. Slow but incredibly durable, they can survive many predator attacks.',
                stats: [
                    { name: 'HP', value: '25', class: 'good' },
                    { name: 'ATK', value: '1', class: 'bad' },
                    { name: 'DEF', value: '6', class: 'good' },
                    { name: 'SPD', value: 'Slow', class: 'bad' }
                ],
                traits: [
                    { text: 'Tanky', class: 'positive' },
                    { text: 'Efficient Hauler', class: 'special' },
                    { text: 'Slow Walker', class: 'negative' }
                ]
            },
            queen: {
                icon: 'üëë',
                title: 'Queen',
                subtitle: 'Colony Mother',
                description: 'High HP makes the Queen a valuable asset to protect. She spawns workers and provides inspiration to nearby ants.',
                stats: [
                    { name: 'HP', value: '30', class: 'good' },
                    { name: 'ATK', value: '3', class: '' },
                    { name: 'DEF', value: '4', class: '' },
                    { name: 'SPD', value: 'Very Slow', class: 'bad' }
                ],
                traits: [
                    { text: 'Royal', class: 'special' },
                    { text: 'Spawns Workers', class: 'positive' },
                    { text: 'High Value Target', class: 'negative' }
                ]
            }
        };

        const PREDATOR_CARD_DATA = {
            spider: {
                icon: 'üï∑Ô∏è',
                title: 'Spider',
                subtitle: 'Ambush Predator',
                description: 'A deadly hunter with high ATK but lower HP. Soldiers can take it down with sustained damage!',
                stats: [
                    { name: 'HP', value: '50', class: 'neutral' },
                    { name: 'ATK', value: '15', class: 'bad' },
                    { name: 'DEF', value: '3', class: '' },
                    { name: 'SPD', value: 'Fast', class: 'bad' }
                ],
                traits: [
                    { text: 'High Damage', class: 'negative' },
                    { text: 'Can Be Killed', class: 'positive' },
                    { text: 'Respawns', class: 'negative' }
                ]
            },
            beetle: {
                icon: 'ü™≤',
                title: 'Beetle',
                subtitle: 'Armored Threat',
                description: 'A tanky predator with high HP and DEF. Hard to kill but deals less damage per hit.',
                stats: [
                    { name: 'HP', value: '80', class: 'bad' },
                    { name: 'ATK', value: '10', class: 'neutral' },
                    { name: 'DEF', value: '8', class: 'bad' },
                    { name: 'SPD', value: 'Slow', class: 'good' }
                ],
                traits: [
                    { text: 'Armored', class: 'negative' },
                    { text: 'High HP', class: 'negative' },
                    { text: 'Slow Patrol', class: 'positive' }
                ]
            }
        };

        // Helper to get stat class based on value comparison
        function getStatClass(value, baseline) {
            const ratio = value / baseline;
            if (ratio >= 1.35) return 'legendary';
            if (ratio >= 1.2) return 'exceptional';
            if (ratio >= 1.05) return 'good';
            if (ratio >= 0.95) return '';
            if (ratio >= 0.85) return 'weak';
            return 'poor';
        }

        // Generate dynamic card data for an individual ant
        function generateAntCardData(ant) {
            const baseData = ANT_CARD_DATA[ant.type];
            const typeConfig = CONFIG.antTypes[ant.type];
            const level = ant.getLevel();
            const xpTotal = ant.getTotalExp();
            const xpProgress = ant.getLevelProgress();
            const xpToNext = ant.getXpToNextLevel();

            // Calculate Pokemon-style stats
            const currentHp = ant.currentHp || ant.maxHp;
            const maxHp = ant.maxHp || typeConfig.hp;
            const atk = ant.atk || typeConfig.atk;
            const def = ant.def || typeConfig.def;
            const hpPercent = Math.round((currentHp / maxHp) * 100);

            // HP class based on current health
            const hpClass = hpPercent >= 75 ? 'good' : hpPercent >= 40 ? '' : hpPercent >= 20 ? 'weak' : 'bad';

            // Build dynamic stats with Pokemon-style format
            const stats = [
                {
                    name: 'HP',
                    value: `${currentHp}/${maxHp}`,
                    class: hpClass
                },
                {
                    name: 'ATK',
                    value: Math.round(atk),
                    class: atk >= 6 ? 'good' : atk >= 3 ? '' : 'weak'
                },
                {
                    name: 'DEF',
                    value: Math.round(def),
                    class: def >= 5 ? 'good' : def >= 3 ? '' : 'weak'
                },
                {
                    name: 'SPD',
                    value: ant.speed.toFixed(2),
                    class: ant.speed >= 0.6 ? 'good' : ant.speed >= 0.4 ? '' : 'weak'
                }
            ];

            // Build dynamic traits
            const traits = [];

            // Level indicator first
            const levelClass = level >= 5 ? 'legendary' : level >= 4 ? 'exceptional' : level >= 3 ? 'good' : level >= 2 ? '' : 'weak';
            traits.push({ text: `Level ${level}`, class: levelClass });

            // Skill indicator if unlocked
            if (ant.hasSkill) {
                traits.push({ text: typeConfig.skillName, class: 'skill' });
            }

            // Add experience-based traits
            if (ant.experience.dangerDeliveries >= 10) {
                traits.push({ text: 'Daredevil', class: 'exceptional' });
            } else if (ant.experience.dangerDeliveries >= 5) {
                traits.push({ text: 'Risk Taker', class: 'good' });
            }

            if (ant.experience.totalDeliveries >= 30) {
                traits.push({ text: 'Veteran', class: 'exceptional' });
            } else if (ant.experience.totalDeliveries >= 15) {
                traits.push({ text: 'Hardworker', class: 'positive' });
            }

            if (ant.experience.predatorEscapes >= 5) {
                traits.push({ text: 'Survivor', class: 'legendary' });
            } else if (ant.experience.predatorEscapes >= 2) {
                traits.push({ text: 'Escapist', class: 'good' });
            }

            if (ant.experience.foodDiscovered >= 10) {
                traits.push({ text: 'Explorer', class: 'good' });
            }

            // Add trait-based special labels
            if (ant.traitRolls.speed >= 0.95) {
                traits.push({ text: 'Swift', class: 'legendary' });
            }
            if (ant.traitRolls.detection >= 0.95) {
                traits.push({ text: 'Sharp Eyes', class: 'legendary' });
            }
            if (ant.traitRolls.goldBonus >= 0.95) {
                traits.push({ text: 'Midas', class: 'legendary' });
            }

            // Type indicator at end
            traits.push({ text: baseData.title, class: '' });

            // Build description with experience info and skill details
            let desc = baseData.description;

            // Add skill description if unlocked
            if (ant.hasSkill) {
                desc += ` [${typeConfig.skillName}]: ${typeConfig.skillDesc}`;
            } else if (level < 3) {
                desc += ` Unlocks "${typeConfig.skillName}" at Level 3.`;
            }

            return {
                icon: baseData.icon,
                title: ant.name,
                subtitle: `Lv.${level} ${baseData.title}`,
                description: desc,
                stats: stats,
                traits: traits,
                // Additional data for enhanced card
                level: level,
                xpTotal: xpTotal,
                xpProgress: xpProgress,
                xpToNext: xpToNext,
                hasSkill: ant.hasSkill,
                skillName: typeConfig.skillName,
                deliveries: ant.experience.totalDeliveries,
                dangerDeliveries: ant.experience.dangerDeliveries,
                discoveries: ant.experience.foodDiscovered
            };
        }

        // Track update interval for real-time character card updates
        let cardUpdateInterval = null;

        // Stat tooltips explaining what each stat does
        const STAT_TOOLTIPS = {
            'Speed': 'Movement speed while exploring. Improves with level. Queen aura grants +25% bonus.',
            'Capacity': 'Units of food carried per trip. Higher capacity = more food delivered at once.',
            'Detection': 'Radius for detecting food sources. Higher = spots food from further away.',
            'Combat': 'Fight chance / Survival rate. Shows attack success and survival after winning.',
            'Trail': 'Pheromone trail strength. Scouts leave stronger trails for others to follow.',
            'Spawn': 'Time between spawning new workers. Queens spawn faster at higher levels.',
            'Haul': 'Speed retained when carrying. Carriers with Beast of Burden move at 100%.',
            'Gold': 'Innate gold bonus applied to every delivery. Ranges from +0% to +100% extra coins.'
        };

        // Trait tooltips explaining what each trait means
        const TRAIT_TOOLTIPS = {
            // Level traits
            'Level 1': 'Novice ant, just starting out',
            'Level 2': 'Experienced ant with improved stats',
            'Level 3': 'Skilled ant - special ability unlocked!',
            'Level 4': 'Expert ant with significantly boosted stats',
            'Level 5': 'Master ant - maximum power achieved',
            // Experience-based traits
            'Daredevil': '10+ deliveries from danger zones - fearless!',
            'Risk Taker': '5+ deliveries from danger zones',
            'Veteran': '30+ total food deliveries',
            'Hardworker': '15+ total food deliveries',
            'Survivor': 'Escaped predators 5+ times - unkillable!',
            'Escapist': 'Escaped predators 2+ times',
            'Explorer': 'Discovered 10+ food sources',
            // Genetic traits
            'Swift': 'Born with exceptional speed (95%+ roll)',
            'Sharp Eyes': 'Born with exceptional detection (95%+ roll)',
            'Midas': 'Born with exceptional gold bonus (95%+ roll) - +95-100% gold per delivery!',
            // Skill traits (descriptions come from typeConfig)
            'Efficient Forager': 'Follows pheromone trails with 95% accuracy instead of 70%',
            'Berserker': '2x fight chance when colony suffered recent losses',
            'Trailblazer': 'Creates glowing beacon when discovering food',
            'Beast of Burden': 'No speed penalty when carrying food',
            'Royal Decree': 'Grants +25% speed to nearby ants',
            // Type traits
            'Worker': 'Standard colony worker - balanced stats',
            'Soldier': 'Combat specialist - fights predators',
            'Scout': 'Fast explorer - leaves strong trails',
            'Carrier': 'Heavy hauler - carries more food',
            'Queen': 'Colony leader - spawns new workers',
            // Ant type base traits
            'Balanced': 'Average stats across the board',
            'Efficient Carrier': 'Good at transporting food',
            'Common': 'Standard worker type',
            'Brave': 'Will fight instead of flee',
            'Patrols Danger': 'Actively seeks out predators',
            'May Die Fighting': 'Risk of death in combat',
            'Trail Blazer': 'Leaves extra strong pheromone trails',
            'Wide Explorer': 'Covers more ground while searching',
            'Strong': 'Can carry heavy loads',
            'Efficient Hauler': 'Minimal speed loss when loaded',
            'Slow Walker': 'Below average movement speed',
            'Royal': 'Leader of the colony',
            'Spawns Workers': 'Periodically creates new ants',
            'Stays Near Nest': 'Remains close to colony center',
            // Predator traits
            'Territorial': 'Guards a specific area',
            'Can Be Stunned': 'Soldiers can temporarily disable',
            'Deadly Strike': 'Instant kill on contact',
            'Fast': 'High movement speed',
            'Unpredictable': 'Erratic movement patterns',
            'Armored': 'Resistant to damage',
            'Slow Moving': 'Easy to outrun'
        };

        // Calculate bar percentage for a stat
        function getStatBarPercent(statName, value, antType) {
            const typeConfig = CONFIG.antTypes[antType] || CONFIG.antTypes.worker;
            const levelBonuses = typeConfig.levelBonuses || {};
            let baseline, max;

            switch(statName) {
                case 'Speed':
                    baseline = typeConfig.speed;
                    max = baseline + (levelBonuses.speed || 0) * 4 * 1.4;  // Max level 5 with legendary trait
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Capacity':
                    baseline = typeConfig.carryCapacity;
                    max = baseline + (levelBonuses.carryCapacity || 0) * 4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Detection':
                    baseline = typeConfig.foodDetectRadius;
                    max = baseline + (levelBonuses.foodDetectRadius || 0) * 4 * 1.4;
                    return Math.min(100, (parseFloat(value) / max) * 100);
                case 'Combat':
                    // Format is "fight/survive" - parse first number
                    const fightChance = parseInt(value.split('/')[0]) || 0;
                    return Math.min(100, fightChance * 1.25);  // Max ~80%
                case 'Trail':
                    return Math.min(100, parseFloat(value) / 2.3);  // Max ~230 at level 5
                case 'Spawn':
                    const secs = parseInt(value) || 15;
                    return Math.min(100, (20 - secs) * 10);  // Faster = higher bar
                case 'Haul':
                    return Math.min(100, parseFloat(value));  // Already %
                case 'Gold':
                    return parseFloat(value.replace(/[+%]/g, ''));  // Extract number from "+75%"
                default:
                    return 50;
            }
        }

        function showCharacterCard(data, ant = null) {
            selectedAnt = ant;
            const card = document.getElementById('character-card');

            // Update basic info
            document.getElementById('card-icon').textContent = data.icon;
            document.getElementById('card-title').textContent = data.title;
            document.getElementById('card-subtitle').textContent = data.subtitle;
            document.getElementById('card-description').textContent = data.description;

            // Update experience section (only for ants)
            const expSection = document.getElementById('card-exp-section');
            if (ant && ant.experience) {
                expSection.style.display = 'block';

                const level = ant.getLevel();
                const xpProgress = ant.getLevelProgress();
                const xpToNext = ant.getXpToNextLevel();
                const xpTotal = ant.getTotalExp();

                // Level progress bar
                const levelBarHtml = level >= 5
                    ? `<div class="level-bar-container">
                        <div class="level-bar max" style="width: 100%"></div>
                        <span class="level-text">MAX LEVEL</span>
                       </div>`
                    : `<div class="level-bar-container">
                        <div class="level-bar" style="width: ${xpProgress}%"></div>
                        <span class="level-text">${xpToNext} XP to Lv.${level + 1}</span>
                       </div>`;

                document.getElementById('exp-value').innerHTML = `
                    <div class="level-display">
                        <span class="level-number">Lv.${level}</span>
                        <span class="xp-total">${xpTotal} XP</span>
                    </div>
                    ${levelBarHtml}
                `;

                document.getElementById('exp-details').innerHTML = `
                    <div class="exp-detail">
                        <span class="count">${ant.experience.totalDeliveries}</span> deliveries
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.dangerDeliveries}</span> danger
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.foodDiscovered}</span> found
                    </div>
                    <div class="exp-detail">
                        <span class="count">${ant.experience.predatorEscapes}</span> escapes
                    </div>
                `;
                document.getElementById('card-id').textContent = `ID: #${String(ant.id).padStart(3, '0')}`;
            } else {
                expSection.style.display = 'none';
                document.getElementById('card-id').textContent = 'PREDATOR';
            }

            // Build stats HTML with bars, tooltips, and starting markers
            let statsHtml = '';
            for (const stat of data.stats) {
                const tooltip = STAT_TOOLTIPS[stat.name] || '';
                const barPercent = ant ? getStatBarPercent(stat.name, stat.value, ant.type) : 50;
                const barClass = stat.class || 'default';

                // Calculate starting stat marker position
                let startMarkerHtml = '';
                if (ant && stat.startValue !== undefined) {
                    const startPercent = getStatBarPercent(stat.name, stat.startValue, ant.type);
                    // Only show marker if there's been progress (current > start by more than 1%)
                    if (barPercent > startPercent + 1) {
                        startMarkerHtml = `<div class="stat-start-marker" style="left: ${startPercent}%"></div>`;
                    }
                }

                statsHtml += `<div class="stat-item">
                    <div class="stat-header">
                        <span class="stat-name">${stat.name}</span>
                        <span class="stat-val ${stat.class}">${stat.value}</span>
                    </div>
                    <div class="stat-bar-container">
                        ${startMarkerHtml}
                        <div class="stat-bar ${barClass}" style="width: ${barPercent}%"></div>
                    </div>
                    ${tooltip ? `<div class="stat-tooltip">${tooltip}</div>` : ''}
                </div>`;
            }
            document.getElementById('card-stats').innerHTML = statsHtml;

            // Build traits HTML with tooltips
            let traitsHtml = '';
            for (const trait of data.traits) {
                const tooltip = TRAIT_TOOLTIPS[trait.text] || '';
                const tooltipHtml = tooltip ? `<span class="trait-tooltip">${tooltip}</span>` : '';
                traitsHtml += `<span class="trait-tag ${trait.class}">${trait.text}${tooltipHtml}</span>`;
            }
            document.getElementById('card-traits').innerHTML = traitsHtml;

            card.classList.remove('hidden');
            characterCardOpen = true;

            // Start real-time updates for ants
            if (ant) {
                if (cardUpdateInterval) clearInterval(cardUpdateInterval);
                cardUpdateInterval = setInterval(() => {
                    if (selectedAnt && characterCardOpen) {
                        updateCardRealTime();
                    }
                }, 500);
            }
        }

        // Real-time update function for the card
        function updateCardRealTime() {
            if (!selectedAnt || !characterCardOpen) return;

            // Check if ant still exists
            if (!ants.includes(selectedAnt)) {
                closeCharacterCard();
                return;
            }

            const ant = selectedAnt;
            const level = ant.getLevel();
            const xpProgress = ant.getLevelProgress();
            const xpToNext = ant.getXpToNextLevel();
            const xpTotal = ant.getTotalExp();

            // Update level number and XP - use querySelector to update specific elements
            const levelNum = document.querySelector('.level-number');
            const xpTotalEl = document.querySelector('.xp-total');
            const levelBar = document.querySelector('.level-bar');
            const levelText = document.querySelector('.level-text');

            if (levelNum) levelNum.textContent = `Lv.${level}`;
            if (xpTotalEl) xpTotalEl.textContent = `${xpTotal} XP`;
            if (levelBar) {
                levelBar.style.width = level >= 5 ? '100%' : `${xpProgress}%`;
                if (level >= 5 && !levelBar.classList.contains('max')) {
                    levelBar.classList.add('max');
                }
            }
            if (levelText) {
                levelText.textContent = level >= 5 ? 'MAX LEVEL' : `${xpToNext} XP to Lv.${level + 1}`;
            }

            // Update exp detail counts only (not full rebuild)
            const expDetails = document.querySelectorAll('.exp-detail .count');
            if (expDetails.length >= 4) {
                expDetails[0].textContent = ant.experience.totalDeliveries;
                expDetails[1].textContent = ant.experience.dangerDeliveries;
                expDetails[2].textContent = ant.experience.foodDiscovered;
                expDetails[3].textContent = ant.experience.predatorEscapes;
            }

            // Update subtitle with current level
            const baseData = ANT_CARD_DATA[ant.type];
            document.getElementById('card-subtitle').textContent = `Lv.${level} ${baseData.title}`;

            // Update stat values and bars without rebuilding (preserves hover state)
            const cardData = generateAntCardData(ant);
            const statItems = document.querySelectorAll('.stat-item');

            cardData.stats.forEach((stat, index) => {
                if (statItems[index]) {
                    const valEl = statItems[index].querySelector('.stat-val');
                    const barEl = statItems[index].querySelector('.stat-bar');

                    if (valEl) {
                        valEl.textContent = stat.value;
                        valEl.className = `stat-val ${stat.class || ''}`;
                    }
                    if (barEl) {
                        const barPercent = getStatBarPercent(stat.name, stat.value, ant.type);
                        barEl.style.width = `${barPercent}%`;
                        barEl.className = `stat-bar ${stat.class || 'default'}`;
                    }
                }
            });

            // Only rebuild traits if skill status changed (rare)
            const currentTraitCount = document.querySelectorAll('.trait-tag').length;
            if (currentTraitCount !== cardData.traits.length) {
                let traitsHtml = '';
                for (const trait of cardData.traits) {
                    const tooltip = TRAIT_TOOLTIPS[trait.text] || '';
                    const tooltipHtml = tooltip ? `<span class="trait-tooltip">${tooltip}</span>` : '';
                    traitsHtml += `<span class="trait-tag ${trait.class}">${trait.text}${tooltipHtml}</span>`;
                }
                document.getElementById('card-traits').innerHTML = traitsHtml;
            }
        }

        function closeCharacterCard() {
            document.getElementById('character-card').classList.add('hidden');
            characterCardOpen = false;
            selectedAnt = null;
            if (cardUpdateInterval) {
                clearInterval(cardUpdateInterval);
                cardUpdateInterval = null;
            }
        }

        function findClickedEntity(x, y) {
            // Check predators first (larger click targets)
            for (const { predator, key } of getAllPredatorsWithKeys()) {
                const dist = Math.hypot(predator.x - x, predator.y - y);
                if (dist < 30) {
                    return { type: 'predator', key: key };
                }
            }

            // Check ants
            for (const ant of ants) {
                const dist = Math.hypot(ant.x - x, ant.y - y);
                if (dist < 15) {
                    return { type: 'ant', ant: ant };
                }
            }

            return null;
        }

        function findAntsInRect(x1, y1, x2, y2) {
            // Normalize rectangle coordinates
            const left = Math.min(x1, x2);
            const right = Math.max(x1, x2);
            const top = Math.min(y1, y2);
            const bottom = Math.max(y1, y2);

            const foundAnts = [];
            for (const ant of ants) {
                if (ant.x >= left && ant.x <= right && ant.y >= top && ant.y <= bottom) {
                    foundAnts.push(ant);
                }
            }
            return foundAnts;
        }

        function drawSelectionRect() {
            if (!isDragging) return;

            const left = Math.min(dragStartX, dragCurrentX);
            const top = Math.min(dragStartY, dragCurrentY);
            const right = Math.max(dragStartX, dragCurrentX);
            const bottom = Math.max(dragStartY, dragCurrentY);
            const w = right - left;
            const h = bottom - top;

            if (w < dragThreshold && h < dragThreshold) return;

            ctx.save();

            // Semi-transparent fill
            ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            ctx.fillRect(left, top, w, h);

            // Animated dashed border
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.lineDashOffset = -Date.now() / 50;
            ctx.strokeRect(left, top, w, h);

            // Corner accents
            const cornerSize = 12;
            ctx.setLineDash([]);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 8;

            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(left, top + cornerSize);
            ctx.lineTo(left, top);
            ctx.lineTo(left + cornerSize, top);
            ctx.stroke();

            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, top);
            ctx.lineTo(right, top);
            ctx.lineTo(right, top + cornerSize);
            ctx.stroke();

            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(left, bottom - cornerSize);
            ctx.lineTo(left, bottom);
            ctx.lineTo(left + cornerSize, bottom);
            ctx.stroke();

            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(right - cornerSize, bottom);
            ctx.lineTo(right, bottom);
            ctx.lineTo(right, bottom - cornerSize);
            ctx.stroke();

            // Show count of ants in selection
            const antsInRect = findAntsInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
            if (antsInRect.length > 0) {
                ctx.shadowBlur = 12;
                ctx.fillStyle = 'rgba(0, 20, 10, 0.9)';
                ctx.font = 'bold 14px "Orbitron", monospace';
                const text = `${antsInRect.length} ANT${antsInRect.length > 1 ? 'S' : ''}`;
                const metrics = ctx.measureText(text);
                const padding = 8;
                const boxWidth = metrics.width + padding * 2;
                const boxHeight = 24;
                const boxX = left + w / 2 - boxWidth / 2;
                const boxY = top - boxHeight - 8;

                // Background
                ctx.fillStyle = 'rgba(0, 20, 10, 0.95)';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 1;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                // Text
                ctx.fillStyle = '#00ff88';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, left + w / 2, boxY + boxHeight / 2);
            }

            ctx.restore();
        }

        function placeFood(x, y) {
            // Only place food if placement mode is active
            if (!foodPlacementActive || !selectedFoodType) return false;

            const now = Date.now();
            const minInterval = selectedFoodType === 'sugar' ? 100 : 200;
            if (now - lastPlaceTime < minInterval) return false;
            lastPlaceTime = now;

            // Check if position is within a food spot
            let inFoodSpot = false;
            for (const spot of foodSpots) {
                if (Math.hypot(x - spot.x, y - spot.y) < spot.radius) {
                    inFoodSpot = true;
                    break;
                }
            }
            if (!inFoodSpot) return false;

            if (addFood(x, y, selectedFoodType)) {
                showHint = false;
                // Reset the timeout when food is placed
                if (foodPlacementTimeout) {
                    clearTimeout(foodPlacementTimeout);
                    foodPlacementTimeout = setTimeout(() => {
                        deactivateFoodPlacement();
                    }, 10000);
                }
                return true;
            }
            return false;
        }

        let wasDragging = false; // Track if we just finished a drag

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // If card is open, close it and don't start drag
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            // If food placement is active, handle food placement mode
            if (foodPlacementActive) {
                isPlacing = true;
                placeFood(e.clientX, e.clientY);
                return;
            }

            // Start potential drag selection
            isDragging = true;
            wasDragging = false;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragCurrentX = e.clientX;
            dragCurrentY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            // Handle food placement drag
            if (isPlacing && foodPlacementActive) {
                placeFood(e.clientX, e.clientY);
                return;
            }

            // Handle selection drag
            if (isDragging) {
                dragCurrentX = e.clientX;
                dragCurrentY = e.clientY;

                // Check if we've exceeded the threshold to be considered a drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                if (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold) {
                    wasDragging = true;
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            isPlacing = false;

            if (isDragging) {
                isDragging = false;

                // Check if this was a significant drag
                const dx = dragCurrentX - dragStartX;
                const dy = dragCurrentY - dragStartY;
                const wasDragSelection = Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold;

                if (wasDragSelection) {
                    // Find ants in selection rectangle
                    const selectedAnts = findAntsInRect(dragStartX, dragStartY, dragCurrentX, dragCurrentY);
                    if (selectedAnts.length > 0) {
                        // Select a random ant from the selection (more interesting than always first)
                        const randomAnt = selectedAnts[Math.floor(Math.random() * selectedAnts.length)];
                        showCharacterCard(generateAntCardData(randomAnt), randomAnt);
                    }
                    wasDragging = false;
                    return;
                }
            }

            // Only process click if we weren't dragging
            if (!wasDragging && !foodPlacementActive) {
                const entity = findClickedEntity(e.clientX, e.clientY);
                if (entity) {
                    if (entity.type === 'ant') {
                        showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                    } else if (entity.type === 'predator') {
                        showCharacterCard(PREDATOR_CARD_DATA[entity.key], null);
                    }
                }
            }
            wasDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isPlacing = false;
            isDragging = false;
            wasDragging = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();

            // If card is open, close it on any touch
            if (characterCardOpen) {
                closeCharacterCard();
                return;
            }

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            // If food placement is active, place food
            if (foodPlacementActive) {
                isPlacing = true;
                placeFood(touchX, touchY);
                return;
            }

            // Check if touching an entity (only when not placing food)
            const entity = findClickedEntity(touchX, touchY);
            if (entity) {
                if (entity.type === 'ant') {
                    showCharacterCard(generateAntCardData(entity.ant), entity.ant);
                } else if (entity.type === 'predator') {
                    showCharacterCard(PREDATOR_CARD_DATA[entity.key], null);
                }
                return;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isPlacing && foodPlacementActive && !characterCardOpen) placeFood(e.touches[0].clientX, e.touches[0].clientY);
        });

        canvas.addEventListener('touchend', () => isPlacing = false);

        // ===========================================
        // MAIN LOOP
        // ===========================================

        function update() {
            if (gameOver || upgradesPaused) return;

            time++;

            // Check if it's time to offer upgrades
            checkUpgradeTime();

            // Check if we should spawn more predators (every minute)
            checkPredatorSpawn();

            for (const ant of ants) ant.update();

            // Update all predators from arrays
            for (const spider of spiderPredators) spider.update();
            for (const beetle of beetlePredators) beetle.update();

            decayPheromones();
            updateAmbientParticles();
            updateSpawnNotifications();
            updateFoodTimers();
            updateDeathCounter();  // For Berserker skill
            updateTrailblazerBeacons();  // For Scout skill

            // Check for game over
            checkGameOver();
        }

        // Track spoiled food IDs this frame
        let spoiledFoodIds = new Set();

        function updateFoodTimers() {
            spoiledFoodIds.clear();

            // Update all food items and collect spoiled ones
            for (let i = foodItems.length - 1; i >= 0; i--) {
                const food = foodItems[i];
                food.update();

                if (food.spoiled) {
                    spoiledFoodIds.add(food.id);
                    foodItems.splice(i, 1);
                }
            }

            // If any food spoiled, remove carried pieces from that food
            if (spoiledFoodIds.size > 0) {
                for (const ant of ants) {
                    if (ant.carriedFoodPiece && spoiledFoodIds.has(ant.carriedFoodPiece.sourceFoodId)) {
                        // Food went bad - drop the carried piece
                        ant.carriedFoodPiece = null;
                        ant.carriedFoodValue = 0;
                        ant.targetFood = null;
                        ant.state = 'exploring';
                        ant.foundFoodRecently = false;
                    }
                }
            }
        }

        function drawHint() {
            if (!showHint) return;

            ctx.save();
            ctx.fillStyle = 'rgba(240, 235, 224, 0.5)';
            ctx.font = 'italic 16px "Playfair Display", Georgia, serif';
            ctx.textAlign = 'center';
            ctx.fillText('click to drop food', width / 2, height * 0.18);

            ctx.strokeStyle = 'rgba(240, 235, 224, 0.3)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(width / 2, height * 0.21);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.moveTo(width / 2 - 6, height * 0.26);
            ctx.lineTo(width / 2, height * 0.28);
            ctx.lineTo(width / 2 + 6, height * 0.26);
            ctx.stroke();
            ctx.restore();
        }

        function render() {
            drawGround();
            drawSpots();
            drawPheromones();
            drawNest();
            drawFood();
            drawTrailblazerBeacons();  // Scout skill beacons
            drawRoyalAuras();          // Queen skill auras
            drawAnts();
            // Draw all predators from arrays
            for (const spider of spiderPredators) spider.draw();
            for (const beetle of beetlePredators) beetle.draw();
            drawAmbientParticles();
            drawSpawnNotifications();
            drawHint();
            drawSelectionRect(); // Draw selection rectangle on top
        }

        // Draw Queen's Royal Decree aura
        function drawRoyalAuras() {
            for (const ant of ants) {
                if (ant.type === 'queen' && ant.hasSkill) {
                    const pulse = Math.sin(Date.now() / 400) * 0.15 + 0.85;

                    ctx.save();

                    // Outer soft glow
                    const gradient = ctx.createRadialGradient(ant.x, ant.y, 0, ant.x, ant.y, 120);
                    gradient.addColorStop(0, `rgba(150, 80, 180, ${0.15 * pulse})`);
                    gradient.addColorStop(0.5, `rgba(150, 80, 180, ${0.08 * pulse})`);
                    gradient.addColorStop(1, 'rgba(150, 80, 180, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(ant.x, ant.y, 120, 0, Math.PI * 2);
                    ctx.fill();

                    // Animated ring
                    ctx.strokeStyle = `rgba(180, 100, 200, ${0.3 * pulse})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 12]);
                    ctx.lineDashOffset = -Date.now() / 30;
                    ctx.beginPath();
                    ctx.arc(ant.x, ant.y, 115, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                }
            }
        }

        function gameLoop() {
            update();
            render();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function resize() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);

            initPheromoneGrid();
            CONFIG.nestX = width * 0.5;
            CONFIG.nestY = height * 0.55;

            generateForestElements();
            generateGrass();
            initAmbientParticles();
        }

        function initPredators() {
            // Generate random spots first
            generateMapSpots();

            // Update CONFIG.predators positions from the spots
            for (const spot of predatorSpots) {
                if (spot.type === 'spider') {
                    CONFIG.predators.spider.x = spot.x;
                    CONFIG.predators.spider.y = spot.y;
                } else if (spot.type === 'beetle') {
                    CONFIG.predators.beetle.x = spot.x;
                    CONFIG.predators.beetle.y = spot.y;
                }
            }

            // Initialize predator arrays with one of each
            spiderPredators = [new Spider()];
            beetlePredators = [new Beetle()];
        }

        // Initialize
        resize();
        initAnts();
        initPredators();

        // Track initial ants as spawned
        totalAntsSpawned = ants.length;

        gameLoop();

        window.addEventListener('resize', resize);
    </script>
</body>
</html>
